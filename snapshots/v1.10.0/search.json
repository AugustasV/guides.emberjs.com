{"documents": [{"external_id":"b08ba4accecf68e2f43acec372677712","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/application/","type":"enum"},{"name":"body","value":"Creating an Application\nThe first step to creating an Ember.js application is to make an\ninstance of Ember.Application and assign it to a global variable.\n\n  1\n\n  window.App = Ember.Application.create();\n\n\n\nMost people call their application App, but you can call it whatever\nmakes the most sense to you. Just make sure it starts with a capital\nletter.\n\nWhat does creating an Ember.Application instance get you?\n\n\nIt is your application's namespace. All of the classes in your\napplication will be defined as properties on this object (e.g.,\nApp.PostsView and App.PostsController). This helps to prevent\npolluting the global scope.\nIt adds event listeners to the document and is responsible for\ndelegating events to your views. (See The View\nLayer\nfor a detailed description.)\nIt automatically renders the application\ntemplate.\nIt automatically creates a router and begins routing, choosing which\ntemplate and model to display based on the current URL.\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"47913aec12ee9dbd0749f8ee0c891428","fields":[{"name":"title","value":"Customizing a Component's Element","type":"string"},{"name":"url","value":"/components/customizing-a-components-element/","type":"enum"},{"name":"body","value":"By default, each component is backed by a \u003cdiv\u003e element. If you were\nto look at a rendered component in your developer tools, you would see\na DOM representation that looked something like:\n\n  1\n2\n3\n\n  \u003cdiv id=\"ember180\" class=\"ember-view\"\u003e\n  \u003ch1\u003eMy Component\u003c/h1\u003e\n\u003c/div\u003e\n\n\n\nYou can customize what type of element Ember generates for your\ncomponent, including its attributes and class names, by creating a\nsubclass of Ember.Component in your JavaScript.\nCustomizing the Element\nTo use a tag other than div, subclass Ember.Component and assign it\na tagName property. This property can be any valid HTML5 tag name as a\nstring.\n\n  1\n2\n3\n\n  App.NavigationBarComponent = Ember.Component.extend({\n  tagName: 'nav'\n});\n\n\n\n  1\n2\n3\n4\n5\n\n  {{! templates/components/navigation-bar }}\n\u003cul\u003e\n  \u003cli\u003e{{#link-to 'home'}}Home{{/link-to}}\u003c/li\u003e\n  \u003cli\u003e{{#link-to 'about'}}About{{/link-to}}\u003c/li\u003e\n\u003c/ul\u003e\n\n\nCustomizing Class Names\nYou can also specify which class names are applied to the component's\nelement by setting its classNames property to an array of strings:\n\n  1\n2\n3\n\n  App.NavigationBarComponent = Ember.Component.extend({\n  classNames: ['primary']\n});\n\n\n\nIf you want class names to be determined by properties of the component,\nyou can use class name bindings. If you bind to a Boolean property, the\nclass name will be added or removed depending on the value:\n\n  1\n2\n3\n4\n\n  App.TodoItemComponent = Ember.Component.extend({\n  classNameBindings: ['isUrgent'],\n  isUrgent: true\n});\n\n\n\nThis component would render the following:\n\n  1\n\n  \u003cdiv class=\"ember-view is-urgent\"\u003e\u003c/div\u003e\n\n\n\nIf isUrgent is changed to false, then the is-urgent class name will be removed.\n\nBy default, the name of the Boolean property is dasherized. You can customize the class name\napplied by delimiting it with a colon:\n\n  1\n2\n3\n4\n\n  App.TodoItemComponent = Ember.Component.extend({\n  classNameBindings: ['isUrgent:urgent'],\n  isUrgent: true\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view urgent\"\u003e\n\n\n\nBesides the custom class name for the value being true, you can also specify a class name which is used when the value is false:\n\n  1\n2\n3\n4\n\n  App.TodoItemComponent = Ember.Component.extend({\n  classNameBindings: ['isEnabled:enabled:disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nYou can also specify a class which should only be added when the property is\nfalse by declaring classNameBindings like this:\n\n  1\n2\n3\n4\n\n  App.TodoItemComponent = Ember.Component.extend({\n  classNameBindings: ['isEnabled::disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nIf the isEnabled property is set to true, no class name is added:\n\n  1\n\n  \u003cdiv class=\"ember-view\"\u003e\n\n\n\nIf the bound property's value is a string, that value will be added as a class name without\nmodification:\n\n  1\n2\n3\n4\n\n  App.TodoItemComponent = Ember.Component.extend({\n  classNameBindings: ['priority'],\n  priority: 'highestPriority'\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view highestPriority\"\u003e\n\n\nCustomizing Attributes\nYou can bind attributes to the DOM element that represents a component\nby using attributeBindings:\n\n  1\n2\n3\n4\n5\n\n  App.LinkItemComponent = Ember.Component.extend({\n  tagName: 'a',\n  attributeBindings: ['href'],\n  href: \"http://emberjs.com\"\n});\n\n\n\nYou can also bind these attributes to differently named properties:\n\n  1\n2\n3\n4\n5\n\n  App.LinkItemComponent = Ember.Component.extend({\n  tagName: 'a',\n  attributeBindings: ['customHref:href'],\n  customHref: \"http://emberjs.com\"\n});\n\n\nExample\nHere is an example todo application that shows completed todos with a\nred background:\n\nJS Bin\n\nNote: The binding functionality in this very simple example could also be implemented without\nthe use of Ember.Component but by simply binding element attributes or binding element class names.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6faa3aaa66dd8ba5f798d307f0136e3c","fields":[{"name":"title","value":"Defining a Component","type":"string"},{"name":"url","value":"/components/defining-a-component/","type":"enum"},{"name":"body","value":"To define a component, create a template whose name starts with\ncomponents/. To define a new component, {{blog-post}} for example,\ncreate a components/blog-post template.\n\nNote: Components must have a dash in their name. So blog-post is an acceptable name,\nbut post is not. This prevents clashes with current or future HTML element names, and\nensures Ember picks up the components automatically.\n\nIf you are including your Handlebars templates inside an HTML file via\n\u003cscript\u003e tags, it would look like this:\n\n  1\n2\n3\n4\n\n  \u003cscript type=\"text/x-handlebars\" id=\"components/blog-post\"\u003e\n  \u003ch1\u003eBlog Post\u003c/h1\u003e\n  \u003cp\u003eLorem ipsum dolor sit amet.\u003c/p\u003e\n\u003c/script\u003e\n\n\n\nIf you're using build tools, create a Handlebars file at\ntemplates/components/blog-post.handlebars.\n\nHaving a template whose name starts with components/ creates a\ncomponent of the same name. Given the above template, you can now use the\n{{blog-post}} custom element:\n\n  1\n2\n3\n4\n\n  \u003ch1\u003eMy Blog\u003c/h1\u003e\n{{#each post in model}}\n  {{blog-post}}\n{{/each}}\n\n\n\nJS Bin\n\nEach component, under the hood, is backed by an element. By default\nEmber will use a \u003cdiv\u003e element to contain your component's template.\nTo learn how to change the element Ember uses for your component, see\nCustomizing a Component's\nElement.\nDefining a Component Subclass\nOften times, your components will just encapsulate certain snippets of\nHandlebars templates that you find yourself using over and over. In\nthose cases, you do not need to write any JavaScript at all. Just define\nthe Handlebars template as described above and use the component that is\ncreated.\n\nIf you need to customize the behavior of the component you'll\nneed to define a subclass of Ember.Component. For example, you would\nneed a custom subclass if you wanted to change a component's element,\nrespond to actions from the component's template, or manually make\nchanges to the component's element using JavaScript.\n\nEmber knows which subclass powers a component based on its name. For\nexample, if you have a component called blog-post, you would create a\nsubclass called App.BlogPostComponent. If your component was called\naudio-player-controls, the class name would be\nApp.AudioPlayerControlsComponent.\n\nIn other words, Ember will look for a class with the camelized name of\nthe component, followed by Component.\n\n\n  \n  \n    Component Name\n    Component Class\n  \n  \n  \n    blog-post\n    App.BlogPostComponent\n  \n  \n    audio-player-controls\n    App.AudioPlayerControlsComponent\n  \n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"89cbe21cbd7181ade5de9485d9bd1da7","fields":[{"name":"title","value":"Handling User Interaction with Actions","type":"string"},{"name":"url","value":"/components/handling-user-interaction-with-actions/","type":"enum"},{"name":"body","value":"Components allow you to define controls that you can reuse throughout\nyour application. If they're generic enough, they can also be shared\nwith others and used in multiple applications.\n\nTo make a reusable control useful, however, you first need to allow\nusers of your application to interact with it.\n\nYou can make elements in your component interactive by using the\n{{action}} helper. This is the same {{action}} helper you use in\napplication templates, but it has an\nimportant difference when used inside a component.\n\nInstead of sending an action to the template's controller, then bubbling\nup the route hierarchy, actions sent from inside a component are sent\ndirectly to the component's Ember.Component instance, and do not\nbubble.\n\nFor example, imagine the following component that shows a post's title.\nWhen the title is clicked, the entire post body is shown:\n\n  1\n2\n3\n4\n5\n6\n\n  \u003cscript type=\"text/x-handlebars\" id=\"components/post-summary\"\u003e\n  \u003ch3 {{action \"toggleBody\"}}\u003e{{title}}\u003c/h3\u003e\n  {{#if isShowingBody}}\n    \u003cp\u003e{{{body}}}\u003c/p\u003e\n  {{/if}}\n\u003c/script\u003e\n\n\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.PostSummaryComponent = Ember.Component.extend({\n  actions: {\n    toggleBody: function() {\n      this.toggleProperty('isShowingBody');\n    }\n  }\n});\n\n\n\nJS Bin\n\nThe {{action}} helper can accept arguments, listen for different event\ntypes, control how action bubbling occurs, and more.\n\nFor details about using the {{action}} helper, see the Actions\nsection of the Templates chapter.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a7fac78db6b283e0bea80138768d18ef","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/components/","type":"enum"},{"name":"body","value":"HTML was designed in a time when the browser was a simple document\nviewer. Developers building great web apps need something more.\n\nInstead of trying to replace HTML, however, Ember.js embraces it, then adds\npowerful new features that modernize it for building web apps.\n\nCurrently, you are limited to the tags that are created for you by the\nW3C. Wouldn't it be great if you could define your own,\napplication-specific HTML tags, then implement their behavior using\nJavaScript?\n\nThat's exactly what components let you do. In fact, it's such a good\nidea that the W3C is currently working on the Custom\nElements\nspec.\n\nEmber's implementation of components hews as closely to the Web\nComponents specification as possible.\nOnce Custom Elements are widely available in browsers, you should be able to\neasily migrate your Ember components to the W3C standard and have them be\nusable by other frameworks.\n\nThis is so important to us that we are working closely with the\nstandards bodies to ensure our implementation of components matches the\nroadmap of the web platform.\n\nTo highlight the power of components, here is a short example of turning a blog post into a reusable\nblog-post custom element that you could use again and again in your\napplication. Keep reading this section for more details on building\ncomponents.\n\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8d2797c18261ac73c76de693da7cae13","fields":[{"name":"title","value":"Passing Properties to a Component","type":"string"},{"name":"url","value":"/components/passing-properties-to-a-component/","type":"enum"},{"name":"body","value":"By default a component does not have access to properties in the\ntemplate scope in which it is used.\n\nFor example, imagine you have a blog-post component that is used to\ndisplay a blog post:\n\n  1\n2\n3\n4\n\n  \u003cscript type=\"text/x-handlebars\" id=\"components/blog-post\"\u003e\n  \u003ch1\u003eComponent: {{title}}\u003c/h1\u003e\n  \u003cp\u003eLorem ipsum dolor sit amet.\u003c/p\u003e\n\u003c/script\u003e\n\n\n\nYou can see that it has a {{title}} Handlebars expression to print the\nvalue of the title property inside the \u003ch1\u003e.\n\nNow imagine we have the following template and route:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.IndexRoute = Ember.Route.extend({\n  model: function() {\n    return {\n      title: \"Rails is omakase\"\n    };\n  }\n});\n\n\n\n  1\n2\n3\n\n  {{! index.handlebars }}\n\u003ch1\u003eTemplate: {{title}}\u003c/h1\u003e\n{{blog-post}}\n\n\n\nRunning this code, you will see that the first \u003ch1\u003e (from the outer\ntemplate) displays the title property, but the second \u003ch1\u003e (from\ninside the component) is empty.\n\nJS Bin\n\nWe can fix this by making the title property available to the\ncomponent:\n\n  1\n\n  {{blog-post title=title}}\n\n\n\nThis will make the title property in the outer template scope\navailable inside the component's template using the same name, title.\n\nJS Bin\n\n\nIf, in the above example, the model's title property was instead\ncalled name, we would change the component usage to:\n\n  1\n\n  {{blog-post title=name}}\n\n\n\nJS Bin\n\n\nIn other words, you are binding a named property from the outer scope to\na named property in the component scope, with the syntax\ncomponentProperty=outerProperty.\n\nIt is important to note that the value of these properties is bound.\nWhether you change the value on the model or inside the component, the\nvalues stay in sync. In the following example, type some text in the\ntext field either in the outer template or inside the component and note\nhow they stay in sync.\n\nJS Bin\n\n\nYou can also bind properties from inside an {{#each}} loop. This will\ncreate a component for each item and bind it to each model in the loop.\n\n  1\n2\n3\n\n  {{#each post in model}}\n  {{blog-post title=post.title}}\n{{/each}}\n\n\n\nJS Bin\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a770b7ecc3a463d75a45227c9b80486","fields":[{"name":"title","value":"Sending Actions from Components to Your Application","type":"string"},{"name":"url","value":"/components/sending-actions-from-components-to-your-application/","type":"enum"},{"name":"body","value":"When a component is used inside a template, it has the ability to send\nactions to that template's controller and routes. These allow the\ncomponent to inform the application when important events, such as the\nuser clicking a particular element in a component, occur.\n\nLike the {{action}} Handlebars helper, actions sent from components\nfirst go to the template's controller. If the controller does not\nimplement a handler for that action, it will bubble to the template's\nroute, and then up the route hierarchy. For more information about this\nbubbling behavior, see Action\nBubbling.\n\nComponents are designed to be reusable across different parts of your\napplication. In order to achieve this reusability, it's important that\nthe actions that your components send can be specified when the component\nis used in a template.\n\nIn other words, if you were writing a button component, you would not\nwant to send a click action, because it is ambiguous and likely to\nconflict with other components on the page. Instead, you would want to\nallow the person using the component to specify which action to send\nwhen the button was clicked.\n\nLuckily, components have a sendAction() method that allows them to\nsend actions specified when the component is used in a template.\nSending a Primary Action\nMany components only send one kind of action. For example, a button\ncomponent might send an action when it is clicked on; this is the\nprimary action.\n\nTo set a component's primary action, set its action attribute in\nHandlebars:\n\n  1\n\n  {{my-button action=\"showUser\"}}\n\n\n\nThis tells the my-button component that it should send the showUser\naction when it triggers its primary action.\n\nSo how do you trigger sending a component's primary action? After\nthe relevant event occurs, you can call the sendAction() method\nwithout arguments:\n\n  1\n2\n3\n4\n5\n\n  App.MyButtonComponent = Ember.Component.extend({\n  click: function() {\n    this.sendAction();\n  }\n});\n\n\n\nIn the above example, the my-button component will send the showUser\naction when the component is clicked.\nSending Parameters with an Action\nYou may want to provide additional context to the route or controller\nhandling an action. For example, a button component may want to tell a\ncontroller not only that an item was deleted, but also which item.\n\nTo send parameters with the primary action, call sendAction() with the\nstring 'action' as the first argument and any additional parameters\nfollowing it:\n\n  1\n\n  this.sendAction('action', param1, param2);\n\n\n\nFor example, imagine we're building a todo list that allows the user to\ndelete a todo:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  App.IndexRoute = Ember.Route.extend({\n  model: function() {\n    return {\n      todos: [{\n        title: \"Learn Ember.js\"\n      }, {\n        title: \"Walk the dog\"\n      }]\n    };\n  },\n\n  actions: {\n    deleteTodo: function(todo) {\n      var todos = this.modelFor('index').todos;\n      todos.removeObject(todo);\n    }\n  }\n});\n\n\n\n  1\n2\n3\n4\n5\n\n  {{! index.handlebars }}\n\n{{#each todo in todos}}\n  \u003cp\u003e{{todo.title}} \u003cbutton {{action \"deleteTodo\" todo}}\u003eDelete\u003c/button\u003e\u003c/p\u003e\n{{/each}}\n\n\n\nWe want to update this app so that, before actually deleting a todo, the\nuser must confirm that this is what they intended. We'll implement a\ncomponent that first double-checks with the user before completing the\naction.\n\nIn the component, when triggering the primary action, we'll pass an\nadditional argument that the component user can specify:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  App.ConfirmButtonComponent = Ember.Component.extend({\n  actions: {\n    showConfirmation: function() {\n      this.toggleProperty('isShowingConfirmation');\n    },\n\n    confirm: function() {\n      this.toggleProperty('isShowingConfirmation');\n      this.sendAction('action', this.get('param'));\n    }\n  }\n});\n\n\n\n  1\n2\n3\n4\n5\n6\n7\n\n  {{! templates/components/confirm-button.handlebars }}\n\n{{#if isShowingConfirmation}}\n  \u003cbutton {{action \"confirm\"}}\u003eClick again to confirm\u003c/button\u003e\n{{else}}\n  \u003cbutton {{action \"showConfirmation\"}}\u003e{{title}}\u003c/button\u003e\n{{/if}}\n\n\n\nNow we can update our initial template and replace the {{action}}\nhelper with our new component:\n\n  1\n2\n3\n4\n5\n\n  {{! index.handlebars }}\n\n    {{#each todo in todos}}\n      \u003cp\u003e{{todo.title}} {{confirm-button title=\"Delete\" action=\"deleteTodo\" param=todo}}\u003c/p\u003e\n    {{/each}}\n\n\n\nNote that we've specified the action to send by setting the component's\naction attribute, and we've specified which argument should be sent as\na parameter by setting the component's param attribute.\n\nJS Bin\nSending Multiple Actions\nDepending on the complexity of your component, you may need to let users\nspecify multiple different actions for different events that your\ncomponent can generate.\n\nFor example, imagine that you're writing a form component that the user\ncan either submit or cancel. Depending on which button the user clicks,\nyou want to send a different action to your controller or route.\n\nYou can specify which action to send by passing the name of the event\nas the first argument to sendAction(). For example, you can specify two\nactions when using the form component:\n\n  1\n\n  {{user-form submit=\"createUser\" cancel=\"cancelUserCreation\"}}\n\n\n\nIn this case, you can send the createUser action by calling\nthis.sendAction('submit'), or send the cancelUserCreation action by\ncalling this.sendAction('cancel').\n\nJS Bin\nActions That Aren't Specified\nIf someone using your component does not specify an action for a\nparticular event, calling sendAction() has no effect.\n\nFor example, if you define a component that triggers the primary action\non click:\n\n  1\n2\n3\n4\n5\n\n  App.MyButtonComponent = Ember.Component.extend({\n  click: function() {\n    this.sendAction();\n  }\n});\n\n\n\nUsing this component without assigning a primary action will have no\neffect if the user clicks it:\n\n  1\n\n  {{my-button}}\n\n\nThinking About Component Actions\nIn general, you should think of component actions as translating a\nprimitive event (like a mouse click or an \u003caudio\u003e element's pause\nevent) into actions that have meaning within your application.\n\nThis allows your routes and controllers to implement action handlers\nwith names like deleteTodo or songDidPause instead of vague names\nlike click or pause that may be ambiguous to other developers when\nread out of context.\n\nAnother way to think of component actions is as the public API of your\ncomponent. Thinking about which events in your component can trigger\nactions in their application is the primary way other developers will\nuse your component. In general, keeping these events as generic as\npossible will lead to components that are more flexible and reusable.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e9763ebaa18b58c8fafed5531d19eb14","fields":[{"name":"title","value":"Wrapping Content in a Component","type":"string"},{"name":"url","value":"/components/wrapping-content-in-a-component/","type":"enum"},{"name":"body","value":"Sometimes, you may want to define a component that wraps content\nprovided by other templates.\n\nFor example, imagine we are building a blog-post component that we can\nuse in our application to display a blog post:\n\n  1\n2\n3\n4\n\n  \u003cscript type=\"text/x-handlebars\" id=\"components/blog-post\"\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cdiv class=\"body\"\u003e{{body}}\u003c/div\u003e\n\u003c/script\u003e\n\n\n\nNow, we can use the {{blog-post}} component and pass it properties\nin another template:\n\n  1\n\n  {{blog-post title=title body=body}}\n\n\n\nJS Bin\n\n(See Passing Properties to a\nComponent for\nmore.)\n\nIn this case, the content we wanted to display came from the model. But\nwhat if we want the developer using our component to be able to provide custom\nHTML content?\n\nIn addition to the simple form you've learned so far, components also\nsupport being used in block form. In block form, components can be\npassed a Handlebars template that is rendered inside the component's\ntemplate wherever the {{yield}} expression appears.\n\nTo use the block form, add a # character to the\nbeginning of the component name, then make sure to add a closing tag.\n(See the Handlebars documentation on block expressions for more.)\n\nIn that case, we can use the {{blog-post}} component in block form\nand tell Ember where the block content should be rendered using the\n{{yield}} helper. To update the example above, we'll first change the component's\ntemplate:\n\n  1\n2\n3\n4\n\n  \u003cscript type=\"text/x-handlebars\" id=\"components/blog-post\"\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cdiv class=\"body\"\u003e{{yield}}\u003c/div\u003e\n\u003c/script\u003e\n\n\n\nYou can see that we've replaced {{body}} with {{yield}}. This tells\nEmber that this content will be provided when the component is used.\n\nNext, we'll update the template using the component to use the block\nform:\n\n  1\n2\n3\n4\n\n  {{#blog-post title=title}}\n  \u003cp class=\"author\"\u003eby {{author}}\u003c/p\u003e\n  {{body}}\n{{/blog-post}}\n\n\n\nJS Bin\n\nIt's important to note that the template scope inside the component\nblock is the same as outside. If a property is available in the template\noutside the component, it is also available inside the component block.\n\nThis JSBin illustrates the concept:\n\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2ae1d52f685486a7d60a04e02e241913","fields":[{"name":"title","value":"Core Concepts","type":"string"},{"name":"url","value":"/concepts/core-concepts/","type":"enum"},{"name":"body","value":"To get started with Ember.js, there are a few core concepts you\nshould understand. \n\nEmber.js is designed to help developers build ambitiously large web\napplications that are competitive with native apps. Doing so requires\nboth new tools and a new vocabulary of concepts. We've spent a lot of\ntime borrowing ideas pioneered by native application frameworks like\nCocoa and Smalltalk.\n\nHowever, it's important to remember what makes the web special. Many\npeople think that something is a web application because it uses\ntechnologies like HTML, CSS and JavaScript. In reality, these are just\nimplementation details.\n\nInstead, the web derives its power from the ability to bookmark and\nshare URLs. URLs are the key feature that give web applications\nsuperior shareability and collaboration. Today, most JavaScript\nframeworks treat the URL as an afterthought, instead of the primary\nreason for the web's success.\n\nEmber.js, therefore, marries the tools and concepts of native\nGUI frameworks with support for the feature that makes the web so\npowerful: the URL.\nConceptsTemplates\nA template, written in the Handlebars templating language, describes\nthe user interface of your application. Each template is backed by a\nmodel, and the template automatically updates itself if the model changes.\n\nIn addition to plain HTML, templates can contain:\n\n\nExpressions, like {{firstName}}, which take information from\nthe template's model and put it into HTML.\nOutlets, which are placeholders for other templates. As users\nmove around your app, different templates can be plugged into the\noutlet by the router. You can put outlets into your template using the\n{{outlet}} helper.\nComponents, custom HTML elements that you can use to clean up\nrepetitive templates or create reusable controls.\n\nRouter\nThe router translates a URL into a series of nested templates, each\nbacked by a model. As the templates or models being shown to the user\nchange, Ember automatically keeps the URL in the browser's address bar\nup-to-date.\n\nThis means that, at any point, users are able to share the URL of your\napp. When someone clicks the link, they reliably see the same content as\nthe original user.\nComponents\nA component is a custom HTML tag whose behavior you implement using\nJavaScript and whose appearance you describe using Handlebars templates.\nThey allow you to create reusable controls that can simplify your\napplication's templates.\nModels\nA model is an object that stores persistent state. Templates are\nresponsible for displaying the model to the user by turning it into\nHTML. In many applications, models are loaded via an HTTP JSON API,\nalthough Ember is agnostic to the backend that you choose.\nRoute\nA route is an object that tells the template which model it should\ndisplay.\nControllers\nA controller is an object that stores application state. A\ntemplate can optionally have a controller in addition to a model, and\ncan retrieve properties from both.\n\n\n\nThese are the core concepts you'll need to understand as you develop\nyour Ember.js app. They are designed to scale up in complexity, so that\nadding new functionality doesn't force you to go back and refactor major \nparts of your app.\n\nNow that you understand the roles of these objects, you're equipped to\ndive deep into Ember.js and learn the details of how each of these\nindividual pieces work.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c8116f59e37526b373ebee360ffadc30","fields":[{"name":"title","value":"Naming Conventions","type":"string"},{"name":"url","value":"/concepts/naming-conventions/","type":"enum"},{"name":"body","value":"Ember.js uses naming conventions to wire up your objects without a\nlot of boilerplate. You will want to use these conventional names\nfor your routes, controllers and templates.\n\nYou can usually guess the names, but this guide outlines, in one place, \nall of the naming conventions. In the following examples 'App' is a name \nthat we chose to namespace or represent our Ember application when it was \ncreated, but you can choose any name you want for your application.\nWe will show you later how to create an Ember application, but for now we\nwill focus on conventions.\nThe Application\nWhen your application boots, Ember will look for these objects:\n\n\nApp.ApplicationRoute\nApp.ApplicationController\nthe application template\n\n\nEmber.js will render the application template as the main template.\nIf App.ApplicationController is provided, Ember.js will set an\ninstance of App.ApplicationController as the controller for the\ntemplate. This means that the template will get its properties from\nthe controller.\n\nIf your app provides an App.ApplicationRoute, Ember.js will invoke\nthe router's hooks first, before rendering the\napplication template. Hooks are implemented as methods and provide \nyou access points within an Ember object's lifecycle to intercept and \nexecute code to modify the default behavior at these points to meet \nyour needs. Ember provides several hooks for you to utilize for various\npurposes (e.g. model, setupController, etc). In the example below \nApp.ApplicationRoute, which is an Ember.Route object, implements \nthe setupController hook.\n\nHere's a simple example that uses a route, controller, and template:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  App.ApplicationRoute = Ember.Route.extend({\n  setupController: function(controller) {\n    // `controller` is the instance of ApplicationController\n    controller.set('title', \"Hello world!\");\n  }\n});\n\nApp.ApplicationController = Ember.Controller.extend({\n  appName: 'My First Example'\n});\n\n\n\n  1\n2\n3\n4\n\n  \u003c!-- application template --\u003e\n\u003ch1\u003e{{appName}}\u003c/h1\u003e\n\n\u003ch2\u003e{{title}}\u003c/h2\u003e\n\n\n\nIn Ember.js applications, you will always specify your controllers\nas classes, and the framework is responsible for instantiating\nthem and providing them to your templates.\n\nThis makes it super-simple to test your controllers, and ensures that\nyour entire application shares a single instance of each controller.\nSimple Routes\nEach of your routes will have a controller, and a template with the \nsame name as the route.\n\nLet's start with a simple router:\n\n  1\n2\n3\n\n  App.Router.map(function() {\n  this.route('favorites');\n});\n\n\n\nIf your user navigates to /favorites, Ember.js will look for these\nobjects:\n\n\nApp.FavoritesRoute\nApp.FavoritesController\nthe favorites template\n\n\nEmber.js will render the favorites template into the {{outlet}}\nin the application template. It will set an instance of the\nApp.FavoritesController as the controller for the template.\n\nIf your app provides an App.FavoritesRoute, the framework will\ninvoke it before rendering the template. Yes, this is a bit\nrepetitive.\n\nFor a route like App.FavoritesRoute, you will probably implement\nthe model hook to specify what model your controller will present\nto the template.\n\nHere's an example:\n\n  1\n2\n3\n4\n5\n6\n\n  App.FavoritesRoute = Ember.Route.extend({\n  model: function() {\n    // the model is an Array of all of the posts\n    return this.store.find('post');\n  }\n});\n\n\n\nIn this example, we didn't provide a FavoritesController. Because\nthe model is an Array, Ember.js will automatically supply an instance\nof Ember.ArrayController, which will present the backing Array as\nits model.\n\nYou can treat the ArrayController as if it was the model itself.\nThis has two major benefits:\n\n\nYou can replace the controller's model at any time without having\nto directly notify the view of the change.\nThe controller can provide additional computed properties or\nview-specific state that do not belong in the model layer. This\nallows a clean separation of concerns between the view, the\ncontroller and the model.\n\n\nThe template can iterate over the elements of the controller:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n{{#each item in controller}}\n  \u003cli\u003e{{item.title}}\u003c/li\u003e\n{{/each}}\n\u003c/ul\u003e\n\n\nDynamic Segments\nIf a route uses a dynamic segment (a URL that includes a parameter), the route's model will be based\non the value of that segment provided by the user.\n\nConsider this router definition:\n\n  1\n2\n3\n\n  App.Router.map(function() {\n  this.resource('post', { path: '/posts/:post_id' });\n});\n\n\n\nIn this case, the route's name is post, so Ember.js will look for\nthese objects:\n\n\nApp.PostRoute\nApp.PostController\nthe post template\n\n\nYour route handler's model hook converts the dynamic :post_id\nparameter into a model. The serialize hook converts a model object\nback into the URL parameters for this route (for example, when\ngenerating a link for a model object).\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.PostRoute = Ember.Route.extend({\n  model: function(params) {\n    return this.store.find('post', params.post_id);\n  },\n\n  serialize: function(post) {\n    return { post_id: post.get('id') };\n  }\n});\n\n\n\nBecause this pattern is so common, it is the default for route\nhandlers.\n\n\nIf your dynamic segment ends in _id, the default model\nhook will convert the first part into a model class on the\napplication's namespace (post becomes App.Post). It will\nthen call find on that class with the value of the dynamic\nsegment.\nThe default behaviour of the serialize hook is to replace \nthe route's dynamic segment with the value of the model \nobject's id property.\n\nRoute, Controller and Template Defaults\nIf you don't specify a route handler for the post route\n(App.PostRoute), Ember.js  will still render the post\ntemplate with the app's instance of App.PostController.\n\nIf you don't specify the controller (App.PostController),\nEmber will automatically make one for you based on the return value\nof the route's model hook. If the model is an Array, you get an\nArrayController. Otherwise, you get an ObjectController.\n\nIf you don't specify a post template, Ember.js won't render\nanything!\nNesting\nYou can nest routes under a resource.\n\n  1\n2\n3\n4\n5\n6\n\n  App.Router.map(function() {\n  this.resource('posts', function() { // the `posts` route\n    this.route('favorites');          // the `posts.favorites` route\n    this.resource('post');            // the `post` route\n  });\n});\n\n\n\nA resource is the beginning of a route, controller, or template\nname. Even though the post resource is nested, its route is named\nApp.PostRoute, its controller is named App.PostController and its\ntemplate is post.\n\nWhen you nest a route inside a resource, the route name is added\nto the resource name, after a ..\n\nHere are the naming conventions for each of the routes defined in\nthis router:\n\n\n  \n  \n    Route Name\n    Controller\n    Route\n    Template\n  \n  \n  \n    posts\n    PostsController\n    PostsRoute\n    posts\n  \n  \n    posts.favorites\n    PostsFavoritesController\n    PostsFavoritesRoute\n    posts/favorites\n  \n  \n    post\n    PostController\n    PostRoute\n    post\n  \n\n\nThe rule of thumb is to use resources for nouns, and routes for\nadjectives (favorites) or verbs (edit). This ensures that\nnesting does not create ridiculously long names, but avoids\ncollisions with common adjectives and verbs.\nThe Index Route\nAt every level of nesting (including the top level), Ember.js\nautomatically provides a route for the / path named index.\n\nFor example, if you write a simple router like this:\n\n  1\n2\n3\n\n  App.Router.map(function() {\n  this.route('favorites');\n});\n\n\n\nIt is the equivalent of:\n\n  1\n2\n3\n4\n\n  App.Router.map(function() {\n  this.route('index', { path: '/' });\n  this.route('favorites');\n});\n\n\n\nIf the user visits /, Ember.js will look for these objects:\n\n\nApp.IndexRoute\nApp.IndexController\nthe index template\n\n\nThe index template will be rendered into the {{outlet}} in the\napplication template. If the user navigates to /favorites,\nEmber.js will replace the index template with the favorites\ntemplate.\n\nA nested router like this:\n\n  1\n2\n3\n4\n5\n\n  App.Router.map(function() {\n  this.resource('posts', function() {\n    this.route('favorites');\n  });\n});\n\n\n\nIs the equivalent of:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.Router.map(function() {\n  this.route('index', { path: '/' });\n  this.resource('posts', function() {\n    this.route('index', { path: '/' });\n    this.route('favorites');\n  });\n});\n\n\n\nIf the user navigates to /posts, the current route will be\nposts.index. Ember.js will look for objects named:\n\n\nApp.PostsIndexRoute\nApp.PostsIndexController\nThe posts/index template\n\n\nFirst, the posts template will be rendered into the {{outlet}}\nin the application template. Then, the posts/index template\nwill be rendered into the {{outlet}} in the posts template.\n\nIf the user then navigates to /posts/favorites, Ember.js will\nreplace the {{outlet}} in the posts template with the\nposts/favorites template.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"70e329941930eb4995e87499f75284e4","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/concepts/understanding-web-apps/","type":"enum"},{"name":"body","value":"Traditional web applications make the user download a new page every time\nthey interact with the server. This means that every interaction is never faster\nthan the latency between you and the user, and usually slower. Using AJAX to\nreplace only parts of the page helps somewhat, but still requires a roundtrip to\nyour server every time your UI needs to update. And if multiple parts of the\npage need to update all at once, most developers just resort to loading the page\nover again, since keeping everything in sync is tricky.\n\nEmber.js, like some other modern JavaScript frameworks, works a little differently.\nInstead of the majority of your application's logic living on the server, an\nEmber.js application downloads everything it needs to run in the initial page\nload. That means that while your user is using your app, she never has to load\na new page and your UI responds quickly to their interaction.\n\nOne advantage of this architecture is that your web application uses the same\nREST API as your native apps or third-party clients. Back-end developers can\nfocus on building a fast, reliable, and secure API server, and don't have to be\nfront-end experts, too.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d39f80aed7361b80c062019ee885f7cf","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/concepts/what-is-ember-js/","type":"enum"},{"name":"body","value":"What is Ember.js?\nEmber.js is a JavaScript framework for creating ambitious web\napplications. It helps you:\n\n\nWrite less code with templates that automatically update.\nRetrieve models, with rich relationships, from your server.\nConventional app structure helps your app grow without messy code.\n\nEnhancing JavaScriptEliminating Boilerplate\nThere are some things that every web app developer has to do. For\nexample, everyone has written code that loads data from a server,\nrenders it to the screen, then updates if it changes.\n\nSince the tools provided to do this by the browser are quite primitive,\nyou end up writing the same code over and over. Ember.js provides tools\nthat let you focus on your app instead of writing the same code you've\nwritten a hundred times.\n\nBecause we've built many applications ourselves, we've extracted\npatterns that go beyond low-level event-driven abstractions. We've\neliminated much of the boilerplate associated with propagating changes\nthroughout your application, and especially into the DOM itself.\n\nFor example, to help manage changes in the view, Ember.js comes with a\ntemplating engine that will automatically update the DOM when the\nobject it is bound to changes.\n\nFor a simple example, consider this template:\n\n  1\n\n  User {{person.name}} is {{person.age}} years old.\n\n\n\nAs with any templating system, when the template is initially rendered,\nit will reflect the current state of the person.  In Ember.js, though,\nwe also update the DOM automatically for you if the person's name or age\nchanges—no re-render or update code needed. Just specify your template\nonce, and Ember makes sure it stays up-to-date.\n\nTemplates are just one example. As you read through these guides, you'll\nsee how Ember.js allows you to forget about stuff that you'd have to\nhandle manually in other frameworks—from data persistence to memory\nmanagement.\nApplication Architecture\nSince web applications evolved from web pages, which were nothing more\nthan static documents, the primitive APIs supplied by the browser give\nyou just enough rope to hang yourself with.\n\nEmber.js helps you build your app with a clear separation of concerns in\nmind, leading to code that is more modular, more testable, and more\nconsistent.\n\nWe also supply built-in support for state management, so you'll have\na way to describe how your application moves through various nested states\n(like signed-out, signed-in, viewing-post, and viewing-comment) out of the box.\nEmber.js at a Glance\nThese are the three features that make Ember a joy to use:\n\n\nBindings\nComputed properties\nAuto-updating templates\n\nBindings\nUse bindings to keep properties between two different objects in sync. You just\ndeclare a binding once, and Ember will make sure changes get propagated in either\ndirection.\n\nHere's how you create a binding between two objects:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  MyApp.president = Ember.Object.create({\n  name: \"Barack Obama\"\n});\n\nMyApp.country = Ember.Object.create({\n  // Ending a property with 'Binding' tells Ember to\n  // create a binding to the presidentName property.\n  presidentNameBinding: 'MyApp.president.name'\n});\n\n// Later, after Ember has resolved bindings...\nMyApp.country.get('presidentName');\n// \"Barack Obama\"\n\n\n\nBindings allow you to architect your application using the MVC (Model-View-Controller)\npattern, then rest easy knowing that data will always flow correctly from layer to layer.\nComputed Properties\nComputed properties allow you to treat a function like a property:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  MyApp.president = Ember.Object.create({\n  firstName: \"Barack\",\n  lastName: \"Obama\",\n\n  fullName: function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n\n  // Call this flag to mark the function as a property\n  }.property()\n});\n\nMyApp.president.get('fullName');\n// \"Barack Obama\"\n\n\n\nComputed properties are useful because they can work with bindings, just\nlike any other property.\n\nMany computed properties have dependencies on other properties. For example, in the above\nexample, the fullName property depends on firstName and lastName to determine its value.\nYou can tell Ember about these dependencies like this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  MyApp.president = Ember.Object.create({\n  firstName: \"Barack\",\n  lastName: \"Obama\",\n\n  fullName: function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n\n  // Tell Ember that this computed property depends on firstName\n  // and lastName\n  }.property('firstName', 'lastName')\n});\n\n\n\nMake sure you list these dependencies so Ember knows when to update bindings that connect\nto a computed property.\nAuto-updating Templates\nEmber uses Handlebars, a semantic templating library. To take data from your JavaScript application\nand put it into the DOM, create a \u003cscript\u003e tag and put it into your HTML, wherever you'd like the\nvalue to appear:\n\n  1\n2\n3\n\n  \u003cscript type=\"text/x-handlebars\"\u003e\n  The President of the United States is {{MyApp.president.fullName}}.\n\u003c/script\u003e\n\n\n\nHere's the best part: templates are bindings-aware. That means that if you ever change the value of\nthe property that you told us to display, we'll update it for you automatically. And because you've\nspecified dependencies, changes to those properties are reflected as well.\n\nHopefully you can see how all three of these powerful tools work together: start with some primitive\nproperties, then start building up more sophisticated properties and their dependencies using computed\nproperties. Once you've described the data, you only have to say how it gets displayed once, and Ember\ntakes care of the rest. It doesn't matter how the underlying data changes, whether from an XHR request\nor the user performing an action; your user interface always stays up-to-date. This eliminates entire\ncategories of edge cases that developers struggle with every day.\nDifferences from Server-Side MVC\nA common misconception about Ember.js's MVC implementation is that it must be similar to that of Ruby on Rails. This is incorrect. \n\nThe reason for this difference is due to Ruby on Rails being a server-side framework, whereas Ember is a client-side framework.[1]\n\nEmber runs in the browser, so it can detect and respond to browser events such as mouse clicks, finger taps, scrolling, key presses, etc. The view objects that receive these events can then send them to controller objects, which can work with the data model to save changes. Everything happens client-side, in the browser, and ember-data takes care of sending and receiving appropriate data to and from the server API.\n\n\n  \n\n\nRails, on the other hand, runs on the server. As such, it can only communicate with the client through HTTP requests. Rather than receive direct user events, the server takes HTTP requests as input (GET /, POST /users/1, etc.), reads the route and maps it to a controller action. The controller then interacts with the model and the view templates to construct a response (usually in the form of an HTML document) to send back over HTTP. The user is always interacting with what is basically a flat page, assembled on demand for them based on their requests.\n\n\n  \n\n\nIt is important to keep this difference in mind when architecting your applications. \n\n[1] Although it is possible to use Ember.js on the server side, that is beyond the scope of this guide.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"62986c9e6cbee2077f1bd848372a19dc","fields":[{"name":"title","value":"Disabling Prototype Extensions","type":"string"},{"name":"url","value":"/configuring-ember/disabling-prototype-extensions/","type":"enum"},{"name":"body","value":"By default, Ember.js will extend the prototypes of native JavaScript\nobjects in the following ways:\n\n\nArray is extended to implement the Ember.Enumerable,\nEmber.MutableEnumerable, Ember.MutableArray and Ember.Array\ninterfaces. This polyfills ECMAScript 5 array methods in browsers that\ndo not implement them, adds convenience methods and properties to\nbuilt-in arrays, and makes array mutations observable.\nString is extended to add convenience methods, such as\ncamelize() and fmt(). \nFunction is extended with methods to annotate functions as\ncomputed properties, via the property() method, and as observers,\nvia the observes() or observesBefore() methods.\n\n\nThis is the extent to which Ember.js enhances native prototypes. We have\ncarefully weighed the tradeoffs involved with changing these prototypes,\nand recommend that most Ember.js developers use them. These extensions\nsignificantly reduce the amount of boilerplate code that must be typed.\n\nHowever, we understand that there are cases where your Ember.js\napplication may be embedded in an environment beyond your control. The\nmost common scenarios are when authoring third-party JavaScript that is\nembedded directly in other pages, or when transitioning an application\npiecemeal to a more modern Ember.js architecture.\n\nIn those cases, where you can't or don't want to modify native\nprototypes, Ember.js allows you to completely disable the extensions\ndescribed above.\n\nTo do so, simply set the EXTEND_PROTOTYPES flag to false:\n\n  1\n2\n\n  window.EmberENV = {};\nEmberENV.EXTEND_PROTOTYPES = false;\n\n\n\nOr you can choose class which you want to disable prototype extension.\njavascript\nEmberENV.EXTEND_PROTOTYPES = {\n  String: false,\n  Array: true\n};\n\n\nNote that the above code must be evaluated before Ember.js loads. If\nyou set the flag after the Ember.js JavaScript file has been evaluated,\nthe native prototypes will already have been modified.\nLife Without Prototype Extension\nIn order for your application to behave correctly, you will need to\nmanually extend or create the objects that the native objects were\ncreating before.\nArrays\nNative arrays will no longer implement the functionality needed to\nobserve them. If you disable prototype extension and attempt to use\nnative arrays with things like a template's {{#each}} helper, Ember.js\nwill have no way to detect changes to the array and the template will\nnot update as the underlying array changes.\n\nAdditionally, if you try to set the model of an\nEmber.ArrayController to a plain native array, it will raise an\nexception since it no longer implements the Ember.Array interface.\n\nYou can manually coerce a native array into an array that implements the\nrequired interfaces using the convenience method Ember.A:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var islands = ['Oahu', 'Kauai'];\nislands.contains('Oahu');\n//=\u003e TypeError: Object Oahu,Kauai has no method 'contains'\n\n// Convert `islands` to an array that implements the\n// Ember enumerable and array interfaces\nEmber.A(islands);\n\nislands.contains('Oahu');\n//=\u003e true\n\n\nStrings\nStrings will no longer have the convenience methods described in the\nEmber.String API reference.. Instead,\nyou can use the similarly-named methods of the Ember.String object and\npass the string to use as the first parameter:\n\n  1\n2\n3\n4\n5\n\n  \"my_cool_class\".camelize();\n//=\u003e TypeError: Object my_cool_class has no method 'camelize'\n\nEmber.String.camelize(\"my_cool_class\");\n//=\u003e \"myCoolClass\"\n\n\nFunctions\nTo annotate computed properties, use the Ember.computed() method to\nwrap the function:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // This won't work:\nfullName: function() {\n  return this.get('firstName') + ' ' + this.get('lastName');\n}.property('firstName', 'lastName')\n\n\n// Instead, do this:\nfullName: Ember.computed('firstName', 'lastName', function() {\n  return this.get('firstName') + ' ' + this.get('lastName');\n})\n\n\n\nObservers are annotated using Ember.observer():\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // This won't work:\nfullNameDidChange: function() {\n  console.log(\"Full name changed\");\n}.observes('fullName')\n\n\n// Instead, do this:\nfullNameDidChange: Ember.observer('fullName', function() {\n  console.log(\"Full name changed\");\n})\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"479923146262192b72f2b6cd4e92d83b","fields":[{"name":"title","value":"Embedding Applications","type":"string"},{"name":"url","value":"/configuring-ember/embedding-applications/","type":"enum"},{"name":"body","value":"In most cases, your application's entire UI will be created by templates\nthat are managed by the router.\n\nBut what if you have an Ember.js app that you need to embed into an\nexisting page, or run alongside other JavaScript frameworks?\nChanging the Root Element\nBy default, your application will render the application\ntemplate and attach it to\nthe document's body element.\n\nYou can tell the application to append the application template to a\ndifferent element by specifying its rootElement property:\n\n  1\n2\n3\n\n  App = Ember.Application.create({\n  rootElement: '#app'\n});\n\n\n\nThis property can be specified as either an element or a\njQuery-compatible selector\nstring.\nDisabling URL Management\nYou can prevent Ember from making changes to the URL by changing the\nrouter's location to\nnone:\n\n  1\n2\n3\n\n  App.Router = Ember.Router.extend({\n  location: 'none'\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"32ec1a30c836c88e234758571f01a21e","fields":[{"name":"title","value":"Feature Flags","type":"string"},{"name":"url","value":"/configuring-ember/feature-flags/","type":"enum"},{"name":"body","value":"About Features\nWhen a new feature is added to Ember they will be written in such a way that the\nfeature can be conditionally included in the generated build output and enabled\n(or completely removed) based on whether a particular flag is present. This\nallows newly developed features to be selectively released when they are\nconsidered ready for production use.\nFeature Life-Cycle\nWhen a new feature is flagged it is only available in canary builds (if enabled\nat runtime). When it is time for the next beta cycle to be started (generally\n6-12 week cycles) each feature will be evaluated and those features that are\nready will be enabled in the next beta (and subsequently automatically enabled\nin all future canary builds).\n\nIf a given feature is deemed unstable it will be disabled in the next beta point\nrelease, and not be included in the next stable release. It may still be included\nin the next beta cycle if the issues/concerns have been resolved.\n\nOnce the beta cycle has completed the final release will include any features that\nwere enabled during that cycle. At this point the feature flags will be removed from\nthe canary and future beta branches, and the feature flag will no longer be used.\nFlagging Details\nThe flag status in the generated build output is controlled by the features.json\nfile in the root of the project. This file lists all features and their current\nstatus.\n\nA feature can have one of a few different statuses:\n\n\ntrue - The feature is enabled: the code behind the flag is always enabled in\nthe generated build.\nfalse - The feature is disabled: the code behind the flag is not present in\nthe generated build at all.\nnull - The feature is present in the build output, but must be enabled at\nruntime (it is still behind feature flags).\n\n\nThe process of removing the feature flags from the resulting build output is\nhandled by defeatureify.\nFeature Listing (FEATURES.md)\nWhen a new feature is added to the canary channel (aka master branch), an\nentry is added to FEATURES.md\nexplaining what the feature does (and linking the originating pull request).\nThis listing is kept current, and reflects what is available in each branch\n(stable,beta, and master).\nEnabling At Runtime\nThe only time a feature can be enabled at runtime is if the\nfeatures.json for that build contains null (technically, anything other\nthan true or false will do, but null is the chosen value).\n\nA global EmberENV object will be used to initialize the Ember.ENV\nobject, and any feature flags that are enabled/disabled under\nEmberENV.FEATURES will be migrated to Ember.FEATURES; those features\nwill be enabled based on the flag value. Ember only reads the\nEmberENV value upon initial load so setting this value after Ember has\nbeen loaded will have no affect.\n\nExample:\n\n  1\n\n  EmberENV = {FEATURES: {'link-to': true}};\n\n\n\nAdditionally you can define EmberENV.ENABLE_ALL_FEATURES to force all\nfeatures to be enabled.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3cddcc7a01c23b72f74ea3eceaaada93","fields":[{"name":"title","value":"Adding New Features","type":"string"},{"name":"url","value":"/contributing/adding-new-features/","type":"enum"},{"name":"body","value":"In general, new feature development should be done on master.\n\nBugfixes should not introduce new APIs or break existing APIs, and do\nnot need feature flags.\n\nFeatures can introduce new APIs, and need feature flags. They should not\nbe applied to the release or beta branches, since SemVer requires\nbumping the minor version to introduce new features.\n\nSecurity fixes should not introduce new APIs, but may, if strictly\nnecessary, break existing APIs. Such breakages should be as limited as\npossible.\nBug FixesUrgent Bug Fixes\nUrgent bugfixes are bugfixes that need to be applied to the existing\nrelease branch. If possible, they should be made on master and prefixed\nwith [BUGFIX release].\nBeta Bug Fixes\nBeta bugfixes are bugfixes that need to be applied to the beta branch.\nIf possible, they should be made on master and tagged with [BUGFIX\nbeta].\nSecurity Fixes\nSecurity fixes need to be applied to the beta branch, the current\nrelease branch, and the previous tag. If possible, they should be made\non master and tagged with [SECURITY].\nFeatures\nFeatures must always be wrapped in a feature flag. Tests for the feature\nmust also be wrapped in a feature flag.\n\nBecause the build-tools will process feature-flags, flags must use\nprecisely this format. We are choosing conditionals rather than a block\nform because functions change the surrounding scope and may introduce\nproblems with early return.\n\n  1\n2\n3\n\n  if (Ember.FEATURES.isEnabled(\"feature\")) {\n  // implementation\n} \n\n\n\nTests will always run with all features on, so make sure that any tests\nfor the feature are passing against the current state of the feature.\nCommits\nCommits related to a specific feature should include  a prefix like\n[FEATURE htmlbars]. This will allow us to quickly identify all commits\nfor a specific feature in the future. Features will never be applied to\nbeta or release branches. Once a beta or release branch has been cut, it\ncontains all of the new features it will ever have.\n\nIf a feature has made it into beta or release, and you make a commit to\nmaster that fixes a bug in the feature, treat it like a bugfix as\ndescribed above.\nFeature Naming Conventions\n  1\n2\n3\n\n  Ember.FEATURES[\"\u003cpackageName\u003e-\u003cfeature\u003e\"] // if package specific\nEmber.FEATURES[\"container-factory-injections\"]\nEmber.FEATURES[\"htmlbars\"]\n\n\nBuilds\nThe Canary build, which is based off master, will include all features,\nguarded by the conditionals in the original source. This means that\nusers of the canary build can enable whatever features they want by\nenabling them before creating their Ember.Application.\n\n  1\n\n  Ember.FEATURES[\"htmlbars\"] = true;\n\n\nfeatures.json\nThe root of the repository will contain a features.json file, which will\ncontain a list of features that should be enabled for beta or release\nbuilds.\n\nThis file is populated when branching, and may not gain additional\nfeatures after the original branch. It may remove features.\n\n  1\n2\n3\n\n  {\n  \"htmlbars\": true\n}\n\n\n\nThe build process will remove any features not included in the list, and\nremove the conditionals for features in the list.\nTravis Testing\nFor a new PR:\n\n\nTravis will test against master with all feature flags on.\nIf a commit is tagged with [BUGFIX beta], Travis will also\ncherry-pick the commit into beta, and run the tests on that\nbranch. If the commit doesn't apply cleanly or the tests fail, the\ntests will fail.\nIf a commit is tagged with [BUGFIX release], Travis will also cherry-pick\nthe commit into release, and run the test on that branch. If the commit\ndoesn't apply cleanly or the tests fail, the tests will fail.\n\n\nFor a new commit to master:\n\n\nTravis will run the tests as described above.\nIf the build passes, Travis will cherry-pick the commits into the\nappropriate branches.\n\n\nThe idea is that new commits should be submitted as PRs to ensure they\napply cleanly, and once the merge button is pressed, Travis will apply\nthem to the right branches.\nGo/No-Go Process\nEvery six weeks, the core team goes through the following process.\nBeta Branch\nAll remaining features on the beta branch are vetted for readiness. If\nany feature isn't ready, it is removed from features.json.\n\nOnce this is done, the beta branch is tagged and merged into release.\nMaster Branch\nAll features on the master branch are vetted for readiness. In order for\na feature to be considered \"ready\" at this stage, it must be ready as-is\nwith no blockers. Features are a no-go even if they are close and\nadditional work on the beta branch would make it ready.\n\nBecause this process happens every six weeks, there will be another\nopportunity for a feature to make it soon enough.\n\nOnce this is done, the master branch is merged into beta. A\nfeatures.json file is added with the features that are ready.\nBeta Releases\nEvery week, we repeat the Go/No-Go process for the features that remain\non the beta branch. Any feature that has become unready is removed from\nthe features.json.\n\nOnce this is done, a Beta release is tagged and pushed.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"26d81f9d1949f3951aa7d9505e7280dd","fields":[{"name":"title","value":"Repositories","type":"string"},{"name":"url","value":"/contributing/repositories/","type":"enum"},{"name":"body","value":"Ember is made up of several libraries. If you wish to add a feature or fix a bug please file a pull request against the appropriate repository. Be sure to check the libraries listed below before making changes in the Ember.js repository.\nMain Repositories\nEmber.js - The main repository for Ember.\n\n\nhttps://github.com/emberjs/ember.js\n\n\nEmber Data - A data persistence library for Ember.js.\n\n\nhttps://github.com/emberjs/data\n\n\nEmber Website - Source for http://emberjs.com including these guides.\n\n\nhttps://github.com/emberjs/website\n\nLibraries Used By Ember\nThese libraries are part of the Ember.js source, but development of them takes place in a seperate repository.\npackages/ember-metal/lib/vendor/backburner.js\n\nbackburner.js - Implements the Ember run loop.\nhttps://github.com/ebryn/backburner.js\n\npackages/ember-routing/lib/vendor/route-recognizer.js\n\nroute-recognizer.js - A lightweight JavaScript library that matches paths against registered routes.\nhttps://github.com/tildeio/route-recognizer\n\npackages/ember-routing/lib/vendor/router.js\n\nrouter.js - A lightweight JavaScript library that builds on route-recognizer and rsvp to provide an API for handling routes.\nhttps://github.com/tildeio/router.js\n\npackages/metamorph\n\nMetamorph.js - Used by Ember for databinding handlebars templates\nhttps://github.com/tomhuda/metamorph.js\n\npackages/rsvp\n\nRSVP.js - Implementation of the of Promises/A+ spec used by Ember.\nhttps://github.com/tildeio/rsvp.js\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c34d88bfea40594c8c5d1478666d47a7","fields":[{"name":"title","value":"Managing Dependencies Between Controllers","type":"string"},{"name":"url","value":"/controllers/dependencies-between-controllers/","type":"enum"},{"name":"body","value":"Sometimes, especially when nesting resources, we find ourselves needing\nto have some kind of connection between two controllers. Let's take this\nrouter as an example:\n\n  1\n2\n3\n4\n5\n\n  App.Router.map(function() {\n  this.resource(\"post\", { path: \"/posts/:post_id\" }, function() {\n    this.resource(\"comments\", { path: \"/comments\" });\n  });\n});\n\n\n\nIf we visit a /posts/1/comments URL, our Post model will get\nloaded into a PostController's model, which means it is not directly\naccessible in the CommentsController. We might however want to display\nsome information about it in the comments template.\n\nTo be able to do this we define our CommentsController to need the PostController\nwhich has our desired Post model.\n\n  1\n2\n3\n\n  App.CommentsController = Ember.ArrayController.extend({\n  needs: \"post\"\n});\n\n\n\nThis tells Ember that our CommentsController should be able to access\nits parent PostController, which can be done via controllers.post\n(either in the template or in the controller itself).\n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003ch1\u003eComments for {{controllers.post.title}}\u003c/h1\u003e\n\n\u003cul\u003e\n  {{#each comment in comments}}\n    \u003cli\u003e{{comment.text}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nWe can also create an aliased property to give ourselves a shorter way to access\nthe PostController (since it is an ObjectController, we don't need\nor want the Post instance directly).\n\n  1\n2\n3\n4\n\n  App.CommentsController = Ember.ArrayController.extend({\n  needs: \"post\",\n  post: Ember.computed.alias(\"controllers.post\")\n});\n\n\n\nIf you want to connect multiple controllers together, you can specify an\narray of controller names:\n\n  1\n2\n3\n\n  App.AnotherController = Ember.Controller.extend({\n  needs: ['post', 'comments']\n});\n\n\n\nFor more information about dependecy injection and needs in Ember.js,\nsee the dependency injection guide.\nFor more information about aliases, see the API docs for\naliased properties.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f72002399f11df302a9dac49684ae8dc","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/controllers/","type":"enum"},{"name":"body","value":"Controllers\nIn Ember.js, controllers allow you to decorate your models with \ndisplay logic. In general, your models will have properties that\nare saved to the server, while controllers will have properties\nthat your app does not need to save to the server.\n\nFor example, if you were building a blog, you would have a\nBlogPost model that you would present in a blog_post template.\n\nYour BlogPost model would have properties like:\n\n\ntitle\nintro\nbody\nauthor\n\n\nYour template would bind to these properties in the blog_post \ntemplate:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003ch2\u003eby {{author}}\u003c/h2\u003e\n\n\u003cdiv class='intro'\u003e\n  {{intro}}\n\u003c/div\u003e\n\u003chr\u003e\n\u003cdiv class='body'\u003e\n  {{body}}\n\u003c/div\u003e\n\n\n\nIn this simple example, we don't have any display-specific properties\nor actions just yet. For now, our controller just acts as a\npass-through (or \"proxy\") for the model properties. (Remember that\na controller gets the model it represents from its route handler.)\n\nLet's say we wanted to add a feature that would allow the user to \ntoggle the display of the body section. To implement this, we would\nfirst modify our template to show the body only if the value of a \nnew isExpanded property is true.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003ch2\u003eby {{author}}\u003c/h2\u003e\n\n\u003cdiv class='intro'\u003e\n  {{intro}}\n\u003c/div\u003e\n\u003chr\u003e\n\n{{#if isExpanded}}\n  \u003cbutton {{action 'toggleProperty' 'isExpanded'}}\u003eHide Body\u003c/button\u003e\n  \u003cdiv class='body'\u003e\n    {{body}}\n  \u003c/div\u003e\n{{else}}\n  \u003cbutton {{action 'toggleProperty' 'isExpanded'}}\u003eShow Body\u003c/button\u003e\n{{/if}}\n\n\n\nYou might think you should put this property on the model, but \nwhether the  body is expanded or not is strictly a display concern.\n\nPutting this property on the controller cleanly separates logic\nrelated to your data model from logic related to what you display\non the screen. This makes it easy to unit-test your model without\nhaving to worry about logic related to your display creeping into\nyour test setup.\nA Note on Coupling\nIn Ember.js, templates get their properties from controllers, which\ndecorate a model.\n\nThis means that templates know about controllers and controllers\nknow about models, but the reverse is not true. A model knows\nnothing about which (if any) controllers are decorating it, and\ncontroller does not know which views are presenting its properties.\n\n\n\n\n\nThis also means that as far as a template is concerned, all of its\nproperties come from its controller, and it doesn't need to know\nabout the model directly.\n\nIn practice, Ember.js will create a template's controller once for\nthe entire application, but the controller's model may change\nthroughout the lifetime of the application without requiring that\nthe view knows anything about those mechanics.\n\nFor example, if the user navigates from /posts/1 to /posts/2,\nthe PostController will change its model from Post.find(1) to\nPost.find(2). The template will update its representations of any\nproperties on the model, as well as any computed properties on the\ncontroller that depend on the model.\n\nThis makes it easy to test a template in isolation by rendering it \nwith a controller object that contains the properties the template\nexpects. From the template's perspective, a controller is simply\nan object that provides its data.\nRepresenting Models\nTemplates are always connected to controllers, not models. This \nmakes it easy to separate display-specific properties from model \nspecific properties, and to swap out the controller's model as the\nuser navigates around the page.\n\nFor convenience, Ember.js provides controllers that proxy \nproperties from their models so that you can say {{name}} in your\ntemplate rather than {{model.name}}. An Ember.ArrayController \nproxies properties from an Array, and an Ember.ObjectController \nproxies properties from an object.\n\nIf your controller is an ArrayController, you can iterate directly\nover the controller using {{#each item in controller}}. This keeps the\ntemplate from having to know about how the controller is implemented\nand makes isolation testing and refactoring easier.\nStoring Application Properties\nNot all properties in your application need to be saved to the \nserver. Any time you need to store information only for the lifetime\nof this application run, you should store it on a controller.\n\nFor example, imagine your application has a search field that\nis always present. You could store a search property on your\nApplicationController, and bind the search field in the \napplication template to that property, like this:\n\n  1\n2\n3\n4\n5\n6\n\n  \u003c!-- application.handlebars --\u003e\n\u003cheader\u003e\n  {{input type=\"text\" value=search action=\"query\"}}\n\u003c/header\u003e\n\n{{outlet}}\n\n\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  App.ApplicationController = Ember.Controller.extend({\n  // the initial value of the `search` property\n  search: '',\n\n  actions: {\n    query: function() {\n      // the current value of the text field\n      var query = this.get('search');\n      this.transitionToRoute('search', { query: query });\n    }\n  }\n});\n\n\n\nThe application template stores its properties and sends its \nactions to the ApplicationController. In this case, when the user\nhits enter, the application will transition to the search route,\npassing the query as a parameter.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b3722fbc137928b16ffe6ac08527499b","fields":[{"name":"title","value":"Representing a Single Model with ObjectController","type":"string"},{"name":"url","value":"/controllers/representing-a-single-model-with-objectcontroller/","type":"enum"},{"name":"body","value":"Use Ember.ObjectController to represent a single model. To tell an \nObjectController which model to represent, set its model\nproperty in your route's setupController method.\n\nWhen a template asks an ObjectController for the value of a property, the controller \nlooks for a property with the same name on itself first before checking \nthe model.\n\nFor example, imagine you are writing a music player. You have defined\nyour SongController to represent the currently playing song.\n\n  1\n2\n3\n\n  App.SongController = Ember.ObjectController.extend({\n  soundVolume: 1\n});\n\n\n\nIn the Song route, you set the model of the controller to the\ncurrently playing song:\n\n  1\n2\n3\n4\n5\n\n  App.SongRoute = Ember.Route.extend({\n  setupController: function(controller, song) {\n    controller.set('model', song);\n  }\n});\n\n\n\nIn your template, you want to display the name of the currently playing\nsong, as well as the volume at which it is playing.\n\n  1\n2\n3\n4\n5\n6\n\n  \u003cp\u003e\n  \u003cstrong\u003eSong\u003c/strong\u003e: {{name}} by {{artist}}\n\u003c/p\u003e\n\u003cp\u003e\n  \u003cstrong\u003eCurrent Volume\u003c/strong\u003e: {{soundVolume}}\n\u003c/p\u003e\n\n\n\nBecause name and artist are persisted information, and thus stored\non the model, the controller looks them up there and provides them to\nthe template.\n\nsoundVolume, however, is specific to the current user's session, and\nthus stored on the controller. The controller can return its own value\nwithout consulting the model.\n\nThe advantage of this architecture is that it is easy to get started\nby accessing the properties of the model via the object controller. If,\nhowever, you need to transform a model property for a template, there is\na well-defined place to do so without adding view-specific concerns to\nthe model.\n\nFor example, imagine we want to display the duration of the song:\n\n  1\n2\n3\n4\n5\n6\n\n  \u003cp\u003e\n  \u003cstrong\u003eSong\u003c/strong\u003e: {{name}} by {{artist}}\n\u003c/p\u003e\n\u003cp\u003e\n  \u003cstrong\u003eDuration\u003c/strong\u003e: {{duration}}\n\u003c/p\u003e\n\n\n\nThis is saved on the server as an integer representing the number of\nseconds, so our first attempt looks like this:\n\n  1\n2\n3\n4\n5\n6\n\n  \u003cp\u003e\n  \u003cstrong\u003eSong\u003c/strong\u003e: 4 Minute Warning by Radiohead\n\u003c/p\u003e\n\u003cp\u003e\n  \u003cstrong\u003eDuration\u003c/strong\u003e: 257\n\u003c/p\u003e\n\n\n\nSince our users are humans and not robots, however, we'd like to display\nthe duration as a formatted string.\n\nThis is very easy to do by defining a computed property on the\ncontroller which transforms the model's value into a human-readable\nformat for the template:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.SongController = Ember.ObjectController.extend({\n  duration: function() {\n    var duration = this.get('model.duration'),\n         minutes = Math.floor(duration / 60),\n         seconds = duration % 60;\n\n    return [minutes, seconds].join(':');\n  }.property('model.duration')\n});\n\n\n\nNow, the output of our template is a lot friendlier:\n\n  1\n2\n3\n4\n5\n6\n\n  \u003cp\u003e\n  \u003cstrong\u003eSong\u003c/strong\u003e: 4 Minute Warning by Radiohead\n\u003c/p\u003e\n\u003cp\u003e\n  \u003cstrong\u003eDuration\u003c/strong\u003e: 4:17\n\u003c/p\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"eccf6ac44cf97c8ce01bedff4e10d4c1","fields":[{"name":"title","value":"Representing Multiple Models with ArrayController","type":"string"},{"name":"url","value":"/controllers/representing-multiple-models-with-arraycontroller/","type":"enum"},{"name":"body","value":"You can use Ember.ArrayController to represent an array of models. To tell an\nArrayController which models to represent, set its model property\nin your route's setupController method.\n\nYou can treat an ArrayController just like its underlying array. For\nexample, imagine we want to display the current playlist. In our route,\nwe setup our SongsController to represent the songs in the playlist:\n\n  1\n2\n3\n4\n5\n\n  App.SongsRoute = Ember.Route.extend({\n  setupController: function(controller, playlist) {\n    controller.set('model', playlist.get('songs'));\n  }\n});\n\n\n\nIn the songs template, we can use the {{#each}} helper to display\neach song:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003ch1\u003ePlaylist\u003c/h1\u003e\n\n\u003cul\u003e\n  {{#each song in model}}\n    \u003cli\u003e{{song.name}} by {{song.artist}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nYou can use the ArrayController to collect aggregate information about\nthe models it represents. For example, imagine we want to display the\nnumber of songs that are over 30 seconds long. We can add a new computed\nproperty called longSongCount to the controller:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.SongsController = Ember.ArrayController.extend({\n  longSongCount: function() {\n    var longSongs = this.filter(function(song) {\n      return song.get('duration') \u003e 30;\n    });\n    return longSongs.get('length');\n  }.property('@each.duration')\n});\n\n\n\nNow we can use this property in our template:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003cul\u003e\n  {{#each song in model}}\n    \u003cli\u003e{{song.name}} by {{song.artist}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n{{longSongCount}} songs over 30 seconds.\n\n\nSorting\nThe Ember.ArrayController uses the Ember.SortableMixin to allow sorting\nof content. There are two properties that can be set in order to set up sorting:\n\n  1\n2\n3\n4\n\n  App.SongsController = Ember.ArrayController.extend({\n  sortProperties: ['name', 'artist'],\n  sortAscending: true // false for descending\n});\n\n\nItem Controller\nIt is often useful to specify a controller to decorate individual items in\nthe ArrayController while iterating over them. This can be done by\ncreating an ObjectController:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.SongController = Ember.ObjectController.extend({\n  fullName: function() {\n\n    return this.get('name') + ' by ' + this.get('artist');\n\n  }.property('name', 'artist')\n});\n\n\n\nThen, the ArrayController itemController property must be set to\nthe decorating controller.\n\n  1\n2\n3\n\n  App.SongsController = Ember.ArrayController.extend({\n  itemController: 'song'\n});\n\n\n\n  1\n2\n3\n\n  {{#each item in controller}}\n  \u003cli\u003e{{item.fullName}}\u003c/li\u003e\n{{/each}}\n\n\n\nor you could setup the itemController directly in the template:\n\n  1\n2\n\n  App.SongsController = Ember.ArrayController.extend({\n});\n\n\n\n  1\n2\n3\n\n  {{#each item in controller itemController=\"song\"}}\n  \u003cli\u003e{{item.fullName}}\u003c/li\u003e\n{{/each}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c19f5903fdb5495c93460888ee8a3361","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/client_server_interaction/","type":"enum"},{"name":"body","value":"\nLoading Data From A Server\nServing Compiled Handlebars Templates Using Node.js\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"457ddece3c087ec5d43af5cce49b0775","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/client_server_interaction/loading_data_from_a_server/","type":"enum"},{"name":"body","value":"Problem\nYou want to load data from a server and have it available in your Ember application for observation and manipulation.\nSolution\nUse jQuery.ajax and convert the response into Ember observable objects. You use reopen to add a finder method to your model class. The general workflow of the finder method is the following:\n\n\nYou create an empty result object.\nYou make an asynchronous call to your API...\n... and in your success callback you fill your empty object.\nYou return your result object.\n\n\nNote the slight differences between returning an array and a single object.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n  App.User.reopenClass({\n  findAll : function(){\n    var result = [];\n    $.ajax({\n      url : '/users',\n      dataType : 'json',\n      success : function(response) {\n        response.forEach(function(user){\n           var model = App.User.create(user);\n           result.addObject(model);\n        });\n      }\n    });\n    return result;\n  },\n  findById : function(id){\n    var result = App.User.create();\n    $.ajax({\n      url : '/users/' + id,\n      dataType : 'json',\n      success : function(response) {\n        result.setProperties(response);\n      }\n    });\n    return result;\n  }\n});\n\n\nDiscussion\nAlternatively you could also return a promise (Ember.Deferred) with your finder methods. The code for this approach could look like the following:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n  App.User.reopenClass({\n  findAll : function(){\n    var promise = Ember.Deferred.create();\n\n    $.ajax({\n      url : '/users',\n      dataType : 'json',\n      success : function(response) {\n        var result = [];\n        response.forEach(function(user){\n           var model = App.User.create(user);\n           result.addObject(model);\n        });\n        promise.resolve(result);\n      }\n    });\n    return promise;\n  },\n  findById : function(id){\n    var promise = Ember.Deferred.create();\n\n    $.ajax({\n      url : '/users/' + id,\n      dataType : 'json',\n      success : function(response) {\n        var result = App.User.create();\n        result.setProperties(response);\n        promise.resolve(result);\n      }\n    });\n    return promise;\n  }\n});\n\n\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b8b634a7f193cb14f0f25011ebddc3ae","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/client_server_interaction/sending_data_to_a_server/","type":"enum"},{"name":"body","value":"Problem\nYou want to send data from your Ember application to a server.\nSolution\nUse jQuery.ajax and send json serialized Ember objects to the server.\nDiscussion","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b5f2cf671cd1e70a8164fc4cfe12e7f4","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/client_server_interaction/serving_compiled_templates_using_nodejs/","type":"enum"},{"name":"body","value":"Problem\nEmber.js uses Handlebars.js as its default templating language.  Handlebars files may be \ncreated directly in your HTML document as follows:\nhtml\n\u003cscript type=\"text/x-handlebars\" id=\"some-template\"\u003e\n  {{! your template goes here}}\n\u003c/script\u003e\n\nWhen your Ember application uses one of these templates, it will need to compile that handlebars\nsyntax into a javascript function.  This takes a little bit of time and is a needless task for your\nclient to be performing.  Furthermore, as your application grows, having tons of these templates in\nyour HTML document will become unwieldy and ugly.\n\nThankfully, this compilation step can be done ahead of time.  Ember.js expects that your templates\nwill be found in a hash object called Ember.TEMPLATES.  You can prebuild this hash on your server\nand send it down the wire with your application.\nSolutionDisclaimer\nThis recipe assumes you have never used node, npm, or grunt in your project.  If you have used \nthese before and already have a Gruntfile.js (or .coffee) in your project, some of the early \nsteps can probably be skipped or read through quickly.\nDependencies\n\nNode.js - a javascript run-time powered by V8\nNPM - a package manager for node modules with strong CLI tooling\nGrunt.js - a task-runner for node.js\ngrunt-contrib-watch - a Grunt.js task for watching parts of your file system for changes\ngrunt-ember-templates - a Grunt.js task for compiling handlebars templates into Ember.TEMPLATES\n\nProcess\nAll steps assume you are in your project's root.\nSetup\n\nInstall Node.js (which now ships with NPM).\nType npm init.  This will ask you for a few quick details and then will output a \npackage.json file.  This file contains a list of all your dependencies (and version number) and some\nother details relevant to your project.\nType npm install --save-dev grunt grunt-cli grunt-ember-templates grunt-contrib-watch.  This will install four packages from npm.  --save-dev tells npm to include these dependencies in\nyour package.json file under devDependencies\nCreate Gruntfile.js in your project root.  This file contains all the configuration\nfor your grunt tasks.\nOpen the Gruntfile and paste in the following code:\n\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n  'use strict'\n\nmodule.exports = function (grunt) {\n\n  grunt.initConfig({\n\n    //define some mustache-style variables to use throughout Gruntfile\n    templateDir: \"path/to/directory\",\n    outputDir: \"path/to/output\",\n    compiled: \"nameOfCompiledFile.js\",\n\n    //configure out template precompilation task\n    emberTemplates: {\n      precompile: {\n        options: {\n          templateBasePath: \"path/to/directory/\" ,\n          templateFileExtensions: /\\.(hbs|hjs|handlebars)/\n        },\n        src: \"\u003c%= templateDir %\u003e/**/*.{hbs,hjs,handlebars}\",\n        dest: \"\u003c%= outputDir %\u003e/\u003c%= compiled %\u003e\"\n      }    \n    },\n\n    //configure our file watching task\n    watch: {\n      handlebars: {\n        files: [\"\u003c%= templateDir %\u003e/**/*.{hbs,hjs,handlebars}\"],\n        tasks: [\"emberTemplates\"],\n        options: {\n          livereload: true \n        }\n      } \n    }\n  });\n\n  //load our tasks from NPM\n  grunt.loadNpmTasks(\"grunt-ember-templates\");\n  grunt.loadNpmTasks(\"grunt-contrib-watch\");\n\n  //register CLI task that will precompile our templates\n  grunt.registerTask(\"default\", [\"emberTemplates\"]);\n\n  //register CLI task that will watch our handlebars files and \n  //recompile them whenever they change (watch task blocks the process)\n  grunt.registerTask(\"precompile-watch\", [\"emberTemplates\", \"watch\"]);\n\n};\n\n\nCode Overview\nGruntfiles are easy to read once you know what you are looking at.\n\nThe top declares three \nmustache.js-style variables that may be used to store directory names, filenames, etc and can\nbe used throughout your Gruntfile.  This is huge, as it allows you to easily change project structure\nwithout hardcoding your paths throughout your config file.\n\nThe second two objects are configuration objects for the emberTemplates and watch tasks.\ndetails on the options and configuration of these tasks is found in their respective github\nrepositories.  Grunt tasks typically have easily read README.md files that explain the options \nand configurations for that package.\n\nThe third section is where we register our tasks.  Grunt provides a convenient function \nloadNpmTasks to load task definitions straight from the node_modules directory.\nWe also register two CLI tasks of our own, default and precompile-watch.\n\nTyping grunt at the terminal will run our default task which will compile our templates and\ncreate a file in our specified output folder.  Typing grunt precompile-watch perform\nthe same compilation, but will also start a file watching process which monitors our template\ndirectory for changes and re-runs the compilation task.\nConfiguration and Testing\n\nNow that you know what you are looking at, configure your Gruntfile by changing the paths \nat the top to match your project's layout.\nTest the precompilation with grunt and then test that your file watching task is working\nby typing grunt precompile-watch and then saving one of your template files.\nFin.\n\nDiscussion\nPrecompiling your templates is a must for Ember.js projects that grow beyond a trivial size.\nThe steps outlined here provide a convenient, configurable, and extensible way to perform this\nimportant task and allow you to focus on developing your application.  The repository that this\ntutorial is based on is found at http://www.github.com/stevekane/precompiled-template-recipe.\n\nAs a bonus, if you are interested in using Emblem.js which has a HAML-like syntax to \nbuild your templates, there is a grunt task for precompiling emblem.js templates called \ngrunt-emblem.  The steps needed to configure this task are similar to the ones shown\nbut be sure to refer to the projects github repository for details.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"5840c472a2618d3d0cd89bc93f69a264","fields":[{"name":"title","value":"Deciding If A Recipe is a Good Fit","type":"string"},{"name":"url","value":"/cookbook/contributing/deciding_if_a_recipe_is_a_good_fit/","type":"enum"},{"name":"body","value":"Problem\nYou have an idea for a recipe, but aren't sure it is a good fit for the Cookbook.\nSolution\nRead existing cookbook solutions and compare them to yours. You may also want to borrow or buy a cookbook-style\nbook for another technology to better understand the format.\n\nCookbook recipes are usually quick answers to focused questions. Your recipe should be narrowly tailored to\nsolve a single problem.\nDiscussion\nThe Cookbook format best serves beginners who have a basic knowledge of Ember.js and have ideally completed a\nsmall application of their own. Recipes in the Cookbook should teach intermediate and advanced topics, or present\nskills an Ember.js developer should know. Popular topics on StackOverflow are great examples of what a Cookbook\nrecipe should cover.\n\nA good recipe solves a single problem. Topics like \"Syncing data with one-way bindings\" or \"Integrating Ember with\nmoment.js\" make great recipes. Broader topics like \"Building an Ember application with Node.js\" or \"Creating a GridView\nwith sortable fields and search\" are not. If your topic is too big, consider breaking it into multiple recipes (e.g.\n\"Organizing an Ember application,\" \"Responding to user events,\" \"Connecting to remote data\").\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8f9eab53d10285d9b1f3b28238a34c45","fields":[{"name":"title","value":"Contributing","type":"string"},{"name":"url","value":"/cookbook/contributing/","type":"enum"},{"name":"body","value":"The Ember Cookbook provides answers and solutions to common Ember questions and problems. Anyone is welcome to\ncontribute.\n\nIf you are new to Ember, we recommend that you spend some time reading the guides and tutorials before coming\nto the Cookbook. Cookbook recipes assume that you have a basic understanding of Ember's concepts.\n\nIf you have experience with Ember and would like to contribute to the Cookbook, the discussion section of each\nrecipe is a great place to start.\nRecipes\n\nUnderstanding the Cookbook Format\nParticipating If You Know Ember\nParticipating If You Don't Know Ember\nDeciding If A Recipe is a Good Fit\nSuggesting A Recipe\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"38a21f770ff7d34b31b3d286fd42a7fa","fields":[{"name":"title","value":"Participating If You Don't Know Ember","type":"string"},{"name":"url","value":"/cookbook/contributing/participating_if_you_dont_know_ember/","type":"enum"},{"name":"body","value":"Problem\nYou are new to Ember, but want to help write the Cookbook.\nSolution\nSuggest and/or submit pull requests with a problem statement (see Suggesting A Recipe). You do not need to worry about providing a solution or discussion. Someone more experienced with Ember will be able to take your problem and provide a solution and discussion.\nDiscussion\nThe first version of the Ember Cookbook will be completed in a few phases. First, we will be accepting\nrecipe suggestions. You can suggest a recipe by forking this repository and submitting a pull request\n(see Suggesting a Recipe). Once we have written recipes, we'll be asking for help to proofread and test\nthem.\n\nSee \"Watch a project\" on Github for information on watching projects.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"772fabfc19fd4ef231bdea28f78e6978","fields":[{"name":"title","value":"Participating If You Know Ember","type":"string"},{"name":"url","value":"/cookbook/contributing/participating_if_you_know_ember/","type":"enum"},{"name":"body","value":"Problem\nYou are familiar with Ember and want to help write the Cookbook.\nSolution\nGet started by forking the repository. Send a pull request with an\nupdate to an existing recipe or a new recipe.\nDiscussion\nBased on your experience and knowledge of Ember, we recommend submitting pull requests with the following:\n\n\n  Beginner\n  Problem statements are a good place for anyone to start helping. Feel free to submit pull requests that are just problem statements if there is a recipe you'd like to see. If you're new to Ember and/or haven't ever written an Ember app, this is a perfect place to start contributing.\n  Intermediate\n  Problem \u0026 Solution statements are a great way to participate if you're already writing Ember applications and have a known good solution to a particular problem statement. Feel free to leave _Discussion_ missing for someone else to fill out later.\n  Advanced\n  Problem, Solution \u0026 Discussion is the right way to help if you have a deeper understanding of the topic and can write cogently about why the solution is a good idea, explain pitfalls of other solutions, etc.\n\n\nYou will be able to suggest possible recipes by forking this project and submitting a pull request with a new recipe (see Suggesting a Recipe).\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f5c7f82ba913be21095ff6ce282194f7","fields":[{"name":"title","value":"Suggesting A Recipe","type":"string"},{"name":"url","value":"/cookbook/contributing/suggesting_a_recipe/","type":"enum"},{"name":"body","value":"Problem\nYou'd like to submit a recipe to the Ember Cookbook.\nSolution\nFork the repository and create a feature branch named after your\nrecipe. New recipes should have four sections: a title, a problem statement, a solution statement, and\nan empty discussion section.\nDiscussion\nA feature branch is a branch in a local git\nrepository. Its name should be the camel-cased or underscored name of your recipe. For example, the branch\nname for this recipe – \"Suggesting a Recipe\" – would be SuggestingARecipe or suggesting_a_recipe.\n\nThe title, problem, and solution of your recipe should match the Cookbook's style (see\nUnderstanding the Cookbook Format). While your recipe should include a discussion section, you should leave\nit blank. These sections will be created in a later phase of the Cookbook project.\n\nThe filename of your suggested recipe should be the lowercase, underscored version of your recipe's name. The\nfilename name for this recipe \u0026nash; \"Suggesting a Recipe\" – would be suggesting_a_recipe.mdown.\n\nWhen you are ready to submit your recipe, push your local branch to the remote branch on your Github fork and\nsubmit a pull request. Before submitting a pull request, make sure someone hasn't already submitted a similar\nrecipe and that your recipe is a good fit for the Cookbook (see Deciding If A Recipe Is A Good Fit).\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f52fc00c428d9353d4c46c79a238b67e","fields":[{"name":"title","value":"Understanding the Cookbook Format","type":"string"},{"name":"url","value":"/cookbook/contributing/understanding_the_cookbook_format/","type":"enum"},{"name":"body","value":"Problem\nYou want to contribute, but aren't familiar with the Cookbook format or don't know\nhow your contribution should be formatted.\nSolution\nCookbook-style guides contain recipes that guide a beginning programmer to a deeper knowledge of the subject\nby answering specific, \"how-to\" style questions. Cookbook recipes address more topics than\nAPI documentation for a class, but are smaller in\nscope than a topic-based guide.\n\nAll recipes follow the same format:\n\n\n  Title\n  Broadly explains the topic of the recipe\n  Problem\n  Outlines the recipe's goals\n  Solution\n  Summarizes the correct approach to addressing the problem\n  Discussion\n  Explores the solution in detail\n\n\nA Cookbook does not need to be read in any particular order, and each recipe should contain all the information\nnecessary for a beginner to address the problem statement. Referring to other recipes that are considered\nprerequisite knowledge is encouraged.\nDiscussion\nTake a look at an O'Reilly Cookbook or the\nCoffeescript Cookbook. Both of these are great examples of the Cookbook\nformat.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9bdf82bd9ee1a00dee6b2a69b8d0403f","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/debugging_and_configuration/","type":"enum"},{"name":"body","value":"\nSetting Ember Global Flags\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2be0a7a48ca332c6828dc8b4f6128148","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/debugging_and_configuration/setting_ember_global_flags/","type":"enum"},{"name":"body","value":"Problem\nYou want to control features of Ember by setting specified global flags like Ember.LOG_BINDINGS.\nSolution\nCreate a windows.ENV with these properties set to the desired value before Ember is loaded.\nDiscussion","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"63dee2e4c1871d2ce7cbf9acfaf3837b","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/ember_data/displaying_only_committed_records/","type":"enum"},{"name":"body","value":"Problem\nYou want to display only the committed DS.Model records from the ArrayController content array.\nSolution\nIn order to not show the uncommitted records of your array, you should filter them on isNew property.\nDiscussion","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9412c160f231f1b6373809673480597b","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/ember_data/","type":"enum"},{"name":"body","value":"\nDisplaying Only Committed DS.Model Records\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"476cc3243a1edb4829173b542d568a94","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/ember_data/linking_to_slugs/","type":"enum"},{"name":"body","value":"Problem\nThe default behavior of Ember's link-to helper and Ember.Route's\nmodel hook make it easy to identify and load records by id. However,\nyou may want to use a human-readable keyword or slug to identify\na record in a url in place of an id.\nSolution\nEmber makes it easy to override the Route's default\nmodel\nhook. You can define a custom model function to look up records by a\nslug property instead of by the id.\n\nChanging the link-to to use a slug instead of an id is easy and\nonly requires creating a custom\nserialize\nfunction on the route.\nDiscussion\nIdentifying records by slugs is a two step problem. Given a Router\nmapping that looks like this:\n\n  1\n2\n3\n\n  App.Router.map(function() {\n  this.route('post', { path: '/post/:post_slug' });\n});\n\n\n\nFirst the Router needs to know how to look up the record by the slug\nusing the :post_slug param. Then link-to needs to generate an\nanchor tag with the record's slug property in place of the\n:post_slug.\nQuerying Records by Slug\nBy default, Ember Data does not provide a way to look up only 1 record\nby a property (other then the id property). Luckily, it is easy to\nextend Ember Data's store object to provide this functionality. The\ncode below adds a findOne method to the store.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.ApplicationStore = DS.Store.extend({\n  findOne: function() {\n    return this.find.apply(this, arguments).then(function(results) {\n      return results.objectAt(0);\n    });\n  }\n});\n\n\n\nUsing findOne we can easily fetch a record by its slug property in\nthe Route's model hook.\n\n  1\n2\n3\n4\n5\n\n  App.PostRoute = Ember.Route.extend({\n  model: function(params) {\n    return this.store.findOne('post', {slug: params.post_slug});\n  }\n});\n\n\nLinking To the Slug\nThe next step is to include a record's slug in the anchor tag\ngenerated by ember's link-to helper. The normal way to create a\nlink-to would look something like this:\n\n  1\n\n  {{#link-to 'post' model}}{{model.slug}}{{/link-to}}\n\n\n\nUnfortunately it will generate an anchor tag that includes the Post's\nid in the dynamic segment.\n\n  1\n\n  \u003ca href=\"/post/1\"\u003ehamster\u003c/a\u003e\n\n\n\nYou can work around this behavior by defining a custom serialize\nmethod on the route.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.PostRoute = Ember.Route.extend({\n  serialize: function(model) {\n    return {\n      post_slug: model.get('slug')\n    };\n  }\n});\n\n\n\nNow using we can use the same link-to code as above and the\nrecords's slug property will be correctly serialize the :post_slug\nparam in the anchor tag's href.\n\n  1\n\n  \u003ca href=\"/post/hamster\"\u003ehamster\u003c/a\u003e\n\n\nExample\n\nCookbook: Using slugs in links\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4884e4d6d82b771a64e79aa0c5e5330d","fields":[{"name":"title","value":"Binding Properties of an Object to Its Own Properties","type":"string"},{"name":"url","value":"/cookbook/event_handling_and_data_binding/binding_properties_of_an_object_to_its_own_properties/","type":"enum"},{"name":"body","value":"Problem\nYou want to base the value of one property on the value of another property.\nSolution\nUse one of the computed property macros like Ember.computed.alias or Ember.computed.gte\n\n  1\n2\n3\n4\n5\n6\n\n  App.Person = Ember.Object.extend({\n    firstName : null,\n    lastName : null,\n    surname : Ember.computed.alias(\"lastName\"),\n    eligibleForRetirement: Ember.computed.gte(\"age\", 65)\n});\n\n\nDiscussion\nEmber.js includes a number of macros that will help create properties whose values are based\non the values of other properties, correctly connecting them with bindings so they remain\nupdated when values change. These all are stored on the Ember.computed object\nand documented in the API documentation\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"330d340741cab3bb5f7a9565ae50551f","fields":[{"name":"title","value":"Event Handling \u0026 Data Binding","type":"string"},{"name":"url","value":"/cookbook/event_handling_and_data_binding/","type":"enum"},{"name":"body","value":"Here are some recipes for managing events and dealing with bindings.\n\n\nBinding Properties of an Object to Its Own Properties\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0b37f9b51f0e70c38a3a938841487720","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/event_handling_and_data_binding/responding_to_user_events/","type":"enum"},{"name":"body","value":"Problem\nYou want to respond to user-initialed browser events like clicks or key presses.\nSolution\nImplement event named based methods on your View classes\nDiscussion","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8f67a53d2b055dcb2ce3110447b35927","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/event_handling_and_data_binding/setting_the_attributes_of_a_views_element/","type":"enum"},{"name":"body","value":"Problem\nYou want to set the attributes of an HTML element that is created from an Ember.View\nSolution\nUse either the {{bindAttr}} Handlebars helper in your templates or set an attribute binding to a path in your application.\nDiscussion","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3141c79a132c8c594c8b03d2ccfe2b46","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/event_handling_and_data_binding/toggling_a_boolean_property/","type":"enum"},{"name":"body","value":"Problem\nYou want to toggle a boolean property.\nSolution\nUse the toggleProperty method of an Ember.Object.\n\n  1\n\n  obj.toggleProperty('isVisible');\n\n\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4d22c4d3e39a56ebdd341bd569c0ed4a","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/event_handling_and_data_binding/using_computed_properties/","type":"enum"},{"name":"body","value":"Problem\nYou want a property on an object whose value is determined programmatically\nSolution\nCreate a computer function either with Ember.computed or the property() function of Function objects\nDiscussion","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"950060fbebe4e96580cf049a3a23d580","fields":[{"name":"title","value":"Adding Google Analytics Tracking","type":"string"},{"name":"url","value":"/cookbook/helpers_and_components/adding_google_analytics_tracking/","type":"enum"},{"name":"body","value":"Problem\nYou want to add analytics to your Ember application.\nSolution\nSubscribe to the didTransition event inside your application router.\n\nIn the following examples we're using Google Analytics but it could be any other analytics product.\nAdd google analytic's base code to the html file that renders your ember app.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  \u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003ctitle\u003eMy Ember Site\u003c/title\u003e\n  \u003cscript type=\"text/javascript\"\u003e\n\n    var _gaq = _gaq || [];\n    _gaq.push(['_setAccount', 'UA-XXXXX-Y']);\n\n    (function() {\n      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;\n      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';\n      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);\n    })();\n\n  \u003c/script\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\n\u003c/body\u003e\n\u003c/html\u003e\n\n\n\nThen reopen the application router and add this function. It will be called when\ndidTransition is fired by the router.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.Router.reopen({\n  notifyGoogleAnalytics: function() {\n    return ga('send', 'pageview', {\n        'page': this.get('url'),\n        'title': this.get('url')\n      });\n  }.on('didTransition')\n});\n\n\nDiscussion\nThe didTransition event is responsible for notifying listeners of any URL\nchanges, in this example we are getting the path after the hash in the url so we\ncan notify Google Analytics about moving between areas of the site.\n\nJSBin Example\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"dc6dedae17bd529e34a0a28d46088f63","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/helpers_and_components/creating_a_handlebars_helper_to_truncate_text/","type":"enum"},{"name":"body","value":"Problem\nYou want to truncate string to a specified length inside your Handlebars templates.\nSolution\nWrite a custom Handlebars helper that can truncates text.\nDiscussion\nThe Handlebars helper is very simple. It takes two parameters: str (string) and len (length).\n\n  1\n2\n3\n4\n5\n6\n7\n\n  Ember.Handlebars.helper('truncate', function(str, len) {\n  if (str.length \u003e len) {\n    return str.substring(0, len - 3) + '...';\n  } else {\n    return str;\n  }\n});\n\n\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"19e03258c1115ce2ed917edfaaff2d8b","fields":[{"name":"title","value":"Creating Reusable Social Share Buttons","type":"string"},{"name":"url","value":"/cookbook/helpers_and_components/creating_reusable_social_share_buttons/","type":"enum"},{"name":"body","value":"Problem\nYou want to create a reusable Tweet button\nfor your application.\nSolution\nWrite a custom component that renders the Tweet button with specific attributes\npassed in.\n\n  1\n2\n3\n4\n5\n\n  {{share-twitter data-url=\"http://emberjs.com\" \n                data-text=\"EmberJS Components are Amazing!\" \n                data-size=\"large\" \n                data-hashtags=\"emberjs\"}}\n\n\n\n\n  1\n2\n3\n4\n5\n\n  App.ShareTwitterComponent = Ember.Component.extend({\n  tagName: 'a',\n  classNames: 'twitter-share-button',\n  attributeBindings: ['data-size', 'data-url', 'data-text', 'data-hashtags']\n});\n\n\n\nInclude Twitter's widget code in your HTML:\n\n  1\n\n  \u003cscript type=\"text/javascript\" src=\"http://platform.twitter.com/widgets.js\" id=\"twitter-wjs\"\u003e\u003c/script\u003e\n\n\nDiscussion\nTwitter's widget library expects to find an \u003ca\u003e tag on the page with specific data- attributes applied.\nIt takes the values of these attributes and, when the \u003ca\u003e tag is clicked, opens an iFrame for twitter sharing.\n\nThe share-twitter component takes four options that match the four attributes for the resulting \u003ca\u003e tag:\ndata-url, data-text, data-size, data-hashtags. These options and their values become properties on the\ncomponent object. \n\nThe component defines certain attributes of its HTML representation as bound to properties of the object through\nits attributeBindings property. When the values of these properties change, the component's HTML element's\nattributes will be updated to match the new values.\n\nAn appropriate tag and css class are applied through the tagName and classNames properties.\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"15f1bde6f3b703fd693ce18e0c1b8d81","fields":[{"name":"title","value":"Helpers \u0026 Components","type":"string"},{"name":"url","value":"/cookbook/helpers_and_components/","type":"enum"},{"name":"body","value":"Here are some recipes to help you encapsulate your code into Components and build Helpers.\n\n\nCreating Reusable Social Share Buttons\nA Spinning Button for Asynchronous Actions\nAdding Google Analytics Tracking\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b617fcfefa51d145d6a139c21ebdae70","fields":[{"name":"title","value":"A Spinning Button for Asynchronous Actions","type":"string"},{"name":"url","value":"/cookbook/helpers_and_components/spin_button_for_asynchronous_actions/","type":"enum"},{"name":"body","value":"Problem\nYou want a button component that spins to show asynchronous action till completion. Eg- Save Button.\nSolution\nWrite an Ember Component to change to loading state when action is taking place.\n\nFor example a button to save data could be as\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  \u003cscript type='text/x-handlebars' id='application'\u003e\n    {{spin-button id=\"forapplication\" isLoading = isLoading buttonText=buttonText action='saveData'}}\n\u003c/script\u003e\n\n\u003cscript type='text/x-handlebars' id='components/spin-button'\u003e\n    \u003cbutton {{bind-attr id=id}} {{action 'showLoading'}}\u003e\n        {{#if isLoading}}\n            \u003cimg src=\"http://i639.photobucket.com/albums/uu116/pksjce/spiffygif_18x18.gif\"\u003e\n        {{else}}\n            {{buttonText}}\n        {{/if}}\n    \u003c/button\u003e\n\u003c/script\u003e\n\n\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n  var App = Ember.Application.create({});\n\nApp.ApplicationController = Ember.Controller.extend({\n    isLoading:false,\n    buttonText:\"Submit\",\n    actions:{\n        saveData:function(){\n            var self = this;\n\n           //Do Asynchronous action here. Set \"isLoading = false\" after a timeout.\n            Ember.run.later(function(){\n                self.set('isLoading', false);\n            }, 1000);\n        }\n    }\n});\n\nApp.SpinButtonComponent = Ember.Component.extend({\n    classNames: ['button'],\n    buttonText:\"Save\",\n    isLoading:false,\n    actions:{\n        showLoading:function(){\n            if(!this.get('isLoading')){\n                this.set('isLoading', true);\n                this.sendAction('action');\n            }\n        }\n    }\n});\n\n\n\nDiscussion\nI have dumbed down the sample code to only change text within the button. One may add a loading image inside the button or change the button to a div styled like a button.\nThe component is in charge of setting isLoading = true and the base controller performing asynchronous action decides when the 'isLoading' becomes false again.\nFor safety and sanity of the component, one can add a settimeout of however much time and then set 'isLoading' back to false so that the components comes to initial state no matter the result of the asynchronous call. But I would prefer it was properly handled in the parent controller.\nAlso note that the component does not let multiple clicks get in the way of loading status.\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f82f010c217fd28e74fcbd4844adf8d8","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/helpers_and_components/writing_a_custom_handlebars_helper/","type":"enum"},{"name":"body","value":"Problem\nYou have portions of your views layer that use the same or similar HTML in many places.\nSolution\nWrite a custom Handlebars helper that can be called from any template and gets updated when the model changes.\nDiscussion\n  1\n2\n3\n\n  \u003cscript type=\"text/x-handlebars\"\u003e\n   $ {{dollar model}}\n\u003c/script\u003e\n\n\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  App = Ember.Application.create();\n\nApp.ApplicationRoute = Em.Route.extend({\n  model: function() {\n    return 980; // cents\n  }\n});\n\nEmber.Handlebars.registerBoundHelper('dollar', function(cents) {\n  var dollar = Math.floor(cents / 100);\n\n  return dollar;\n});\n\n\n\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"88c83cda7168eea4a444aaae82405ae5","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/cookbook/","type":"enum"},{"name":"body","value":"Welcome to the Ember.js Cookbook! The Cookbook provides answers and solutions\nto common Ember questions and problems. Anyone is welcome to contribute.\n\nHere are all of the available recipes:\nContributing\n\nUnderstanding the Cookbook Format\nParticipating If You Know Ember\nParticipating If You Don't Know Ember\nDeciding If A Recipe is a Good Fit\nSuggesting A Recipe\n\nUser Interface \u0026 Interaction\n\nAdding CSS Classes to Your Components\nAdding CSS Classes to Your Components Based on Properties\nFocusing a Textfield after It's Been Inserted\nDisplaying Formatted Dates With Moment.js\nSpecifying Data-Driven Areas of Templates That Do Not Need To Update\nUsing Modal Dialogs\nResetting scroll on route changes\n\nEvent Handling \u0026 Data Binding\n\nBinding Properties of an Object to Its Own Properties\n\nHelpers \u0026 Components\n\nCreating Reusable Social Share Buttons\nA Spinning Button for Asynchronous Actions\nAdding Google Analytics Tracking\n\nWorking with Objects\n\nIncrementing Or Decrementing A Property\nSetting Multiple Properties At Once\nContinuous Redrawing of Views\n\n\nIf you would like to see more recipes, take a look at the Suggesting A Recipe section.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"01219d66bd0a87abec37a5922e5dddaf","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/to_be_done/","type":"enum"},{"name":"body","value":"\nAdding Pagination to an ArrayController\nUpdating Views Real-Time with WebSockets\nCreating a Master/Detail Interface\nDisplaying Content with Partials\nInserting Data From Other Controllers with Render\nApplying a Simple Authentication Solution\nLoading Code/Templates Lazily\nSelecting Dates with DatePicker\nPerforming Form Validations\nUsing Twitter Bootstrap\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2df8728459776c61d05ca768128c004b","fields":[{"name":"title","value":"Adding CSS Classes to Your Components","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/adding_css_classes_to_your_components/","type":"enum"},{"name":"body","value":"Problem\nYou want to add CSS class names to your Ember Components.\nSolution\nSet additional class names with the classNames property of subclassed components:\n\n  1\n2\n3\n\n  App.AwesomeInputComponent = Ember.Component.extend({\n  classNames: ['css-framework-fancy-class']  \n})\n\n\n\n  1\n\n  {{awesome-input}}\n\n\n\n  1\n\n  \u003cdiv class=\"css-framework-fancy-class\"\u003e\u003c/div\u003e\n\n\nDiscussion\nIf desired, you can apply multiple class names.\n\n  1\n\n  classNames: ['bold', 'italic', 'blue']\n\n\nExample\nJS Bin\n\nSee Customizing a Component's Element for further examples.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"94aa466c359de8843e39693c877cdd64","fields":[{"name":"title","value":"Adding CSS Classes to Your Components Based on Properties","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/adding_css_classes_to_your_components_based_on_properties/","type":"enum"},{"name":"body","value":"Problem\nYou want to add or remove CSS class names to your Ember Components based on properties of the component.\nSolution\nAdd property names to the classNameBindings property of subclassed components.\nDiscussion\nYou can apply classes based on properties of the component, or even by properties bound to data passed into the component. This is done by binding the class attribute using classNameBindings.\n\n  1\n2\n\n  classNameBindings: ['active'],\nactive: true\n\n\n\nYou can also set the class name based on a computed property.\n\n  1\n2\n3\n4\n\n  classNameBindings: ['isActive'],\nisActive: function() {\n  return 'active';\n}.property('someAttribute')\n\n\n\nAnother way would be to bind the class name to a bound property.\n\n  1\n2\n\n  classNameBindings: ['isRelated:relative'],\nisRelatedBinding: \"content.isRelated\" // value resolves to boolean\n\n\nExample\nJS Bin\n\nSee Customizing a Component's Element for further examples.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e3ccacd41f2c23844a5036d74793e315","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/basic_form_validations/","type":"enum"},{"name":"body","value":"Problem\nYou want to validate your form text fields. The validation should only\napply when the user focused out of the input (so that a blank form won't\nbe all-red until user focuses each field).\nSolution\nCreate a new component and define a focusOut hook, which will record\nthat the field has been focused, and add a computed property named\nhasError, which will return validation result only if the field has\nbeen focused. The component expects to get the validation result as the\nvalid property.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  App.ValidatedInputComponent = Ember.Component.extend({\n  beenFocused: false,\n  valid: null,\n  hasError: function() {\n    if (this.get('beenFocused')) {\n      return !this.get('valid');\n    }\n  }.property('valid', 'beenFocused'),\n  focusOut: function() {\n    this.set('beenFocused', true);\n  }\n});\n\n\n\nAnd in the template of the component, put an {{input}} and wrap it\ninto a div, which would have the class of has-error bound to\nhasError. \n\n  1\n2\n3\n4\n5\n\n  \u003cscript type=\"text/x-handlebars\" data-template-name=\"components/validated-input\"\u003e\n  \u003cdiv {{bindAttr class=\"hasError :form-group\"}}\u003e\n    {{input type=type value=value size=size pattern=pattern name=name placeholder=placeholder disaled=disabled maxlength=maxlength tabindex=tabindex class=input-class}}\n  \u003c/div\u003e\n\u003c/script\u003e\n\n\n\nThe use like this:\n\n  1\n\n  {{validated-input value=name valid=nameValid placeholder=\"Name\" type=\"text\" input-class=\"form-control\"}}\n\n\nDiscussion\nEssentially, what we need to achieve is to have a component which wraps\nthe input field with a div that has the has-error class if the\nvalidation fails (after the field has been focused). The validation\nresult is passed to the component through the valid property.\n\nAs there is no way to take existing Ember.TextField component and wrap\nit with a layout (because \u003cinput\u003e is a self-closing element, so it has\nno content, and so there is nothing to wrap; and Ember can't wrap the\nelement itself this way), we are creating a new component,\nValidatedInputComponent.\n\nIt renders a wrapped input field. The wrapper has the has-error class\nif hasError property of the component is true. It's true only when\nthe validation fails and the field has been focused at.\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0527841fe584b7e1dd13d46b84cd8053","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/converting_strings_to_currency_with_accounting_js/","type":"enum"},{"name":"body","value":"Problem\nYou're displaying formatted values in user inputs as currency with\nAccounting.js and need to remove the decoration to set the\nattributes upstream.\nSolution\nMake use of the computed property's setter to remove the\ndisplay formatting and set the property to the proper value.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  formattedAmount: function(key, value) {\n  if (arguments.length \u003e 1) {\n    // setter\n    var cleanAmount = accounting.unformat(value);\n    this.set('amount', cleanAmount);\n  }\n\n  return accounting.formatMoney(this.get('amount'));\n}.property('amount')\n\n\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"356077cd8cbe65ee0bc9345c0360cb99","fields":[{"name":"title","value":"Displaying Formatted Dates With Moment.js","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/displaying_formatted_dates_with_moment_js/","type":"enum"},{"name":"body","value":"Problem\nDisplay JavaScript Date objects in human readable format.\nSolution\nThere are two ways of formatting the value:\n\n\nCreate a Handlebars helper {{format-date}} and use it in your template\nCreate a computed property formattedDate that will return a transformed date\n\n\nWe will use Moment.js for formatting dates.\n\nLet's look at a simple example. You're working on a website for your\nclient, and one of the requirements is to have the current date on the index page in human readable format. This is a perfect place to use a\nHandlebars helper that \"pretty prints\" the current date:\n\n  1\n2\n3\n\n  Ember.Handlebars.registerBoundHelper('currentDate', function() {\n  return moment().format('LL');\n});\n\n\n\nYour template will look like:\n\n  1\n\n  Today's date: {{currentDate}}  // Today's date: August 30 2013\n\n\n\nYou can even enhance your code and pass in the date format to the helper:\n\n  1\n2\n3\n\n  Ember.Handlebars.registerBoundHelper('currentDate', function(format) {\n  return moment().format(format);\n});\n\n\n\nNow you would need to pass an additional parameter to the helper:\n\n  1\n\n  Today's date: {{currentDate 'LL'}}  // Today's date: August 30 2013\n\n\n\nLet's look at another example. Say you need\nto create a simple control that allows you to type in a date and\na date format. The date will be formatted accordingly.\n\nDefine formattedDate computed property that depends on\ndate and format. Computed property in this example does\nthe same thing as Handlebars helpers defined above.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.ApplicationController = Ember.Controller.extend({\n  format: \"YYYYMMDD\",\n  date: null,\n  formattedDate: function() {\n    var date = this.get('date'),\n        format = this.get('format');\n    return moment(date).format(format);\n  }.property('date', 'format')\n});\n\n\n\n  1\n2\n3\n\n  {{input value=date}}\n{{input value=format}}\n\u003cdiv\u003e{{formattedDate}}\u003c/div\u003e\n\n\nDiscussion\nBoth helper and computed property can format your date value. \nWhich one do I use and when?\n\nHandlebars helpers are shorthand for cases where you want to format\na value specifically for presentation. That value may be used \nacross different models and controllers.\n\nYou can use {{currentDate}} across your application to format dates\nwithout making any changes to controllers.\n\nComputed property in the example above does the same thing as the\nHandlebars helper with one big difference:\nformattedDate can be consumed later without applying\ndate format on the date property again.\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"83c1f0cd7e851a3458314ba223f87911","fields":[{"name":"title","value":"Focusing a Textfield after It's Been Inserted","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/focusing_a_textfield_after_its_been_inserted/","type":"enum"},{"name":"body","value":"Problem\nYou have an Ember.TextField instance that you would like become focused after it's been inserted.\nSolution\nSubclass Ember.TextField and define a method marked with\n.on('didInsertElement'). Inside this method apply focus\nto the text field by accessing the components's jQuery $ property:\n\n  1\n2\n3\n4\n5\n\n  App.FocusInputComponent = Ember.TextField.extend({\n  becomeFocused: function() {\n    this.$().focus();\n  }.on('didInsertElement')\n});\n\n\n\nFor the component's template:\n\n  1\n\n  Focus Input component!\n\n\n\n  1\n\n  {{focus-input}}\n\n\nDiscussion\nCustom components provide a way to extend native HTML elements with new behavior\nlike autofocusing.\n\nOur App.FocusInputComponent is an extension of the Ember.TextField component\nwith a becomeFocused method added. After it is added to the DOM, every\ncomponent in Ember.js has access to an underlying jQuery object. This object wraps\nthe component's element and provides a unified, cross-browser interface for DOM\nmanipulations like triggering focus.\n\nBecause we can only work with these DOM features once an Ember.js component has\nbeen added to the DOM we need to wait for this event to occur. Component's have a\ndidInsertElement event that is triggered when the component has been added to the\nDOM.\n\nBy default Ember.js extends the native Function.prototype object to include a\nnumber of additional functions, the on function among them.  on gives us a declarative\nsyntax for signify that a method should be called when a specific event has fired. In this case,\nwe want to call our new becomeFocused method when the didInsertElement is fired for an instance \nof our component.\n\nPrototype extension can be disabled by setting the Ember.EXTEND_PROTOTYPES property to false.\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"7885361de2e0b9cf0ea815192a0f9e6e","fields":[{"name":"title","value":"User Interface and Interaction","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/","type":"enum"},{"name":"body","value":"Here are some recipes that will help you provide a better user experience.\n\n\nAdding CSS Classes to Your Components\nAdding CSS Classes to Your Components Based on Properties\nFocusing a Textfield after It's Been Inserted\nDisplaying Formatted Dates With Moment.js\nSpecifying Data-Driven Areas of Templates That Do Not Need To Update\nUsing Modal Dialogs\nResetting scroll on route changes\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"63d8e08cdc54ce42a343231a617f595c","fields":[{"name":"title","value":"Resetting scroll on route changes","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/resetting_scroll_on_route_changes/","type":"enum"},{"name":"body","value":"Problem\nThe page scroller keeps in the same position when you go from one page to another. For instance, if you scroll down a long list of displayed elements on a page and then you navigate to another page with another long list of elements, you should be able to notice that scroll position is not being reset.\nSolution\nAdd the following mixin to the affected Routes:\n\n  1\n2\n3\n4\n5\n6\n\n  App.ResetScroll = Ember.Mixin.create({\n  activate: function() {\n    this._super();\n    window.scrollTo(0,0);\n  }\n});\n\n\n\nOnly if you need do something on the activate method you must call this._super() at the beginning:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.IndexRoute = Ember.Route.extend(App.ResetScroll, {\n  //I need to do other things with activate\n  activate: function() {\n    this._super.apply(this, arguments); // Call super at the beginning\n    // Your stuff\n  }\n});\n\n\nExample\nEmber Starter Kit\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ce0ad930ab039b25194ad5056f380516","fields":[{"name":"title","value":"Specifying Data-Driven Areas of Templates That Do Not Need To Update","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/specifying_data_driven_areas_of_templates_that_do_not_need_to_update/","type":"enum"},{"name":"body","value":"Problem\nYou have a section of a template that is based on a data but you don't need the template to update\nSolution\nUse the {{unbound}} Handlebars helper.\n\n  1\n2\n\n  {{unbound firstName}}\n{{lastName}}\n\n\nDiscussion\nBy default all uses of Handlebars helpers in Ember.js will use data bound values that will automatically update\nthe section of the template where a property changes after initial rendering.  Ember.Handlebars does this by\napplying the {{bind}} helper automatically for you.\n\nFor example, the two following uses of Handlebars are identical in an Ember.js application:\n\n  1\n2\n\n  {{lastName}}\n{{bind lastName}}\n\n\n\nIf you know that a property accessed in Handlebars will not change for the duration of the application's\nlife, you can specifiy that the property is not bound by applying the {{unbound}} helper. A property\nthat is not bound will avoid adding unnecessary observers on a property.\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"118458a47bfa45283f898609ab029fd1","fields":[{"name":"title","value":"Using Modal Dialogs","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/using_modal_dialogs/","type":"enum"},{"name":"body","value":"Problem\nYou want to show part of your UI in a modal dialog.\nSolution\nRender a specific controller into a named modal outlet in your application\ntemplate.\nDiscussion\nYou can use a route's render method to render a specific controller and\ntemplate into a named outlet. In this case we can setup our application template\nto handle the main outlet and a modal outlet:\n\n  1\n2\n\n  {{outlet}}\n{{outlet 'modal'}}\n\n\n\nThen you can render a controller and template into the modal outlet.  Sending\nan action in a template will propagate to the application route's actions.\n\nIn a template:\n\n  1\n\n  \u003cbutton {{action 'openModal' 'myModal'}}\u003eOpen modal\u003c/button\u003e\n\n\n\nIn your application route:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  App.ApplicationRoute = Ember.Route.extend({\n  actions: {\n    openModal: function(modalName) {\n      return this.render(modalName, {\n        into: 'application',\n        outlet: 'modal'\n      });\n    }\n  }\n});\n\n\n\nWhen closing a modal, you can use the route's disconnectOutlet method to remove\nthe modal from the DOM.\n\n  1\n2\n3\n4\n5\n6\n\n    closeModal: function() {\n    return this.disconnectOutlet({\n      outlet: 'modal',\n      parentView: 'application'\n    });\n  }\n\n\n\nIt may also be helpful to use a modal-dialog component to handle common markup\nand interactions such as rendering an overlay and handling clicks outside of the\nmodal.\nExample\nThis example shows:\n\n\nRendering a pop-up modal in a named outlet.\nSending a specific model to the modal controller.\nWrapping the common modal markup and actions in a component.\nHandling events to close the modal when the overlay is clicked.\n\n\n\n  Recipe: Using a Modal Dialog\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a3aef6a7a8621d2a8f6a06aeba45ea05","fields":[{"name":"title","value":"Continuous Redrawing of Views","type":"string"},{"name":"url","value":"/cookbook/working_with_objects/continuous_redrawing_of_views/","type":"enum"},{"name":"body","value":"Problem\nYou'd like to redraw your views every few seconds/minutes e.g. to update\nrelative timestamps (like on twitter.com).\nSolution\nHave a clock object with a pulse attribute in your application which \nincrements using a timed interval. You want to let view(s) bind values to be\nrefreshed when the pulse attribute increments.\n\nThe clock object can be used to create new instances for binding to new views\ngenerated within the application, like a list of comments.\nDiscussion\n\nCookbook: Continuous Redrawing of Views\n\nClockService object\nThis ClockService is an example of an object that may come from a library.\nAnd, is injected into the application via an initializer.\n\nDuring initialization the tick method is called which uses Ember.run.later\nwith a time of 250 milliseconds as the interval. A property is set at the end\nof the interval. Since the tick method observes the incremented property\nanother interval is triggered each time the property increases.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  var ClockService = Ember.Object.extend({\n  pulse: Ember.computed.oneWay('_seconds').readOnly(),\n  tick: function () {\n    var clock = this;\n    Ember.run.later(function () {\n      var seconds = clock.get('_seconds');\n      if (typeof seconds === 'number') {\n        clock.set('_seconds', seconds + (1/4));\n      }\n    }, 250);\n  }.observes('_seconds').on('init'),\n  _seconds: 0,\n});\n\n\nBinding to the pulse attribute\nIn this recipe, an application initializer is used to inject an instance of the\nClockService object, setting a controller's clock property to this instance.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  Ember.Application.initializer({\n  name: 'clockServiceInitializer',\n  initialize: function(container, application) {\n    container.register('clock:service', ClockService);\n    application.inject('controller:interval', 'clock', 'clock:service');\n  }\n});\n\n\n\nThe controller can set any computed properties based on the pulse property of\nthe injected clock instance.\n\nIn this case the seconds property is bound to the pulse property of the\ncontroller's clock. The property clock.pulse was injected during\ninitialization.\n\nThe controller has (session) data to display seconds to visitors, as well as\na handful of properties used as conditions in the Handlebars template.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  App.IntervalController = Ember.ObjectController.extend({\n  secondsBinding: 'clock.pulse',\n  fullSecond: function () {\n    return (this.get('seconds') % 1 === 0);\n  }.property('seconds'),\n  quarterSecond: function () {\n    return (this.get('seconds') % 1 === 1/4);\n  }.property('seconds'),\n  halfSecond: function () {\n    return (this.get('seconds') % 1 === 1/2);\n  }.property('seconds'),\n  threeQuarterSecond: function () {\n    return (this.get('seconds') % 1 === 3/4);\n  }.property('seconds')\n});\n\n\n\nA controller for a list of comments, each comment will have a new clock\ninstance when added to the list. The comment item controller sets up\nthe seconds binding, used by the template to show the time since the\ncomment was created.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  App.CommentItemController = Ember.ObjectController.extend({\n  seconds: Ember.computed.oneWay('clock.pulse').readOnly()\n});\n\nApp.CommentsController = Ember.ArrayController.extend({\n  itemController: 'commentItem',\n  comment: null,\n  actions: {\n    add: function () {\n      this.addObject(Em.Object.create({\n        comment: this.get('comment'),\n        clock: ClockService.create()\n      }));\n      this.set('comment', null);\n    }\n  }\n});\n\n\nHandlebars template which displays the pulse\nThe seconds value is computed from the pulse attribute. And the controller\nhas a few properties to select a component to render, fullSecond,\nquarterSecond, halfSecond, threeQuarterSecond.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  {{#if fullSecond}}\n  {{nyan-start}}\n{{/if}}\n{{#if quarterSecond}}\n  {{nyan-middle}}\n{{/if}}\n{{#if halfSecond}}\n  {{nyan-end}}\n{{/if}}\n{{#if threeQuarterSecond}}\n  {{nyan-middle}}\n{{/if}}\n\u003ch3\u003eYou\u0026apos;ve nyaned for {{digital-clock seconds}} (h:m:s)\u003c/h3\u003e\n{{render 'comments'}}\n\n\n\nA template for a list of comments\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  \u003cform {{action \"add\" on=\"submit\"}}\u003e\n  {{input value=comment}}\n  \u003cbutton\u003eAdd Comment\u003c/button\u003e\n\u003c/form\u003e\n\u003cul\u003e\n{{#each item in this}}\n  \u003cli\u003e{{item.comment}} ({{digital-clock item.seconds}})\u003c/li\u003e\n{{/each}}\n\u003c/ul\u003e\n\n\nHandlebars helper to format the clock display (h:m:s)\nThis helper is used in the template like so {{digital-clock seconds}},\nseconds is the property of the controller that will be displayed (h:m:s).\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  Ember.Handlebars.registerBoundHelper('digital-clock', function(seconds) {\n  var h = Math.floor(seconds / 3600);\n  var m = Math.floor((seconds % 3600) / 60);\n  var s = Math.floor(seconds % 60);\n  var addZero = function (number) {\n    return (number \u003c 10) ? '0' + number : '' + number;\n  };\n  var formatHMS = function(h, m, s) {\n    if (h \u003e 0) {\n      return '%@:%@:%@'.fmt(h, addZero(m), addZero(s));\n    }\n    return '%@:%@'.fmt(m, addZero(s));\n  };\n  return new Ember.Handlebars.SafeString(formatHMS(h, m, s));\n});\n\n\nNote\nTo explore the concept further, try adding a timestamp and updating the clock's\npulse by comparing the current time. This would be needed to update the pulse\nproperty when a user puts his/her computer to sleep then reopens their browser\nafter waking.\nLinks\nThe source code:\n\n\nhttp://jsbin.com/somosocuni/1/edit?html,js,output\n\n\nFurther reading:\n\n\nEmber Object\nEmber Application Initializers\nMethod Inject\nConditionals\nWriting Helpers\nDefining a Component\nEmber Array Controller\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"5e86bfe426ef038807619502fbf46e06","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/working_with_objects/displaying_content_arrays_in_reverse_order/","type":"enum"},{"name":"body","value":"Problem\nYou want to display an Ember content array from an ArrayController in descending order instead of ascending order (the default).\nSolution\n\nConvert the built-in content array to a normal JavaScript array, then reverse it.\nYou use Ember's @each property to mirror the reverse change to the content array.\nUser the built-in sortProperties and sortAscending properties to reverse the order.\n\nDiscussion\nOne way to achieve that is to extend Ember.ArrayController with a new function called reverse.\nYou will also have to create a computed property:\njavascript\nreversedArray: function() {\n    return this.toArray().reverse();\n  }.property('myArray.@each')\n\n\nOnce you do that, you will be able to use reversedArray property in your Handlebars template: {{#each reversedArray}}{{/each}}.\n\nAnother way to do it is to leverage out of the box EmberJs functionality and to use sortProperties and sortAscending properties.\nJust specify them on your controller, like so:\njavascript\nApp.MyController = Ember.ArrayController.extend({\n  sortProperties: ['id'],\n  sortAscending: false\n});\n\n\nAnd in your template you will be able to consume a reversed array, like this: {{#each arrangedContent}}{{/each}}.\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3e872f31e6a0cf6abf16d1d1f252b8c4","fields":[{"name":"title","value":"Incrementing Or Decrementing A Property","type":"string"},{"name":"url","value":"/cookbook/working_with_objects/incrementing_or_decrementing_a_property/","type":"enum"},{"name":"body","value":"Problem\nYou want to increment or decrement a property.\nSolution\nUse the incrementProperty or decrementProperty methods of Ember.Object.\n\nTo increment:\n\n  1\n\n  person.incrementProperty('age');\n\n\n\nTo decrement:\n\n  1\n\n  person.decrementProperty('age');\n\n\nDiscussion\nYou can optionally specify a value to increment or decrement by:\n\n  1\n\n  person.incrementProperty('age', 10);\n\n\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2c16149f0450be35676c93c8ba49fc26","fields":[{"name":"title","value":"Working with Objects","type":"string"},{"name":"url","value":"/cookbook/working_with_objects/","type":"enum"},{"name":"body","value":"Here are some recipes to help you understand working with Ember Objects.\n\n\nIncrementing Or Decrementing A Property\nSetting Multiple Properties At Once\nContinuous Redrawing of Views\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e756d6d17948a8375dd19f568846e443","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/cookbook/working_with_objects/naming_your_child_views/","type":"enum"},{"name":"body","value":"Problem\nYou want to access a particular child view by name from its parent view.\nSolution\nSupply a viewName option to the {{view}} helper inside your template.\nDiscussion","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"5ab3bf9f56f37a23fabcd1360384b291","fields":[{"name":"title","value":"Setting Multiple Properties At Once","type":"string"},{"name":"url","value":"/cookbook/working_with_objects/setting_multiple_properties_at_once/","type":"enum"},{"name":"body","value":"Problem\nYou want to set multiple properties on an object with a single method call.\nSolution\nUse the setProperties method of Ember.Object.\n\n  1\n2\n3\n4\n\n  person.setProperties({\n  name: 'Gavin',\n  age: 36\n})\n\n\nExample\nJS Bin\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"765720ce4c1d943fa98212ffc0f688de","fields":[{"name":"title","value":"Deprecations","type":"string"},{"name":"url","value":"/deprecations/","type":"enum"},{"name":"body","value":"Periodically, various APIs in Ember.js may be deprecated. During a minor\nrelease, for instance when upgrading from version 1.9 to 1.10, you may see new\ndeprecations fire in your codebase. Until a major revision such as 2.0 lands,\ncode firing such deprecations is still supported by the Ember community. After\nthe next major revision lands, the supporting code may be removed. This style\nof change management is commonly referred to as Semantic Versioning.\n\nWhat follows is a list of deprecations introduced to Ember.js during the 1.x\ncycle.\nDeprecations Added in 1.7Deprecate observing container views like arrays.\nContainerViews have been observable as arrays, where the items in\nthe array are childViews. This introduces complexity into container\nviews despite the feature being a rarely used one.\nDeprecate Ember.DeferredMixin and Ember.Deferred.\nEmber.DeferredMixin and Ember.Deferred have been deprecated in favor\nof using RSVP.Promises.\nDeprecate .then on Ember.Application.\nAs part of the Ember.DeferredMixin deprecation, using .then on an\nEmber.Application instance itself has been deprecated.\n\nYou can use the ready hook or initializers to defer/advance readiness\ninstead.\nDeprecations Added in 1.8Global lookup of views\nPrevious to Ember 1.8, views would commonly be fetched from the global\nscope:\n\n  1\n2\n\n  {{view App.SomeView}}\n{{each item in items itemViewClass=App.SomeView}}\n\n\n\nSince Ember 1.8, views are more appropriately resolved on the application\nvia strings:\n\n  1\n2\n\n  {{view \"some\"}}\n{{each item in items itemViewClass=\"some\"}}\n\n\n\nThey may also be fetched via a binding:\n\n  1\n2\n\n  {{view view.someViewViaTheCurrentView}}\n{{each itemViewClass=someViewViaAControllerProperty}}\n\n\n\nIn general, it is recommended that your Ember application avoid accessing\nglobals from a template.\nNew usage of Ember.Select\nMost of Ember's provided views are already accessed via helpers. For example,\nthe Ember.TextField view is used via the\ninput helper.\n\nThe Ember.Select view has not been upgraded to\nhave a helper. Instead, it was suggested that you call it via the global\nclass name:\n\n  1\n\n  {{view Ember.Select content=manyItems}}\n\n\n\nSince this lookup is now deprecated, the select view has been registered\non an application as select. The new usage is:\n\n  1\n\n  {{view \"select\" content=manyItems}}\n\n\n\nSee the updated Ember.Select documentation\nand the built-in views guide for more details\nand examples.\nEmber.js libraries and plugins\nIf the code triggering this deprecation is being fired from a library, that\nlibrary may need to update its suggested usage.\n\nOne solution for such a library is to provide mixins instead of classes:\n\n  1\n2\n\n  // usage is {{view \"list\"}}\nvar App.ListView = Ember.View.extend(ListView);\n\n\n\nA more advanced solution is to use an initializer to register the plugin's\nviews on the the application:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  // usage is {{view \"list\"}}\nEmber.Application.initializer({\n  name: 'list-view',\n  initialize: function(container, application) {\n    container.register('view:list', ListView);\n  }\n});\n\n\n\nMore details on how to register an Ember.js framework component are available\nin the initializer API documentation\nand the dependency injection guide.\nDeprecate location: 'hash' paths that don't include a forward slash. e.g. #/foo NOT #foo\nPrior to this release, if you were using location: 'hash' (which is the default), you were able to link to a route with a location.hash that didn't contain the expected leading forward slash. e.g. #foo instead of the correct #/foo. Very few, if any, should be impacted by this since the router always produces the correct form.\n\nDoing so is ambiguous because you may also be trying to link to an element on the page who's id matches \u003cdiv id=\"foo\"\u003e and it also erroneously will create an extra history state if a user clicks on something that transitions to that route again, since it will change location.hash === '#/foo'.\n\nThis ability will be removed quickly to allow us to mimick the browser's behavior of scrolling the page to an element who's id matches, but in our case doing so after the transition ends and everything is rendered. Once this feature is added, you'll be able to link to id's even with doubled up hashes: #/foo#some-id as well as the expected #some-id.\nDeprecations Added in 1.9More Consistent Handlebars Scope\nIn today's Ember, the each and with helpers come in two flavors: a \"context-switching\" flavor and a \"named-parameter\" flavor.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  {{#each post in posts}}\n  {{!-- the context in here is the same as the outside context,\n        and `post` references the current iteration --}}\n{{/each}}\n\n{{#each posts}}\n  {{!-- the context in here has shifted to the individual post.\n        the outer context is no longer accessible --}}\n{{/each}}\n\n{{#with post as otherPost}}\n  {{!-- the context in here is the same as the outside context }}\n{{/with}}\n\n{{#with post}}\n  {{!-- the context in here has shifted to the post.\n        the outer context is no longer accessible --}}\n{{/with}}\n\n\n\nThis has proven to be one of the more confusing parts of the Ember templating system. It is also not clear to\nbeginners which to use, and when they choose the context-shifting form, they lose access to values in the outer\ncontext that may be important.\n\nBecause the helper itself offers no clue about the context-shifting behavior, it is easy (even for more experienced\nEmber developers) to get confused when skimming a template about which object a value refers to.\n\nThe context-shifting forms of #each and #with have been deprecated in favor of the named-parameter forms.\nTransition Plan\nTo transition your code to the new syntax, you can change templates that look like this:\n\n  1\n2\n3\n4\n\n  {{#each people}}\n  \u003cp\u003e{{firstName}} {{lastName}}\u003c/p\u003e\n  \u003cp\u003e{{address}}\u003c/p\u003e\n{{/each}}\n\n\n\nwith:\n\n  1\n2\n3\n4\n\n  {{#each person in people}}\n  \u003cp\u003e{{person.firstName}} {{person.lastName}}\u003c/p\u003e\n  \u003cp\u003e{{person.address}}\u003c/p\u003e\n{{/each}}\n\n\n\nIn preparation for further work on HTMLBars, the context switching form of {{each}} is deprecated. This is mostly a \"mechanical\" refactor and dramatically\nsimplifies how to think about the context in your templates. This change should be entirely mechanical.\n\nIn prior versions you may have done one of the following:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each}}\n    \u003cli\u003e{{name}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each people}}\n    \u003cli\u003e{{name}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nYou should now be using:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each person in people}}\n    \u003cli\u003e{{person.name}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\nDeprecations Added in 1.10Deprecate beforeObservers\nbeforeObservers are deprecated due to the negative performance implications they have for Ember internals and applications.\n\nTypically they were used to have access to the old value of a property when it's about to change, but you can get same functionality in an even more efficient way with just a few lines of code:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  function fooObserver(obj){\n  var newFoo = obj.get('foo');\n  if (obj._oldFoo !== newFoo) {\n    // do your stuff here\n    obj._oldFoo = newFoo;\n  }\n}\naddObserver(obj, 'foo', fooObserver);\nfooObserver(obj); // Optionally call the observer immediately\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ae8e92d454a11640f89eb9be33e7795a","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/enumerables/","type":"enum"},{"name":"body","value":"Enumerables\nIn Ember.js, an Enumerable is any object that contains a number of child\nobjects, and which allows you to work with those children using the\nEmber.Enumerable API. The most common\nEnumerable in the majority of apps is the native JavaScript array, which\nEmber.js extends to conform to the Enumerable interface.\n\nBy providing a standardized interface for dealing with enumerables,\nEmber.js allows you to completely change the way your underlying data is\nstored without having to modify the other parts of your application that\naccess it.\n\nFor example, you might display a list of items from fixture data during\ndevelopment. If you switch the underlying data from synchronous fixtures\nto an array that fetches data from the server lazily, your view,\ntemplate and controller code do not change at all.\n\nThe Enumerable API follows ECMAScript specifications as much as\npossible. This minimizes incompatibility with other libraries, and\nallows Ember.js to use the native browser implementations in arrays\nwhere available.\n\nFor instance, all Enumerables support the standard forEach method:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  [1,2,3].forEach(function(item) {\n  console.log(item);\n});\n\n//=\u003e 1\n//=\u003e 2\n//=\u003e 3\n\n\n\nIn general, Enumerable methods, like forEach, take an optional second\nparameter, which will become the value of this in the callback\nfunction:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var array = [1,2,3];\n\narray.forEach(function(item) {\n  console.log(item, this.indexOf(item));\n}, array)\n\n//=\u003e 1 0\n//=\u003e 2 1\n//=\u003e 3 2\n\n\nEnumerables in Ember.js\nUsually, objects that represent lists implement the Enumerable interface. Some examples:\n\n\nArray - Ember extends the native JavaScript Array with the\nEnumerable interface (unless you disable prototype\nextensions.)\nEmber.ArrayController - A controller that wraps an underlying array and\nadds additional functionality for the view layer.\nEmber.Set - A data structure that can efficiently answer whether it\nincludes an object.\n\nAPI Overview\nIn this guide, we'll explore some of the most common Enumerable\nconveniences. For the full list, please see the Ember.Enumerable API\nreference documentation.\nIterating Over an Enumerable\nTo enumerate all the values of an enumerable object, use the forEach method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var food = [\"Poi\", \"Ono\", \"Adobo Chicken\"];\n\nfood.forEach(function(item, index) {\n  console.log('Menu Item %@: %@'.fmt(index+1, item));\n});\n\n// Menu Item 1: Poi\n// Menu Item 2: Ono\n// Menu Item 3: Adobo Chicken\n\n\nMaking an Array Copy\nYou can make a native array copy of any object that implements\nEmber.Enumerable by calling the toArray() method:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var states = Ember.Set.create();\n\nstates.add(\"Hawaii\");\nstates.add(\"California\")\n\nstates.toArray()\n//=\u003e [\"Hawaii\", \"California\"]\n\n\n\nNote that in many enumerables, such as the Ember.Set used in this\nexample, the order of the resulting array is not guaranteed.\nFirst and Last Objects\nAll Enumerables expose firstObject and lastObject properties\nthat you can bind to.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var animals = [\"rooster\", \"pig\"];\n\nanimals.get('lastObject');\n//=\u003e \"pig\"\n\nanimals.pushObject(\"peacock\");\n\nanimals.get('lastObject');\n//=\u003e \"peacock\"\n\n\nMap\nYou can easily transform each item in an enumerable using the\nmap() method, which creates a new array with results of calling a\nfunction on each item in the enumerable.\n\n  1\n2\n3\n4\n5\n6\n\n  var words = [\"goodbye\", \"cruel\", \"world\"];\n\nvar emphaticWords = words.map(function(item) {\n  return item + \"!\";\n});\n// [\"goodbye!\", \"cruel!\", \"world!\"]\n\n\n\nIf your enumerable is composed of objects, there is a mapBy()\nmethod that will extract the named property from each of those objects\nin turn and return a new array:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  var hawaii = Ember.Object.create({\n  capital: \"Honolulu\"\n});\n\nvar california = Ember.Object.create({\n  capital: \"Sacramento\"\n});\n\nvar states = [hawaii, california];\n\nstates.mapBy('capital');\n//=\u003e [\"Honolulu\", \"Sacramento\"]\n\n\nFiltering\nAnother common task to perform on an Enumerable is to take the\nEnumerable as input, and return an Array after filtering it based on\nsome criteria.\n\nFor arbitrary filtering, use the filter method.  The filter method\nexpects the callback to return true if Ember should include it in the\nfinal Array, and false or undefined if Ember should not.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var arr = [1,2,3,4,5];\n\narr.filter(function(item, index, self) {\n  if (item \u003c 4) { return true; }\n})\n\n// returns [1,2,3]\n\n\n\nWhen working with a collection of Ember objects, you will often want to filter a set of objects based upon the value of some property. The filterBy method provides a shortcut.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  Todo = Ember.Object.extend({\n  title: null,\n  isDone: false\n});\n\ntodos = [\n  Todo.create({ title: 'Write code', isDone: true }),\n  Todo.create({ title: 'Go to sleep' })\n];\n\ntodos.filterBy('isDone', true);\n\n// returns an Array containing only items with `isDone == true`\n\n\n\nIf you want to return just the first matched value, rather than an Array containing all of the matched values, you can use find and findBy, which work just like filter and filterBy, but return only one item.\nAggregate Information (All or Any)\nIf you want to find out whether every item in an Enumerable matches some condition, you can use the every method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  Person = Ember.Object.extend({\n  name: null,\n  isHappy: false\n});\n\nvar people = [\n  Person.create({ name: 'Yehuda', isHappy: true }),\n  Person.create({ name: 'Majd', isHappy: false })\n];\n\npeople.every(function(person, index, self) {\n  if(person.get('isHappy')) { return true; }\n});\n\n// returns false\n\n\n\nIf you want to find out whether at least one item in an Enumerable matches some conditions, you can use the some method:\n\n  1\n2\n3\n4\n5\n\n  people.some(function(person, index, self) {\n  if(person.get('isHappy')) { return true; }\n});\n\n// returns true\n\n\n\nJust like the filtering methods, the every and some methods have analogous isEvery and isAny methods.\n\n  1\n2\n\n  people.isEvery('isHappy', true) // false\npeople.isAny('isHappy', true)  // true\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f6d3938daff09446eda000dd4f556531","fields":[{"name":"title","value":"Getting Ember","type":"string"},{"name":"url","value":"/getting-ember/","type":"enum"},{"name":"body","value":"Ember Builds\nThe Ember Release Management Team maintains a variety of ways to get  Ember and Ember Data builds.\nChannels\nThe latest Release, Beta, and Canary builds of Ember and Ember data can be found here. For each channel a development, minified, and production version is available. For more on the different channels read the Post 1.0 Release Cycle blog post.\nTagged Releases\nPast release and beta builds  of Ember and Ember Data are available at Tagged Releases. These builds can be useful to track down regressions in your application, but it is recommended to use the latest stable release in production.\nBower\nBower is a package manager for the web. Bower makes it easy to manage dependencies in your application including Ember and Ember Data. To learn more about Bower visit http://bower.io/.\n\nAdding Ember to your application with Bower is easy; simply run bower install ember --save. For Ember Data, run bower install ember-data --save. You can also add ember or ember-data to your bower.json file as follows.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  {\n    \"name\": \"your-app\",\n    \"dependencies\": {\n        \"ember\": \"~1.6\",\n        \"ember-data\": \"~1.0.0-beta.8\"\n    }\n}\n\n\n\nRubyGems\nIf your application uses a Ruby based build system, you can use the ember-source and ember-data-source RubyGems to access ember and ember data sources from Ruby.\n\nIf your application is built in Rails, the ember-rails RubyGem makes it easy to integrate Ember into your Ruby on Rails application.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"efeed0e4604761b1bcb4e6fbb8214094","fields":[{"name":"title","value":"Accepting Edits","type":"string"},{"name":"url","value":"/getting-started/accepting-edits/","type":"enum"},{"name":"body","value":"In the previous step we updated TodoMVC to allow a user to toggle the display of a text \u003cinput\u003e for editing a todo's title. Next, we'll add the behavior that immediately focuses the \u003cinput\u003e when it appears, accepts user input and, when the user presses the \u003center\u003e key or moves focus away from the editing \u003cinput\u003e element, persists these changes, then redisplays the todo with its newly updated text.\n\nTo accomplish this, we'll create a new custom component and register it with Handlebars to make it available to our templates.\n\nCreate a new file js/views/edit_todo_view.js. You may place this file anywhere you like (even just putting all code into the same file), but this guide will assume you have created the file and named it as indicated.\n\nIn js/views/edit_todo_view.js create an extension of Ember.TextField and register it as\na helper:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  Todos.EditTodoView = Ember.TextField.extend({\n  didInsertElement: function() {\n    this.$().focus();\n  }\n});\n\nEmber.Handlebars.helper('edit-todo', Todos.EditTodoView);\n\n\n\nIn index.html require this new file:\n\n  1\n2\n3\n4\n5\n\n  \u003c!--- ... additional lines truncated for brevity ... --\u003e\n  \u003cscript src=\"js/controllers/todo_controller.js\"\u003e\u003c/script\u003e\n  \u003cscript src=\"js/views/edit_todo_view.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c!--- ... additional lines truncated for brevity ... --\u003e\n\n\n\nIn index.html replace the static \u003cinput\u003e element with our custom {{edit-todo}} component, connecting the value property, and actions:\n\n  1\n2\n3\n4\n5\n6\n\n  {{! ... additional lines truncated for brevity ... }}\n{{#if todo.isEditing}}\n  {{edit-todo class=\"edit\" value=todo.title focus-out=\"acceptChanges\"\n                           insert-newline=\"acceptChanges\"}}\n{{else}}\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nPressing the \u003center\u003e key  will trigger the acceptChanges event on the instance of TodoController. Moving focus away from the \u003cinput\u003e will trigger the focus-out event, calling a method acceptChanges on this view's instance of TodoController.\n\nAdditionally, we connect the value property of this \u003cinput\u003e to the title property of this instance of TodoController. We will not implement a title property on the controller so it will retain the default behavior of proxying all requests to its model.\n\nA CSS class edit is applied for styling.\n\nIn js/controllers/todo_controller.js, add the method acceptChanges that we called from EditTodoView:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  // ... additional lines truncated for brevity ...\nactions: {\n  editTodo: function() {\n    this.set('isEditing', true);\n  },\n  acceptChanges: function() {\n    this.set('isEditing', false);\n\n    if (Ember.isEmpty(this.get('model.title'))) {\n      this.send('removeTodo');\n    } else {\n      this.get('model').save();\n    }\n  },\n  removeTodo: function () {\n    var todo = this.get('model');\n    todo.deleteRecord();\n    todo.save();\n  }\n},\n// ... additional lines truncated for brevity ...\n\n\n\nThis method will set the controller's isEditing property to false and commit all changes made to the todo.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nController Guide\nEmber.TextField API documentation\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a205da8b5b6c5ff6c67c1153b89dda98","fields":[{"name":"title","value":"Adding the First Route and Template","type":"string"},{"name":"url","value":"/getting-started/adding-a-route-and-template/","type":"enum"},{"name":"body","value":"Next, we will create an Ember.js application, a route ('/'), and convert our static mockup into a Handlebars template.\n\nInside your js directory, add a file for the application at js/application.js and a file for the router at js/router.js. You may place these files anywhere you like (even just putting all code into the same file), but this guide will assume you have separated them into their own files and named them as indicated.\n\nInside js/application.js add the following code:\n\n  1\n\n  window.Todos = Ember.Application.create();\n\n\n\nThis will create a new instance of Ember.Application and make it available as a variable named Todos within your browser's JavaScript environment.\n\nInside js/router.js add the following code:\n\n  1\n2\n3\n\n  Todos.Router.map(function() {\n  this.resource('todos', { path: '/' });\n});\n\n\n\nThis will tell Ember.js to detect when the application's URL matches '/' and to render the todos template.\n\nNext, update your index.html to wrap the inner contents of \u003cbody\u003e in a Handlebars script tag and include js/application.js and js/router.js after Ember.js and other javascript dependencies:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  \u003c!-- ... additional lines truncated for brevity ... --\u003e\n\u003cbody\u003e\n  \u003cscript type=\"text/x-handlebars\" data-template-name=\"todos\"\u003e\n\n    \u003csection id=\"todoapp\"\u003e\n      {{! ... additional lines truncated for brevity ... }}\n    \u003c/section\u003e\n\n    \u003cfooter id=\"info\"\u003e\n      \u003cp\u003eDouble-click to edit a todo\u003c/p\u003e\n    \u003c/footer\u003e\n\n  \u003c/script\u003e\n\n  \u003c!-- ... Ember.js and other javascript dependencies ... --\u003e\n  \u003cscript src=\"js/application.js\"\u003e\u003c/script\u003e\n  \u003cscript src=\"js/router.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c!-- ... additional lines truncated for brevity ... --\u003e\n\n\n\nReload your web browser to ensure that all files have been referenced correctly and no errors occur.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nHandlebars Guide\nEmber.Application Guide\nEmber.Application API Documentation\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ba4a46e3f62f73d73948463aa0784240","fields":[{"name":"title","value":"Adding Child Routes","type":"string"},{"name":"url","value":"/getting-started/adding-child-routes/","type":"enum"},{"name":"body","value":"Next we will split our single template into a set of nested templates so we can transition between different lists of todos in reaction to user interaction.\n\nIn index.html move the entire \u003cul\u003e of todos into a new template named todos/index by adding a new Handlebars template \u003cscript\u003e tag inside the \u003cbody\u003e of the document:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  \u003c!--- ... additional lines truncated for brevity ... --\u003e\n\u003cbody\u003e\n\u003cscript type=\"text/x-handlebars\" data-template-name=\"todos/index\"\u003e\n  \u003cul id=\"todo-list\"\u003e\n    {{#each todo in model itemController=\"todo\"}}\n      \u003cli {{bind-attr class=\"todo.isCompleted:completed todo.isEditing:editing\"}}\u003e\n        {{#if todo.isEditing}}\n          {{edit-todo class=\"edit\" value=todo.title focus-out=\"acceptChanges\" insert-newline=\"acceptChanges\"}}\n        {{else}}\n          {{input type=\"checkbox\" checked=todo.isCompleted class=\"toggle\"}}\n          \u003clabel {{action \"editTodo\" on=\"doubleClick\"}}\u003e{{todo.title}}\u003c/label\u003e\u003cbutton {{action \"removeTodo\"}} class=\"destroy\"\u003e\u003c/button\u003e\n        {{/if}}\n      \u003c/li\u003e\n    {{/each}}\n  \u003c/ul\u003e\n\u003c/script\u003e\n\u003c!--- ... additional lines truncated for brevity ... --\u003e\n\n\n\nStill within index.html place a Handlebars {{outlet}} helper where the \u003cul\u003e was previously:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  {{! ... additional lines truncated for brevity ... }}\n\u003csection id=\"main\"\u003e\n  {{outlet}}\n\n  \u003cinput type=\"checkbox\" id=\"toggle-all\"\u003e\n\u003c/section\u003e\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nThe {{outlet}} Handlebars helper designates an area of a template that will dynamically update as we transition between routes. Our first new child route will fill this area with the list of all todos in the application.\n\nIn js/router.js update the router to change the todos mapping, with an additional empty function parameter so it can accept child routes, and add this first index route:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  Todos.Router.map(function () {\n  this.resource('todos', { path: '/' }, function () {\n    // additional child routes will go here later\n  });\n});\n\n// ... additional lines truncated for brevity ...\n\nTodos.TodosIndexRoute = Ember.Route.extend({\n  model: function() {\n    return this.modelFor('todos');\n  }\n});\n\n\n\nWhen the application loads at the url '/' Ember.js will enter the todos route and render the todos template as before. It will also transition into the todos.index route and fill the {{outlet}} in the todos template with the todos/index template.  The model data for this template is the result of the model method of TodosIndexRoute, which indicates that the\nmodel for this route is the same model as for the TodosRoute.\n\nThis mapping is described in more detail in the Naming Conventions Guide.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nEmber Router Guide\nEmber Controller Guide\noutlet API documentation\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"447bfe6932d49c99c732a500d5950e94","fields":[{"name":"title","value":"Creating a New Model Instance","type":"string"},{"name":"url","value":"/getting-started/creating-a-new-model/","type":"enum"},{"name":"body","value":"Next we'll update our static HTML \u003cinput\u003e to an Ember view that can expose more complex behaviors.  Update index.html to replace the new todo \u003cinput\u003e with an {{input}} helper:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  {{! ... additional lines truncated for brevity ... }}\n\u003ch1\u003etodos\u003c/h1\u003e\n{{input\n  type=\"text\"\n  id=\"new-todo\"\n  placeholder=\"What needs to be done?\"\n  value=newTitle\n  action=\"createTodo\"}}\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nThis will render an \u003cinput\u003e element at this location with the same id and placeholder attributes applied. It will also connect the newTitle property of this template's controller to the value attribute of the \u003cinput\u003e. When one changes, the other will automatically update to remain synchronized.\n\nAdditionally, we connect user interaction (pressing the \u003center\u003e key) to a method createTodo on this template's controller.\n\nBecause we have not needed a custom controller behavior until this point, Ember.js provided a default controller object for this template. To handle our new behavior, we can implement the controller class Ember.js expects to find according to its naming conventions and add our custom behavior. This new controller class will automatically be associated with this template for us.\n\nAdd a js/controllers/todos_controller.js file. You may place this file anywhere you like (even just putting all code into the same file), but this guide will assume you have created the file and named it as indicated.\n\nInside js/controllers/todos_controller.js implement the controller Ember.js expects to find according to its naming conventions:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  Todos.TodosController = Ember.ArrayController.extend({\n  actions: {\n    createTodo: function() {\n      // Get the todo title set by the \"New Todo\" text field\n      var title = this.get('newTitle');\n      if (!title.trim()) { return; }\n\n      // Create the new Todo model\n      var todo = this.store.createRecord('todo', {\n        title: title,\n        isCompleted: false\n      });\n\n      // Clear the \"New Todo\" text field\n      this.set('newTitle', '');\n\n      // Save the new model\n      todo.save();\n    }\n  }\n});\n\n\n\nThis controller will now respond to user action by using its newTitle property as the title of a new todo whose isCompleted property is false.  Then it will clear its newTitle property which will synchronize to the template and reset the textfield. Finally, it persists any unsaved changes on the todo.\n\nIn index.html include js/controllers/todos_controller.js as a dependency:\n\n  1\n2\n3\n4\n5\n\n  \u003c!--- ... additional lines truncated for brevity ... --\u003e\n   \u003cscript src=\"js/models/todo.js\"\u003e\u003c/script\u003e\n   \u003cscript src=\"js/controllers/todos_controller.js\"\u003e\u003c/script\u003e\n \u003c/body\u003e\n \u003c!--- ... additional lines truncated for brevity ... --\u003e\n\n\n\nReload your web browser to ensure that all files have been referenced correctly and no errors occur. You should now be able to add additional todos by entering a title in the \u003cinput\u003e and hitting the \u003center\u003e key.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nEmber.TextField API documention\nEmber Controller Guide\nNaming Conventions Guide\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"39352015012c0211f31becb538db9d10","fields":[{"name":"title","value":"Creating a Static Mockup","type":"string"},{"name":"url","value":"/getting-started/creating-a-static-mockup/","type":"enum"},{"name":"body","value":"Before adding any code, we can roughly sketch out the layout of our application. In your text editor, create a new file and name it index.html. This file will contain the HTML templates of our completed application and trigger requests for the additional image, stylesheet, and JavaScript resources.\n\nTo start, add the following text to index.html:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n  \u003c!doctype html\u003e\n\u003chtml\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"utf-8\"\u003e\n    \u003ctitle\u003eEmber.js • TodoMVC\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"style.css\"\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003csection id=\"todoapp\"\u003e\n      \u003cheader id=\"header\"\u003e\n        \u003ch1\u003etodos\u003c/h1\u003e\n        \u003cinput type=\"text\" id=\"new-todo\" placeholder=\"What needs to be done?\" /\u003e\n      \u003c/header\u003e\n\n      \u003csection id=\"main\"\u003e\n        \u003cul id=\"todo-list\"\u003e\n          \u003cli class=\"completed\"\u003e\n            \u003cinput type=\"checkbox\" class=\"toggle\"\u003e\n            \u003clabel\u003eLearn Ember.js\u003c/label\u003e\u003cbutton class=\"destroy\"\u003e\u003c/button\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\n            \u003cinput type=\"checkbox\" class=\"toggle\"\u003e\n            \u003clabel\u003e...\u003c/label\u003e\u003cbutton class=\"destroy\"\u003e\u003c/button\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\n            \u003cinput type=\"checkbox\" class=\"toggle\"\u003e\n            \u003clabel\u003eProfit!\u003c/label\u003e\u003cbutton class=\"destroy\"\u003e\u003c/button\u003e\n          \u003c/li\u003e\n        \u003c/ul\u003e\n\n        \u003cinput type=\"checkbox\" id=\"toggle-all\"\u003e\n      \u003c/section\u003e\n\n      \u003cfooter id=\"footer\"\u003e\n        \u003cspan id=\"todo-count\"\u003e\n          \u003cstrong\u003e2\u003c/strong\u003e todos left\n        \u003c/span\u003e\n        \u003cul id=\"filters\"\u003e\n          \u003cli\u003e\n            \u003ca href=\"all\" class=\"selected\"\u003eAll\u003c/a\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\n            \u003ca href=\"active\"\u003eActive\u003c/a\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\n            \u003ca href=\"completed\"\u003eCompleted\u003c/a\u003e\n          \u003c/li\u003e\n        \u003c/ul\u003e\n\n        \u003cbutton id=\"clear-completed\"\u003e\n          Clear completed (1)\n        \u003c/button\u003e\n      \u003c/footer\u003e\n    \u003c/section\u003e\n\n    \u003cfooter id=\"info\"\u003e\n      \u003cp\u003eDouble-click to edit a todo\u003c/p\u003e\n    \u003c/footer\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n\n\n\nThe associated stylesheet and background image for this project should be downloaded and placed in the same directory as index.html\n\nOpen index.html in your web browser to ensure that all assets are loading correctly. You should see the TodoMVC application with three hard-coded \u003cli\u003e elements where the text of each todo will appear.\nLive Preview\nEmber.js • TodoMVC \nAdditional Resources\n\nChanges in this step in diff format\nTodoMVC stylesheet\nTodoMVC background image\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"aa055858ab633f66a458868ca155b0ba","fields":[{"name":"title","value":"Deleting a Model","type":"string"},{"name":"url","value":"/getting-started/deleting-todos/","type":"enum"},{"name":"body","value":"TodoMVC displays a button for removing todos next to each todo when its \u003cli\u003e is hovered. Clicking this button will remove the todo and update the display of remaining incomplete todos and remaining completed todos appropriately.\n\nIn index.html update the static \u003cbutton\u003e element to include an {{action}} Handlebars helper:\n\n  1\n2\n3\n\n  {{! ... additional lines truncated for brevity ... }}\n\u003cbutton {{action \"removeTodo\"}} class=\"destroy\"\u003e\u003c/button\u003e\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nThis will call the removeTodo action defined in the previous chapter and will delete the todo locally and then persist this data change.\n\nBecause the todo is no longer part of the collection of all todos, its \u003cli\u003e element in the page will be automatically removed for us. If the deleted todo was incomplete, the count of remaining todos will be decreased by one and the display of this number will be automatically re-rendered. If the new count results in an inflection change between \"todo\" and \"todos\" this area of the page will be automatically re-rendered.\n\nReload your web browser to ensure that there are no errors and the behaviors described above occurs.\n\nNote: The current action may be invoked twice (via acceptChanges) leading to an exception. For details on how to handle this situation, please see the latest version of the TodoMVC source.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\naction API documentation\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c410128aa0d39ba56632ba3ddece73a7","fields":[{"name":"title","value":"Displaying a Button to Remove All Completed Todos","type":"string"},{"name":"url","value":"/getting-started/display-a-button-to-remove-completed-todos/","type":"enum"},{"name":"body","value":"TodoMVC allows users to delete all completed todos at once by clicking a button. This button is visible only when there are any completed todos, displays the number of completed todos, and removes all completed todos from the application when clicked.\n\nIn this step, we'll implement that behavior. In index.html update the static \u003cbutton\u003e for clearing all completed todos:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  {{! ... additional lines truncated for brevity ... }}\n{{#if hasCompleted}}\n  \u003cbutton id=\"clear-completed\" {{action \"clearCompleted\"}}\u003e\n    Clear completed ({{completed}})\n  \u003c/button\u003e\n{{/if}}\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nIn js/controllers/todos_controller.js implement the matching properties and a method that will clear completed todos and persist these changes when the button is clicked:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  // ... additional lines truncated for brevity ...\nactions: {\n  clearCompleted: function() {\n    var completed = this.filterBy('isCompleted', true);\n    completed.invoke('deleteRecord');\n    completed.invoke('save');\n  },\n  // ... additional lines truncated for brevity ...\n},\nhasCompleted: function() {\n  return this.get('completed') \u003e 0;\n}.property('completed'),\n\ncompleted: function() {\n  return this.filterBy('isCompleted', true).get('length');\n}.property('@each.isCompleted'),\n// ... additional lines truncated for brevity ...\n\n\n\nThe completed and clearCompleted methods both invoke the filterBy method, which is part of the ArrayController API and returns an instance of EmberArray which contains only the items for which the callback returns true.  The clearCompleted method also invokes the invoke method which is part of the EmberArray API.  invoke will execute a method on each object in the Array if the method exists on that object.\n\nReload your web browser to ensure that there are no errors and the behavior described above occurs.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nHandlebars Conditionals Guide\nEnumerables Guide\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"02a96af44ea3b3075be638ed925b33c2","fields":[{"name":"title","value":"Displaying a Model's Complete State","type":"string"},{"name":"url","value":"/getting-started/displaying-a-models-completeness/","type":"enum"},{"name":"body","value":"TodoMVC strikes through completed todos by applying a CSS class completed to the \u003cli\u003e element. Update index.html to apply a CSS class to this element when a todo's isCompleted property is true:\n\n  1\n2\n3\n4\n5\n6\n\n  {{! ... additional lines truncated for brevity ... }}\n\u003cli {{bind-attr class=\"todo.isCompleted:completed\"}}\u003e\n  \u003cinput type=\"checkbox\" class=\"toggle\"\u003e\n  \u003clabel\u003e{{todo.title}}\u003c/label\u003e\u003cbutton class=\"destroy\"\u003e\u003c/button\u003e\n\u003c/li\u003e\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nThis code will apply the CSS class completed when the todo's isCompleted property is true and remove it when the property becomes false.\n\nThe first fixture todo in our application has an isCompleted property of true. Reload the application to see the first todo is now decorated with a strike-through to visually indicate it has been completed.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nbind-attr API documentation\nbind and bind-attr article by Peter Wagenet\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"921c938463653564c581f066562cc0b2","fields":[{"name":"title","value":"Displaying Model Data","type":"string"},{"name":"url","value":"/getting-started/displaying-model-data/","type":"enum"},{"name":"body","value":"Next we'll update our application to display dynamic todos, replacing our hard coded section in the todos template.\n\nInside the file js/router.js implement a TodosRoute class with a model function that returns all the existing todos:\n\n  1\n2\n3\n4\n5\n6\n\n  // ... additional lines truncated for brevity ...\nTodos.TodosRoute = Ember.Route.extend({\n  model: function() {\n    return this.store.find('todo');\n  }\n});\n\n\n\nBecause we hadn't implemented this class before, Ember.js provided a Route for us with the default behavior of rendering a matching template named todos using its naming conventions for object creation.\n\nNow that we need custom behavior (returning a specific set of models), we implement the class and add the desired behavior.\n\nUpdate index.html to replace the static \u003cli\u003e elements with a Handlebars {{each}} helper and a dynamic {{title}} for each item.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  {{! ... additional lines truncated for brevity ... }}\n\u003cul id=\"todo-list\"\u003e\n  {{#each todo in model}}\n    \u003cli\u003e\n      \u003cinput type=\"checkbox\" class=\"toggle\"\u003e\n      \u003clabel\u003e{{todo.title}}\u003c/label\u003e\u003cbutton class=\"destroy\"\u003e\u003c/button\u003e\n    \u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nEmber.js has created a controller for us and set the controller's model property to our route's model. The template loops over the controller's model property. Because we don't need custom behavior for this controller yet, we can use the default object provided by the framework.\n\nReload your web browser to ensure that all files have been referenced correctly and no errors occur.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nTemplates Guide\nControllers Guide\nNaming Conventions Guide\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0c262c72493852d5d9c0f6ebf707fbb0","fields":[{"name":"title","value":"Displaying the Number of Incomplete Todos","type":"string"},{"name":"url","value":"/getting-started/displaying-the-number-of-incomplete-todos/","type":"enum"},{"name":"body","value":"Next we'll update our template's hard-coded count of remaining todos to reflect the actual number of remaining todos. Update index.html to use two properties:\n\n  1\n2\n3\n4\n5\n\n  {{! ... additional lines truncated for brevity ... }}\n\u003cspan id=\"todo-count\"\u003e\n  \u003cstrong\u003e{{remaining}}\u003c/strong\u003e {{inflection}} left\n\u003c/span\u003e\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nImplement these properties as part of this template's controller, the Todos.TodosController:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  // ... additional lines truncated for brevity ...\nactions: {\n  // ... additional lines truncated for brevity ...\n},\n\nremaining: function() {\n  return this.filterBy('isCompleted', false).get('length');\n}.property('@each.isCompleted'),\n\ninflection: function() {\n  var remaining = this.get('remaining');\n  return remaining === 1 ? 'item' : 'items';\n}.property('remaining')\n// ... additional lines truncated for brevity ...\n\n\n\nThe remaining property will return the number of todos whose isCompleted property is false. If the isCompleted value of any todo changes, this property will be recomputed. If the value has changed, the section of the template displaying the count will be automatically updated to reflect the new value.\n\nThe inflection property will return either a plural or singular version of the word \"item\" depending on how many todos are currently in the list. The section of the template displaying the count will be automatically updated to reflect the new value.\n\nReload your web browser to ensure that no errors occur. You should now see an accurate number for remaining todos.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nComputed Properties Guide\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"59427847e14331e01de43a097e3ee4cb","fields":[{"name":"title","value":"Getting Started","type":"string"},{"name":"url","value":"/getting-started/","type":"enum"},{"name":"body","value":"Welcome to Ember.js! This guide will take you through creating a simple application using Ember.js and briefly explain the core concepts behind the framework. This guide assumes you are already familiar with basic web technologies like JavaScript, HTML, and CSS and development technologies like your browser's web inspector.\n\nIn this guide we will walk through the steps of building the popular TodoMVC demo application.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0ed571ead8c44c9164378704319ad93f","fields":[{"name":"title","value":"Marking a Model as Complete or Incomplete","type":"string"},{"name":"url","value":"/getting-started/marking-a-model-as-complete-incomplete/","type":"enum"},{"name":"body","value":"In this step we'll update our application to allow a user to mark a todo as complete or incomplete and persist the updated information.\n\nIn index.html update your template to wrap each todo in its own controller by adding an itemController argument to the {{each}} Handlebars helper. Then convert our static \u003cinput type=\"checkbox\"\u003e into a {{input}} helper:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  {{! ... additional lines truncated for brevity ... }}\n{{#each todo in model itemController=\"todo\"}}\n  \u003cli {{bind-attr class=\"todo.isCompleted:completed\"}}\u003e\n    {{input type=\"checkbox\" checked=todo.isCompleted class=\"toggle\"}}\n    \u003clabel\u003e{{todo.title}}\u003c/label\u003e\u003cbutton class=\"destroy\"\u003e\u003c/button\u003e\n  \u003c/li\u003e\n{{/each}}\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nWhen this {{input}} is rendered it will ask for the current value of the controller's isCompleted property. When a user clicks this input, it will set the value of the controller's isCompleted property to either true or false depending on the new checked value of the input.\n\nImplement the controller for each todo by matching the name used as the itemController value to a class in your application Todos.TodoController. Create a new file at js/controllers/todo_controller.js for this code. You may place this file anywhere you like (even just putting all code into the same file), but this guide will assume you have created the file and named it as indicated.\n\nInside js/controllers/todo_controller.js add code for Todos.TodoController and its isCompleted property:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  Todos.TodoController = Ember.ObjectController.extend({\n  isCompleted: function(key, value){\n    var model = this.get('model');\n\n    if (value === undefined) {\n      // property being used as a getter\n      return model.get('isCompleted');\n    } else {\n      // property being used as a setter\n      model.set('isCompleted', value);\n      model.save();\n      return value;\n    }\n  }.property('model.isCompleted')\n});\n\n\n\nWhen called from the template to display the current isCompleted state of the todo, this property will proxy that question to its underlying model. When called with a value because a user has toggled the checkbox in the template, this property will set the isCompleted property of its model to the passed value (true or false), persist the model update, and return the passed value so the checkbox will display correctly.\n\nThe isCompleted function is marked a computed property whose value is dependent on the value of model.isCompleted.\n\nIn index.html include js/controllers/todo_controller.js as a dependency:\n\n  1\n2\n3\n4\n5\n6\n\n  \u003c!--- ... additional lines truncated for brevity ... --\u003e\n   \u003cscript src=\"js/models/todo.js\"\u003e\u003c/script\u003e\n   \u003cscript src=\"js/controllers/todos_controller.js\"\u003e\u003c/script\u003e\n   \u003cscript src=\"js/controllers/todo_controller.js\"\u003e\u003c/script\u003e\n \u003c/body\u003e\n \u003c!--- ... additional lines truncated for brevity ... --\u003e\n\n\n\nReload your web browser to ensure that all files have been referenced correctly and no errors occur. You should now be able to change the isCompleted property of a todo.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nEmber.Checkbox API documentation\nEmber Controller Guide\nComputed Properties Guide\nNaming Conventions Guide\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b9ba1d8fb68ab51d3298493c5747a2a2","fields":[{"name":"title","value":"Modeling Data","type":"string"},{"name":"url","value":"/getting-started/modeling-data/","type":"enum"},{"name":"body","value":"Next we will create a model class to describe todo items. \n\nCreate a file at js/models/todo.js and put the following code inside:\n\n  1\n2\n3\n4\n\n  Todos.Todo = DS.Model.extend({\n  title: DS.attr('string'),\n  isCompleted: DS.attr('boolean')\n});\n\n\n\nThis code creates a new class Todo and places it within your application's namespace. Each todo will have two attributes: title and isCompleted.\n\nYou may place this file anywhere you like (even just putting all code into the same file), but this guide will assume you have created a file and named it as indicated.\n\nFinally, update your index.html to include a reference to this new file:\n\n  1\n2\n3\n4\n\n  \u003c!-- ... additional lines truncated for brevity ... --\u003e\n  \u003cscript src=\"js/models/todo.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c!-- ... additional lines truncated for brevity ... --\u003e\n\n\n\nReload your web browser to ensure that all files have been referenced correctly and no errors occur.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nModels Guide\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"73ca41ba4eee0d2ef2bf3b1275325615","fields":[{"name":"title","value":"Obtaining Ember.js and Dependencies","type":"string"},{"name":"url","value":"/getting-started/obtaining-emberjs-and-dependencies/","type":"enum"},{"name":"body","value":"TodoMVC has a few dependencies:\n\n\njQuery\nHandlebars\nEmber.js\nEmber Data 1.0 beta\n\n\nFor this example, all of these resources should be stored in the folder js/libs located in the same location as index.html. Update your index.html to load these files by placing \u003cscript\u003e tags just before your closing \u003c/body\u003e tag in the following order:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003c!-- ... additional lines truncated for brevity ... --\u003e\n  \u003cscript src=\"js/libs/jquery-1.11.2.min.js\"\u003e\u003c/script\u003e\n  \u003cscript src=\"js/libs/handlebars-v1.3.0.js\"\u003e\u003c/script\u003e\n  \u003cscript src=\"js/libs/ember.js\"\u003e\u003c/script\u003e\n  \u003cscript src=\"js/libs/ember-data.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c!-- ... additional lines truncated for brevity ... --\u003e\n\n\n\nReload your web browser to ensure that all files have been referenced correctly and no errors occur.\n\nIf you are using a package manager, such as bower, make sure to checkout the Getting Ember guide for info on other ways to get Ember.js (this guide is dependant on ember-data v1.0 or greater so please be sure to use the latest beta).\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ccd0b930897f8be7f9d3f7c3f3c4f306","fields":[{"name":"title","value":"Planning The Application","type":"string"},{"name":"url","value":"/getting-started/planning-the-application/","type":"enum"},{"name":"body","value":"TodoMVC, despite its small size, contains most of the behaviors typical in modern single page applications. Before continuing, take a moment to understand how TodoMVC works from the user's perspective.\n\nTodoMVC has the following main features:\n\n\n\nIt displays a list of todos for a user to see. This list will grow and shrink as the user adds and removes todos.\nIt accepts text in an \u003cinput\u003e for entry of new todos. Hitting the \u003center\u003e key creates the new item and displays it in the list below.\nIt provides a checkbox to toggle between complete and incomplete states for each todo. New todos start as incomplete.\nIt displays the number of incomplete todos and keeps this count updated as new todos are added and existing todos are completed.\nIt provides links for the user to navigate between lists showing all, incomplete, and completed todos.\nIt provides a button to remove all completed todos and informs the user of the number of completed todos. This button will not be visible if there are no completed todos.\nIt provides a button to remove a single specific todo. This button displays as a user hovers over a todo and takes the form of a red X.\nIt provides a checkbox to toggle all existing todos between complete and incomplete states. Further, when all todos are completed this checkbox becomes checked without user interaction.\nIt allows a user to double click to show a textfield for editing a single todo. Hitting the \u003center\u003e key or moving focus outside of this textfield will persist the changed text.\nIt retains a user's todos between application loads by using the browser's localstorage mechanism.\n\n\nYou can interact with a completed version of the application by visiting the TodoMVC site.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9357ab6d3a2df0c7329aca283bb6acda","fields":[{"name":"title","value":"Transitioning back to Show All Todos","type":"string"},{"name":"url","value":"/getting-started/show-all-todos-again/","type":"enum"},{"name":"body","value":"Next we can update the application to allow navigating back to the list of all todos.\n\nIn index.html convert the \u003ca\u003e tag for 'All' todos into a Handlebars {{link-to}} helper:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {{! ... additional lines truncated for brevity ... }}\n\u003cli\u003e\n  {{#link-to \"todos.index\" activeClass=\"selected\"}}All{{/link-to}}\n\u003c/li\u003e\n\u003cli\u003e\n  {{#link-to \"todos.active\" activeClass=\"selected\"}}Active{{/link-to}}\n\u003c/li\u003e\n\u003cli\u003e\n  {{#link-to \"todos.completed\" activeClass=\"selected\"}}Completed{{/link-to}}\n\u003c/li\u003e\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nReload your web browser to ensure that there are no errors. You should be able to navigate between urls for all, active, and completed todos.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nlink-to API documentation\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c45cc0e217f836d8398fa6721197c1a9","fields":[{"name":"title","value":"Transitioning to Show Only Complete Todos","type":"string"},{"name":"url","value":"/getting-started/show-only-complete-todos/","type":"enum"},{"name":"body","value":"Next we'll update the application so a user can navigate to a url where only todos that have already been completed are displayed.\n\nIn index.html convert the \u003ca\u003e tag for 'Completed' todos into a Handlebars {{link-to}} helper:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {{! ... additional lines truncated for brevity ... }}\n\u003cli\u003e\n  \u003ca href=\"all\"\u003eAll\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n  {{#link-to \"todos.active\" activeClass=\"selected\"}}Active{{/link-to}}\n\u003c/li\u003e\n\u003cli\u003e\n  {{#link-to \"todos.completed\" activeClass=\"selected\"}}Completed{{/link-to}}\n\u003c/li\u003e\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nIn js/router.js update the router to recognize this new path and implement a matching route:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  Todos.Router.map(function() {\n  this.resource('todos', { path: '/' }, function() {\n    // additional child routes\n    this.route('active');\n    this.route('completed');\n  });\n});\n\n// ... additional lines truncated for brevity ...\n\nTodos.TodosCompletedRoute = Ember.Route.extend({\n  model: function() {\n    return this.store.filter('todo', function(todo) {\n      return todo.get('isCompleted');\n    });\n  },\n  renderTemplate: function(controller) {\n    this.render('todos/index', {controller: controller});\n  }\n});\n\n\n\nThe model data for this route is the collection of todos whose isCompleted property is true. Just like we recently saw with the similar function for the active todos, changes to a todo's isCompleted property will automatically cause this collection to refresh, updating the UI accordingly.\n\nTodosCompletedRoute has a similar purpose to the active todos - to reuse the existing todos/index template, rather than having to create a new template.\n\nReload your web browser to ensure that there are no errors and the behavior described above occurs.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nlink-to API documentation\nRoute#renderTemplate API documentation\nRoute#render API documentation\nEmber Router Guide\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"cc0d9ccc7a279e0d89623aeff077d921","fields":[{"name":"title","value":"Transitioning to Show Only Incomplete Todos","type":"string"},{"name":"url","value":"/getting-started/show-only-incomplete-todos/","type":"enum"},{"name":"body","value":"Next we'll update the application so a user can navigate to a url where only todos that are not complete are displayed.\n\nIn index.html convert the \u003ca\u003e tag for 'Active' todos into a Handlebars {{link-to}} helper and remove the active class from the \u003ca\u003e tag for 'All':\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {{! ... additional lines truncated for brevity ... }}\n\u003cli\u003e\n  \u003ca href=\"all\"\u003eAll\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\n  {{#link-to \"todos.active\" activeClass=\"selected\"}}Active{{/link-to}}\n\u003c/li\u003e\n\u003cli\u003e\n  \u003ca href=\"completed\"\u003eCompleted\u003c/a\u003e\n\u003c/li\u003e\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nIn js/router.js update the router to recognize this new path and implement a matching route:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  Todos.Router.map(function() {\n  this.resource('todos', { path: '/' }, function() {\n    // additional child routes will go here later\n    this.route('active');\n  });\n});\n\n// ... additional lines truncated for brevity ...\nTodos.TodosActiveRoute = Ember.Route.extend({\n  model: function(){\n    return this.store.filter('todo', function(todo) {\n      return !todo.get('isCompleted');\n    });\n  },\n  renderTemplate: function(controller) {\n    this.render('todos/index', {controller: controller});\n  }\n});\n\n\n\nThe model data for this route is the collection of todos whose isCompleted property is false. When a todo's isCompleted property changes this collection will automatically update to add or remove the todo appropriately.\n\nNormally transitioning into a new route changes the template rendered into the parent {{outlet}}, but in this case we'd like to reuse the existing todos/index template. We can accomplish this by implementing the renderTemplate method and calling render ourselves with the specific template and controller options.\n\nReload your web browser to ensure that there are no errors and the behavior described above occurs.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nlink-to API documentation\nRoute#renderTemplate API documentation\nRoute#render API documentation\nEmber Router Guide\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4597a4510e49841e40e75368a812379a","fields":[{"name":"title","value":"Indicating When All Todos Are Complete","type":"string"},{"name":"url","value":"/getting-started/show-when-all-todos-are-complete/","type":"enum"},{"name":"body","value":"Next we'll update our template to indicate when all todos have been completed. In index.html replace the static checkbox \u003cinput\u003e with an {{input}}:\n\n  1\n2\n3\n4\n5\n6\n\n  {{! ... additional lines truncated for brevity ... }}\n\u003csection id=\"main\"\u003e\n  {{outlet}}\n  {{input type=\"checkbox\" id=\"toggle-all\" checked=allAreDone}}\n\u003c/section\u003e\n{{! ... additional lines truncated for brevity ... }}\n\n\n\nThis checkbox will be checked when the controller property allAreDone is true and unchecked when the property allAreDone is false.\n\nIn js/controllers/todos_controller.js implement the matching allAreDone property:\n\n  1\n2\n3\n4\n5\n\n  // ... additional lines truncated for brevity ...\nallAreDone: function(key, value) {\n  return !!this.get('length') \u0026\u0026 this.isEvery('isCompleted');\n}.property('@each.isCompleted')\n// ... additional lines truncated for brevity ...\n\n\n\nThis property will be true if the controller has any todos and every todo's isCompleted property is true. If the isCompleted property of any todo changes, this property will be recomputed. If the return value has changed, sections of the template that need to update will be automatically updated for us.\n\nReload your web browser to ensure that there are no errors and the behavior described above occurs. \nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nEmber.Checkbox API documentation\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d715080010af9f5a3d04206889ecfe41","fields":[{"name":"title","value":"Toggling All Todos Between Complete and Incomplete","type":"string"},{"name":"url","value":"/getting-started/toggle-all-todos/","type":"enum"},{"name":"body","value":"TodoMVC allows users to toggle all existing todos into either a complete or incomplete state. It uses the same checkbox that becomes checked when all todos are completed and unchecked when one or more todos remain incomplete.\n\nTo implement this behavior update the allAreDone property in js/controllers/todos_controller.js to handle both getting and setting behavior:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  // ... additional lines truncated for brevity ...\nallAreDone: function(key, value) {\n  if (value === undefined) {\n    return !!this.get('length') \u0026\u0026 this.isEvery('isCompleted', true);\n  } else {\n    this.setEach('isCompleted', value);\n    this.invoke('save');\n    return value;\n  }\n}.property('@each.isCompleted')\n// ... additional lines truncated for brevity ...\n\n\n\nIf no value argument is passed this property is being used to populate the current value of the checkbox. If a value is passed it indicates the checkbox was used by a user and we should set the isCompleted property of each todo to this new value.\n\nThe count of remaining todos and completed todos used elsewhere in the template automatically re-render for us if necessary.\n\nReload your web browser to ensure that there are no errors and the behavior described above occurs.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nEmber.Checkbox API documentation\nComputed Properties Guide\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b8efdbb8279718e20ee68c783f49a97e","fields":[{"name":"title","value":"Toggling between Showing and Editing States","type":"string"},{"name":"url","value":"/getting-started/toggle-todo-editing-state/","type":"enum"},{"name":"body","value":"TodoMVC allows users to double click each todo to display a text \u003cinput\u003e element where the todo's title can be updated. Additionally the \u003cli\u003e element for each todo obtains the CSS class editing for style and positioning.\n\nWe'll update the application to allow users to toggle into this editing state for a todo. In index.html update the contents of the {{each}} Handlebars helper to:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n   {{! ... additional lines truncated for brevity ... }}\n{{#each todo in model itemController=\"todo\"}}\n  \u003cli {{bind-attr class=\"todo.isCompleted:completed todo.isEditing:editing\"}}\u003e\n    {{#if todo.isEditing}}\n      \u003cinput class=\"edit\"\u003e\n    {{else}}\n      {{input type=\"checkbox\" checked=todo.isCompleted class=\"toggle\"}}\n      \u003clabel {{action \"editTodo\" on=\"doubleClick\"}}\u003e{{todo.title}}\u003c/label\u003e\u003cbutton class=\"destroy\"\u003e\u003c/button\u003e\n    {{/if}}\n  \u003c/li\u003e\n{{/each}}\n {{! ... additional lines truncated for brevity ... }}\n\n\n\nThe above code applies three new behaviors to our application: it applies the CSS class editing when the controller's isEditing property is true and removes it when the isEditing property is false. We add a new {{action}} helper to the \u003clabel\u003e so double-clicks will call editTodo on\nthis todo's controller. Finally, we wrap our todo in a Handlebars {{if}} helper so a text \u003cinput\u003e will display when we are editing and the todos title will display when we are not editing.\n\nInside js/controllers/todo_controller.js we'll implement the matching logic for this template behavior:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  Todos.TodoController = Ember.ObjectController.extend({\n  actions: {\n    editTodo: function() {\n      this.set('isEditing', true);\n    }\n  },\n\n  isEditing: false,\n\n// ... additional lines truncated for brevity ...\n\n\n\nAbove we defined an initial isEditing value of false for controllers of this type and said that when the editTodo action is called it should set the isEditing property of this controller to true.  This will automatically trigger the sections of template that use isEditing to update their rendered content.\n\nReload your web browser to ensure that no errors occur. You can now double-click a todo to edit it.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nHandlebars Conditionals Guide\nbind-attr API documentation\naction API documentation\nbind and bindAttr article by Peter Wagenet\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"5297d2addd3e2639c566e6b1fbfd1166","fields":[{"name":"title","value":"Using Fixtures","type":"string"},{"name":"url","value":"/getting-started/using-fixtures/","type":"enum"},{"name":"body","value":"Now we'll add fixture data. Fixtures are a way to put sample data into an application before connecting the application to long-term persistence.\n\nFirst, update js/application.js to indicate that your application's ApplicationAdapter\nis an extension of the DS.FixtureAdapter. Adapters are responsible for communicating with a source of data for your application. Typically this will be a web service API, but in this case we are using an adapter designed to load fixture data:\n\n  1\n2\n3\n\n  window.Todos = Ember.Application.create();\n\nTodos.ApplicationAdapter = DS.FixtureAdapter.extend();\n\n\n\nNext, update the file at js/models/todo.js to include the following fixture data:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  // ... additional lines truncated for brevity ...\nTodos.Todo.FIXTURES = [\n {\n   id: 1,\n   title: 'Learn Ember.js',\n   isCompleted: true\n },\n {\n   id: 2,\n   title: '...',\n   isCompleted: false\n },\n {\n   id: 3,\n   title: 'Profit!',\n   isCompleted: false\n }\n];\n\n\n\nReload your web browser to ensure that all files have been referenced correctly and no errors occur.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"08eae55024bc929382b3fde7ba8d0700","fields":[{"name":"title","value":"Replacing the Fixture Adapter with Another Adapter","type":"string"},{"name":"url","value":"/getting-started/using-other-adapters/","type":"enum"},{"name":"body","value":"Finally we'll replace our fixture data with real persistence so todos will remain between application loads by replacing the fixture adapter with a localstorage-aware adapter instead.\n\nChange js/application.js to:\n\n  1\n2\n3\n4\n5\n\n  window.Todos = Ember.Application.create();\n\nTodos.ApplicationAdapter = DS.LSAdapter.extend({\n  namespace: 'todos-emberjs'\n});\n\n\n\nThe local storage adapter, written by Ryan Florence, can be downloaded from its source. Add it to your project as js/libs/localstorage_adapter.js. You may place this file anywhere you like (even just putting all code into the same file), but this guide will assume you have created the file and named it as indicated.\n\nIn index.html include js/libs/localstorage_adapter.js as a dependency:\n\n  1\n2\n3\n4\n5\n\n  \u003c!--- ... additional lines truncated for brevity ... --\u003e\n\u003cscript src=\"js/libs/ember-data.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"js/libs/localstorage_adapter.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"js/application.js\"\u003e\u003c/script\u003e\n \u003c!--- ... additional lines truncated for brevity ... --\u003e\n\n\n\nReload your application. Todos you manage will now persist after the application has been closed.\nLive Preview\nEmber.js • TodoMVC\nAdditional Resources\n\nChanges in this step in diff format\nLocalStorage Adapter on GitHub\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6666cd76f96956469e7be39d750cc7d9","fields":[{"name":"title","value":"Ember.js Guides","type":"string"},{"name":"url","value":"/","type":"enum"},{"name":"body","value":"Welcome to the Ember.js guides! This documentation will take you from\ntotal beginner to Ember expert. It is designed to start from the basics,\nand slowly increase to more sophisticated concepts until you know\neverything there is to know about building awesome web applications.\n\nTo help you get started, we've also made a 30-minute screencast that\nwill guide you through building a full-featured Ember.js application:\n\n\n\nSource code for the app we build in the video is available at https://github.com/tildeio/bloggr-client\n\nMost of these guides are designed to help you start building apps right\naway. If you'd like to know more about the thinking behind Ember.js,\nyou'll find what you're looking for in the Understanding Ember.js\nsection.\n\nThese guides are written in Markdown and are available on\nGitHub, inside the source/guides\ndirectory.  If there is something missing, or you find a typo or\nmistake, please help us by filing an issue or submitting a pull\nrequest. Thanks!\n\nWe're excited for all of the great apps you're going to build with\nEmber.js. To get started, select a topic from the left. They are\npresented in the order that we think will be most useful to you as\nyou're learning Ember.js, but you can also jump to whatever seems\nmost interesting.\n\nGood luck!\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a3f09e944ddc4f339593bee97c850f80","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/models/connecting-to-a-streaming-api/","type":"enum"},{"name":"body","value":"","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"298653c42879aa9157122be8d7fcad36","fields":[{"name":"title","value":"Connecting to an HTTP Server","type":"string"},{"name":"url","value":"/models/connecting-to-an-http-server/","type":"enum"},{"name":"body","value":"If your Ember application needs to load JSON data from an HTTP\nserver, this guide will walk you through the process of configuring\nEmber Data to load records in whatever format your server returns.\n\nThe store uses an object called an adapter to know how to\ncommunicate over the network. By default, the store will use\nDS.RESTAdapter, an adapter that communicates with an HTTP server by\ntransmitting JSON via XHR.\n\nThis guide is divided into two sections. The first section covers what\nthe default behavior of the adapter is, including what URLs it will\nrequest records from and what format it expects the JSON to be in.\n\nThe second section covers how to override these default settings to\ncustomize things like which URLs data is requested from and how the JSON\ndata is structured.\nURL Conventions\nThe REST adapter uses the name of the model to determine what URL to\nsend JSON to.\n\nFor example, if you ask for an App.Photo record by ID:\n\n  1\n2\n3\n4\n5\n\n  App.PhotoRoute = Ember.Route.extend({\n  model: function(params) {\n    return this.store.find('photo', params.photo_id);\n  }\n});\n\n\n\nThe REST adapter will automatically send a GET request to /photos/1.\n\nThe actions you can take on a record map onto the following URLs in the\nREST adapter:\n\n\n  \n    ActionHTTP VerbURL\n  \n  \n    FindGET/photos/123\n    Find AllGET/photos\n    UpdatePUT/photos/123\n    CreatePOST/photos\n    DeleteDELETE/photos/123\n  \n\nJSON Conventions\nGiven the following models:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.Post = DS.Model.extend({\n  title:    DS.attr(),\n  comments: DS.hasMany('comment'),\n  user:     DS.belongsTo('user')\n});\n\nApp.Comment = DS.Model.extend({\n  body: DS.attr()\n});\n\n\n\nEmber Data expects that a GET request to /posts/1 would\nreturn the JSON in the following format:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  {\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Rails is omakase\",\n    \"comments\": [\"1\", \"2\"],\n    \"user\" : \"dhh\"\n  },\n\n  \"comments\": [{\n    \"id\": \"1\",\n    \"body\": \"Rails is unagi\"\n  }, {\n    \"id\": \"2\",\n    \"body\": \"Omakase O_o\"\n  }]\n}\n\n\n\nTo quickly prototype a model and see the expected JSON, try using the Ember Data Model Maker by Andy Crum.\nCustomizing the Adapter\nTo customize the REST adapter, define a subclass of DS.RESTAdapter and\nname it App.ApplicationAdapter. You can then override its properties\nand methods to customize how records are retrieved and saved.\nCustomizing a Specific Model\nIt's entirely possible that you need to define options for just one model instead of an application-wide customization. In that case, you can create an adapter named after the model you are specifying:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.PostAdapter = DS.RESTAdapter.extend({\n  namespace: 'api/v2',\n  host: 'https://api.example2.com'\n});\n\nApp.PhotoAdapter = DS.RESTAdapter.extend({\n  namespace: 'api/v1',\n  host: 'https://api.example.com'\n});\n\n\n\nThis allows you to easily connect to multiple API versions simultaneously or interact with different domains on a per model basis.\nCustomizing URLsURL Prefix\nIf your JSON API lives somewhere other than on the host root,\nyou can set a prefix that will be added to all requests.\n\nFor example, if you are using a versioned JSON API, a request for a\nparticular person might go to /api/v1/people/1.\n\nIn that case, set namespace property to api/v1.\n\n  1\n2\n3\n\n  App.ApplicationAdapter = DS.RESTAdapter.extend({\n  namespace: 'api/v1'\n});\n\n\n\nRequests for a person with ID 1  would now go to /api/v1/people/1.\nURL Host\nIf your JSON API runs on a different domain than the one serving your\nEmber app, you can change the host used to make HTTP requests.\n\nNote that in order for this to work, you will need to be using a browser\nthat supports CORS, and\nyour server will need to be configured to send the correct CORS headers.\n\nTo change the host that requests are sent to, set the host property:\n\n  1\n2\n3\n\n  App.ApplicationAdapter = DS.RESTAdapter.extend({\n  host: 'https://api.example.com'\n});\n\n\n\nRequests for a person with ID 1 would now target https://api.example.com/people/1.\nCustom HTTP Headers\nSome APIs require HTTP headers, e.g. to provide an API key. Arbitrary\nheaders can be set as key/value pairs on the RESTAdapter's headers\nproperty and Ember Data will send them along with each ajax request.\n\nFor Example\n\n  1\n2\n3\n4\n5\n6\n\n  App.ApplicationAdapter = DS.RESTAdapter.extend({\n  headers: {\n    'API_KEY': 'secret key',\n    'ANOTHER_HEADER': 'Some header value'\n  }\n});\n\n\n\nRequests for any resource will include the following HTTP headers.\n\n  1\n2\n\n  ANOTHER_HEADER: Some header value\nAPI_KEY: secret key\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9fca6476286a0f29bd93adca72f72c4d","fields":[{"name":"title","value":"Creating and Deleting Records","type":"string"},{"name":"url","value":"/models/creating-and-deleting-records/","type":"enum"},{"name":"body","value":"You can create records by calling the createRecord method on the store.\n\n  1\n2\n3\n4\n\n  store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\n\n\nThe store object is available in controllers and routes using this.store.\n\nAlthough createRecord is fairly straightforward, the only thing to watch out for\nis that you cannot assign a promise as a relationship, currently.\n\nFor example, if you want to set the author property of a post, this would not work\nif the user with id isn't already loaded into the store:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var store = this.store;\n\nstore.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum',\n  author: store.find('user', 1)\n});\n\n\n\nHowever, you can easily set the relationship after the promise has fulfilled:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var store = this.store;\n\nvar post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nstore.find('user', 1).then(function(user) {\n  post.set('author', user);\n});\n\n\nDeleting Records\nDeleting records is just as straightforward as creating records. Just call deleteRecord()\non any instance of DS.Model. This flags the record as isDeleted and thus removes\nit from all() queries on the store. The deletion can then be persisted using save().\nAlternatively, you can use the destroyRecord method to delete and persist at the same time.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  store.find('post', 1).then(function (post) {\n  post.deleteRecord();\n  post.get('isDeleted'); // =\u003e true\n  post.save(); // =\u003e DELETE to /posts/1\n});\n\n// OR\nstore.find('post', 2).then(function (post) {\n  post.destroyRecord(); // =\u003e DELETE to /posts/2\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c789ddb5644abcf443cde5398de5f989","fields":[{"name":"title","value":"Customizing Adapters","type":"string"},{"name":"url","value":"/models/customizing-adapters/","type":"enum"},{"name":"body","value":"In Ember Data, the logic for communicating with a backend data store\nlives in the Adapter. Ember Data's Adapter has some built-in\nassumptions of how a REST API should look. If\nyour backend conventions differ from these assumptions Ember Data\nmakes it easy to change its functionality by swapping out or extending\nthe default Adapter.\n\nSome reasons for customizing an Adapter include using\nunderscores_case in your urls, using a medium other than REST to\ncommunicate with your backend API or even using a\nlocal backend.\n\nExtending Adapters is a natural process in Ember Data. Ember takes the\nposition that you should extend an adapter to add different\nfunctionality instead of adding a flag. This results in code that is\nmore testable, easier to understand and reduces bloat for people who\nmay want to subclass your adapter.\n\nIf your backend has some consistent rules you can define an\nApplicationAdapter. The ApplicationAdapter will get priority over\nthe default Adapter, however it will still be superseded by model\nspecific Adapters.\n\n  1\n2\n3\n\n  App.ApplicationAdapter = DS.RESTAdapter.extend({\n  // Application specific overrides go here\n});\n\n\n\nIf you have one model that has exceptional rules for communicating\nwith its backend than the others you can create a Model specific\nAdapter by naming an adapter \"ModelName\" + \"Adapter\".\n\n  1\n2\n3\n\n  App.PostAdapter = DS.RESTAdapter.extend({\n  namespace: 'api/v1'\n});\n\n\n\nBy default Ember Data comes with several builtin adapters. Feel free\nto use these adapters as a starting point for creating your own custom\nadapter.\n\n\nDS.Adapter is the basic adapter\nwith no functionality. It is generally a good starting point if you\nwant to create an adapter that is radically different from the other\nEmber adapters.\nDS.FixtureAdapter is an\nadapter that loads records from memory. Its primarily used for\ndevelopment and testing.\nDS.RESTAdapter is the most\ncommonly extended adapter. The RESTAdapter allows your store to\ncommunicate with an HTTP server by transmitting JSON via XHR. Most\nEmber.js apps that consume a JSON API should use the REST adapter.\nDS.ActiveModelAdapter\nis a specialized version of the RESTAdapter that is set up to work\nout of the box with Rails-style REST APIs.\n\nCustomizing the RESTAdapter\nThe DS.RESTAdapter is the\nmost commonly extended adapter that ships with Ember Data. It has a\nhandful of hooks that are commonly used to extend it to work with\nnon-standard backends.\nEndpoint Path Customization\nThe namespace property can be used to prefix requests with a\nspecific url namespace.\n\n  1\n2\n3\n\n  App.ApplicationAdapter = DS.RESTAdapter.extend({\n  namespace: 'api/1'\n});\n\n\n\nRequests for App.Person would now target /api/1/people/1.\nHost Customization\nBy default the adapter will target the current domain. If you would\nlike to specify a new domain you can do so by setting the host\nproperty on the adapter.\n\n  1\n2\n3\n\n  App.ApplicationAdapter = DS.RESTAdapter.extend({\n  host: 'https://api.example.com'\n});\n\n\n\nRequests for App.Person would now target https://api.example.com/people/1.\nPath Customization\nBy default the RESTAdapter will attempt to pluralize and camelCase\nthe model name to generate the path name. If this convention does not\nconform to your backend you can override the pathForType method.\n\nFor example, if you did not want to pluralize model names and needed\nunderscore_case instead of camelCase you could override the\npathForType method like this:\n\n  1\n2\n3\n4\n5\n\n  App.ApplicationAdapter = DS.RESTAdapter.extend({\n  pathForType: function(type) {\n    return Ember.String.underscore(type);\n  }\n});\n\n\n\nRequests for App.Person would now target /person/1.\nRequests for App.UserProfile would now target /user_profile/1.\nAuthoring Adapters\nThe defaultSerializer property can be used to specify the serializer\nthat will be used by this adapter. This is only used when a model\nspecific serializer or ApplicationSerializer are not defined.\n\nIn an application, it is often easier to specify an\nApplicationSerializer. However, if you are the author of a community\nadapter it is important to remember to set this property to ensure\nEmber does the right thing in the case a user of your adapter\ndoes not specify an ApplicationSerializer.\n\n  1\n2\n3\n\n  MyCustomAdapterAdapter = DS.RESTAdapter.extend({\n  defaultSerializer: '-default'\n});\n\n\nCommunity Adapters\nIf none of the builtin Ember Data Adapters work for your backend,\nbe sure to check out some of the community maintained Ember Data\nAdapters. Some good places to look for Ember Data Adapters include:\n\n\nGitHub\nBower\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"03e86bc5333f6f64b9e95b540f952f9d","fields":[{"name":"title","value":"Defining Models","type":"string"},{"name":"url","value":"/models/defining-models/","type":"enum"},{"name":"body","value":"A model is a class that defines the properties and behavior of the\ndata that you present to the user. Anything that the user expects to see\nif they leave your app and come back later (or if they refresh the page)\nshould be represented by a model.\n\nMake sure to include ember-data.js after ember.js\n\n  1\n2\n\n  \u003cscript type=\"text/javascript\" src=\"ember.js\"\u003e\u003c/script\u003e\n\u003cscript type=\"text/javascript\" src=\"ember-data.js\"\u003e\u003c/script\u003e\n\n\n\nFor every model in your application, create a subclass of DS.Model:\n\n  1\n\n  App.Person = DS.Model.extend();\n\n\n\nAfter you have defined a model class, you can start finding and creating\nrecords of that type. When interacting with the store, you will need to\nspecify a record's type using the model name. For example, the store's\nfind() method expects a string as the first argument to tell it what\ntype of record to find:\n\n  1\n\n  store.find('person', 1);\n\n\n\nThe table below shows how model names map to model classes.\n\n\n  \n  \n    Model Name\n    Model Class\n  \n  \n  \n    photo\n    App.Photo\n  \n  \n    adminUserProfile\n    App.AdminUserProfile\n  \n\nDefining Attributes\nYou can specify which attributes a model has by using DS.attr.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var attr = DS.attr;\n\nApp.Person = DS.Model.extend({\n  firstName: attr(),\n  lastName: attr(),\n  birthday: attr()\n});\n\n\n\nAttributes are used when turning the JSON payload returned from your\nserver into a record, and when serializing a record to save back to the\nserver after it has been modified.\n\nYou can use attributes just like any other property, including as part of a\ncomputed property. Frequently, you will want to define computed\nproperties that combine or transform primitive attributes.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var attr = DS.attr;\n\nApp.Person = DS.Model.extend({\n  firstName: attr(),\n  lastName: attr(),\n\n  fullName: function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  }.property('firstName', 'lastName')\n});\n\n\n\nFor more about adding computed properties to your classes, see Computed\nProperties.\n\nIf you don't specify the type of the attribute, it will be whatever was\nprovided by the server. You can make sure that an attribute is always\ncoerced into a particular type by passing a type to attr:\n\n  1\n2\n3\n\n  App.Person = DS.Model.extend({\n  birthday: DS.attr('date')\n});\n\n\n\nThe default adapter supports attribute types of string,\nnumber, boolean, and date. Custom adapters may offer additional\nattribute types, and new types can be registered as transforms. See the\ndocumentation section on the REST Adapter.\n\nPlease note: Ember Data serializes and deserializes dates according to\n                 ISO 8601. For example: 2014-05-27T12:54:01\nOptions\nDS.attr takes an optional hash as a second parameter:\n\n\ndefaultValue: Pass a string or a function to be called to set the\n              attribute to a default value if none is supplied.\n\n\nExample\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n    var attr = DS.attr;\n\n  App.User = DS.Model.extend({\n      username: attr('string'),\n      email: attr('string'),\n      verified: attr('boolean', {defaultValue: false}),\n      createdAt: attr('string', {\n          defaultValue: function() { return new Date(); }\n      })\n  });\n\n\nDefining Relationships\nEmber Data includes several built-in relationship types to help you\ndefine how your models relate to each other.\nOne-to-One\nTo declare a one-to-one relationship between two models, use\nDS.belongsTo:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.User = DS.Model.extend({\n  profile: DS.belongsTo('profile')\n});\n\nApp.Profile = DS.Model.extend({\n  user: DS.belongsTo('user')\n});\n\n\nOne-to-Many\nTo declare a one-to-many relationship between two models, use\nDS.belongsTo in combination with DS.hasMany, like this:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.Post = DS.Model.extend({\n  comments: DS.hasMany('comment')\n});\n\nApp.Comment = DS.Model.extend({\n  post: DS.belongsTo('post')\n});\n\n\nMany-to-Many\nTo declare a many-to-many relationship between two models, use\nDS.hasMany:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.Post = DS.Model.extend({\n  tags: DS.hasMany('tag')\n});\n\nApp.Tag = DS.Model.extend({\n  posts: DS.hasMany('post')\n});\n\n\nExplicit Inverses\nEmber Data will do its best to discover which relationships map to one\nanother. In the one-to-many code above, for example, Ember Data can figure out that\nchanging the comments relationship should update the post\nrelationship on the inverse because post is the only relationship to\nthat model.\n\nHowever, sometimes you may have multiple belongsTo/hasManys for the\nsame type. You can specify which property on the related model is the\ninverse using DS.hasMany's inverse option:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  var belongsTo = DS.belongsTo,\n    hasMany = DS.hasMany;\n\nApp.Comment = DS.Model.extend({\n  onePost: belongsTo('post'),\n  twoPost: belongsTo('post'),\n  redPost: belongsTo('post'),\n  bluePost: belongsTo('post')\n});\n\n\nApp.Post = DS.Model.extend({\n  comments: hasMany('comment', {\n    inverse: 'redPost'\n  })\n});\n\n\n\nYou can also specify an inverse on a belongsTo, which works how you'd expect.\nReflexive relation\nWhen you want to define a reflexive relation, you must either explicitly define\nthe other side, and set the explicit inverse accordingly, and if you don't need the\nother side, set the inverse to null.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var belongsTo = DS.belongsTo,\n    hasMany = DS.hasMany;\n\nApp.Folder = DS.Model.extend({\n  children: hasMany('folder', {inverse: 'parent'}),\n  parent: belongsTo('folder', {inverse: 'children'})\n});\n\n\n\nor\n\n  1\n2\n3\n4\n5\n\n  var belongsTo = DS.belongsTo,\n\nApp.Folder = DS.Model.extend({\n  parent: belongsTo('folder', {inverse: null})\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"5a4d46e7e97f41a2c68379dc2d30560d","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/models/filtering-records/","type":"enum"},{"name":"body","value":"","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"54352571d5fd6e786972f119be9dcf80","fields":[{"name":"title","value":"Finding Records","type":"string"},{"name":"url","value":"/models/finding-records/","type":"enum"},{"name":"body","value":"The Ember Data store provides a simple interface for finding records of a single\ntype through the store object's find method. Internally, the store\nuses find, findAll, and findQuery based on the supplied arguments.\n\nThe first argument to store.find() is always the record type. The optional second\nargument determines if a request is made for all records, a single record, or a query.\nFinding All Records of a Type\n  1\n\n  var posts = this.store.find('post'); // =\u003e GET /posts\n\n\n\nTo get a list of records already loaded into the store, without making\nanother network request, use all instead.\n\n  1\n\n  var posts = this.store.all('post'); // =\u003e no network request\n\n\n\nfind returns a DS.PromiseArray that fulfills to a DS.RecordArray and all\ndirectly returns a DS.RecordArray.\n\nIt's important to note that DS.RecordArray is not a JavaScript array.\nIt is an object that implements Ember.Enumerable. This is important\nbecause, for example, if you want to retrieve records by index, the [] notation\nwill not work--you'll have to use objectAt(index) instead.\nFinding a Single Record\nIf you provide a number or string as the second argument to store.find(),\nEmber Data will assume that you are passing in an ID and attempt to retrieve a record of the type passed in as the first argument with that ID. This will\nreturn a promise that fulfills with the requested record:\n\n  1\n\n  var aSinglePost = this.store.find('post', 1); // =\u003e GET /posts/1\n\n\nQuerying For Records\nIf you provide a plain object as the second argument to find, Ember Data will\nmake a GET request with the object serialized as query params. This method returns\nDS.PromiseArray in the same way as find with no second argument.\n\nFor example, we could search for all person models who have the name of\nPeter:\n\n  1\n\n  var peters = this.store.find('person', { name: \"Peter\" }); // =\u003e GET to /persons?name=Peter\n\n\nIntegrating with the Route's Model Hook\nAs discussed in Specifying a Route's Model, routes are\nresponsible for telling their template which model to render.\n\nEmber.Route's model hook supports asynchronous values\nout-of-the-box. If you return a promise from the model hook, the\nrouter will wait until the promise has fulfilled to render the\ntemplate.\n\nThis makes it easy to write apps with asynchronous data using Ember\nData. Just return the requested record from the model hook, and let\nEmber deal with figuring out whether a network request is needed or not.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  App.Router.map(function() {\n  this.resource('posts');\n  this.resource('post', { path: ':post_id' });\n});\n\nApp.PostsRoute = Ember.Route.extend({\n  model: function() {\n    return this.store.find('post');\n  }\n});\n\nApp.PostRoute = Ember.Route.extend({\n  model: function(params) {\n    return this.store.find('post', params.post_id);\n  }\n})\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6bd56e65140b54329f607d71ebd61f85","fields":[{"name":"title","value":"Frequently Asked Questions","type":"string"},{"name":"url","value":"/models/frequently-asked-questions/","type":"enum"},{"name":"body","value":"Should I use a query or a filter to search records?\nIt depends on how many records you want to search and whether they have\nbeen loaded into the store.\n\nQueries are useful for doing searches of hundreds, thousands, or even\nmillions of records. You just hand the search options to your server,\nand it is responsible for handing you back the list of records that\nmatch. Because the response from the server includes the ID of all of\nthe records that matched, it doesn't matter if the store hadn't loaded\nthem previously; it sees that they are not in the cache and can request\nthe records by ID if necessary.\n\nThe downside of queries is that they do not live update, they are\nslower, and they require that your server support the kind of queries\nthat you wish to perform.\n\nBecause the server decides which records match the query, not the store,\nqueries do not live update. If you want to update them, you must\nmanually call reload() and wait for the server to respond. If you\ncreate a new record on the client, it will not show up in the results\nuntil you both save the new record to the server and reload the query\nresults.\n\nBecause the store must confer with your server to determine the results\nof a query, it necessitates a network request. This can feel slow to\nusers, especially if they are on a slow connection or your server is\nslow to respond. The typical speed of JavaScript web applications can\nheighten the perceived slowness when the server must be consulted.\n\nLastly, performing queries requires collaboration between the store and\nyour server. By default, Ember Data will send the search options that\nyou pass as the body of an HTTP request to your server. If your server\ndoes not support requests in this format, you will need to either change\nyour server to do so, or customize how queries are sent by creating a\ncustom adapter.\n\nFilters, on the other hand, perform a live search of all of the records\nin the store's cache. As soon as a new record is loaded into the store,\nthe filter will check to see if the record matches, and if so, add it to\nthe array of search results. If that array is displayed in a template,\nit will update automatically.\n\nFilters also take into account newly created records that have not been\nsaved, and records that have been modified but not yet saved. If you\nwant records to show up in search results as soon as they are created or\nmodified on the client, you should use a filter.\n\nKeep in mind that records will not show up in a filter if the store\ndoesn't know about them. You can ensure that a record is in the store by\nusing the store's push() method.\n\nThere is also a limit to how many records you can reasonably keep in\nmemory and search before you start hitting performance issues.\n\nFinally, keep in mind that you can combine queries and filters to take\nadvantage of their respective strengths and weaknesses. Remember that\nrecords returned by a query to the server are cached in the store. You\ncan use this fact to perform a filter, passing it a query that starts\nmatching records into the store, and a filter function that matches the\nsame records.\n\nThis will offload searching all of the possible records to the server,\nwhile still creating a live updating list that includes records created\nand modified on the client.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  App.PostsFavoritedRoute = Ember.Route.extend({\n  model: function() {\n    var store = this.store;\n\n    // Create a filter for all favorited posts that will be displayed in\n    // the template. Any favorited posts that are already in the store\n    // will be displayed immediately;\n    // Kick off a query to the server for all posts that\n    // the user has favorited. As results from the query are\n    // returned from the server, they will also begin to appear.\n    return store.filter('post', { favorited: true }, function(post) {\n      return post.get('isFavorited');\n    });\n  }\n});\n\n\nHow do I inform Ember Data about new records created on the backend?\nWhen you request a record using Ember Data's store.find method, Ember\nwill automatically load the data into the store. This allows Ember to\navoid the latency of making a round trip to the backend next time\nthat record is requested. Additionally, loading a record into the\nstore will update any RecordArrays (e.g. the result of\nstore.filter or store.all) that should include that record. This\nmeans any data bindings or computed properties that depend on the\nRecordArray will automatically be synced to include the new or\nupdated record values.\n\nSome applications may want to add or update records in the store\nwithout requesting the record via store.find. To accomplish this you\ncan use the DS.Store's push or pushPayload\nmethods. This is useful for web applications that have a channel\n(such as SSE or\nWeb Sockets) to\nnotify it of new or updated records on the backend.\n\npush\nis the simplest way to load or update records in Ember Data's store.\nWhen using push it is important to\nnormalize\nthe JSON object before pushing it into the store.\n\npush only accepts one record at a time. If you would like to load an\narray of records to the store you can call\npushMany.\n\n  1\n2\n3\n4\n\n  socket.on('message', function (message) {\n  var modelName = message.model;\n  store.push(modelName, store.normalize(modelName, message.data));\n});\n\n\n\nAs of v1.0.0-beta.14 the push method accepts partial attributes for\nupdating existing records. The update method is therefore deprecated.\nUpdating partial attributes is useful if your web application only\nreceives notifications of the changed attributes on a model.\n\npushPayload\nis a convenience wrapper for store#push that will deserialize\npayloads if the model's Serializer implements a pushPayload\nmethod. It is important to note this method will not work with the\nJSONSerializer because it does not implement a pushPayload\nmethod.\n\n  1\n2\n3\n\n  socket.on('message', function (message) {\n  store.pushPayload(message.model, message.data);\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"aaa673b0a07a7fad8549b3be79862344","fields":[{"name":"title","value":"Handling Metadata","type":"string"},{"name":"url","value":"/models/handling-metadata/","type":"enum"},{"name":"body","value":"Along with the records returned from your store, you'll likely need to handle some kind of metadata. Metadata is data that goes along with a specific model or type instead of a record.\n\nPagination is a common example of using metadata. Imagine a blog with far more posts than you can display at once. You might query it like so:\n\n  1\n2\n3\n4\n\n  var result = this.store.find(\"post\", {\n  limit: 10,\n  offset: 0\n});\n\n\n\nTo get different pages of data, you'd simply change your offset in increments of 10. So far, so good. But how do you know how many pages of data you have? Your server would need to return the total number of records as a piece of metadata.\n\nBy default, Ember Data's JSON deserializer looks for a meta key:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  {\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Progressive Enhancement is Dead\",\n    \"comments\": [\"1\", \"2\"],\n    \"links\": {\n      \"user\": \"/people/tomdale\"\n    },\n    // ...\n  },\n\n  \"meta\": {\n    \"total\": 100\n  }\n}\n\n\n\nThe metadata for a specific type is then set to the contents of meta. You can access it either with store.metadataFor, which is updated any time any query is made against the same type:\n\n  1\n\n  var meta = this.store.metadataFor(\"post\");\n\n\n\nOr you can access the metadata just for this query:\n\n  1\n\n  var meta = result.get(\"content.meta\");\n\n\n\nNow, meta.total can be used to calculate how many pages of posts you'll have.\n\nYou can also customize metadata extraction by overriding the extractMeta method. For example, if instead of a meta object, your server simply returned:\n\n  1\n2\n3\n4\n5\n6\n\n  {\n  \"post\": [\n    // ...\n  ],\n  \"total\": 100\n}\n\n\n\nYou could extract it like so:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.ApplicationSerializer = DS.RESTSerializer.extend({\n  extractMeta: function(store, type, payload) {\n    if (payload \u0026\u0026 payload.total) {\n      store.setMetadataFor(type, { total: payload.total });  // sets the metadata for \"post\"\n      delete payload.total;  // keeps ember data from trying to parse \"total\" as a record\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f6824ed2e6c9f37fc0a6d7f987afee17","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/models/","type":"enum"},{"name":"body","value":"Models\nIn Ember, every route has an associated model. This model is set by\nimplementing a route's model hook, by passing the model as an argument\nto {{link-to}}, or by calling a route's transitionTo() method.\n\nSee Specifying a Route's\nModel for more information\non setting a route's model.\n\nFor simple applications, you can get by using jQuery to load JSON data\nfrom a server, then use those JSON objects as models.\n\nHowever, using a model library that manages finding models, making\nchanges, and saving them back to the server can dramatically simplify\nyour code while improving the robustness and performance of your\napplication.\n\nMany Ember apps use Ember Data to handle this.\nEmber Data is a library that integrates tightly with Ember.js to make it\neasy to retrieve records from a server, cache them for performance,\nsave updates back to the server, and create new records on the client.\n\nWithout any configuration, Ember Data can load and save records and\ntheir relationships served via a RESTful JSON API, provided it follows\ncertain conventions.\n\nIf you need to integrate your Ember.js app with existing JSON APIs that\ndo not follow strong conventions, Ember Data is designed to be easily\nconfigurable to work with whatever data your server returns.\n\nEmber Data is also designed to work with streaming APIs like\nsocket.io, Firebase, or WebSockets. You can open a socket to your server\nand push changes to records into the store whenever they occur.\n\nCurrently, Ember Data ships as a separate library from Ember.js.  Until\nEmber Data is included as part of the standard distribution, you can get\na copy of the latest passing build from\nemberjs.com/builds:\n\n\nDevelopment\nMinified\n\nCore Concepts\nLearning to use Ember Data is easiest once you understand some of the\nconcepts that underpin its design.\nStore\nThe store is the central repository of records in your application.\nYou can think of the store as a cache of all of the records available in\nyour app. Both your application's controllers and routes have access to this\nshared store; when they need to display or modify a record, they will\nfirst ask the store for it.\n\nThis instance of DS.Store is created for you automatically and is shared\namong all of the objects in your application.\n\nYou will use the store to retrieve records, as well to create new ones.\nFor example, we might want to find an App.Person model with the ID of\n1 from our route's model hook:\n\n  1\n2\n3\n4\n5\n\n  App.IndexRoute = Ember.Route.extend({\n  model: function() {\n    return this.store.find('person', 1);\n  }\n});\n\n\nModels\nA model is a class that defines the properties and behavior of the\ndata that you present to the user. Anything that the user expects to see\nif they leave your app and come back later (or if they refresh the page)\nshould be represented by a model.\n\nFor example, if you were writing a web application for placing orders at\na restaurant, you might have models like Order, LineItem, and\nMenuItem.\n\nFetching orders becomes very easy:\n\n  1\n\n  this.store.find('order');\n\n\n\nModels define the type of data that will be provided by your server. For\nexample, a Person model might have a firstName attribute that is a\nstring, and a birthday attribute that is a date:\n\n  1\n2\n3\n4\n\n  App.Person = DS.Model.extend({\n  firstName: DS.attr('string'),\n  birthday:  DS.attr('date')\n});\n\n\n\nA model also describes its relationships with other objects. For\nexample, an Order may have many LineItems, and a LineItem may\nbelong to a particular Order.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.Order = DS.Model.extend({\n  lineItems: DS.hasMany('lineItem')\n});\n\nApp.LineItem = DS.Model.extend({\n  order: DS.belongsTo('order')\n});\n\n\n\nModels don't have any data themselves; they just define the properties and\nbehavior of specific instances, which are called records.\nRecords\nA record is an instance of a model that contains data loaded from a\nserver. Your application can also create new records and save them back\nto the server.\n\nA record is uniquely identified by its model type and id.\n\nFor example, if you were writing a contact management app, you might\nhave a model called Person. An individual record in your app might\nhave a type of Person and an ID of 1 or steve-buscemi.\n\n  1\n\n  this.store.find('person', 1); // =\u003e { id: 1, name: 'steve-buscemi' }\n\n\n\nIDs are usually assigned by the server when you save them for the first\ntime, but you can also generate IDs client-side.\nAdapter\nAn adapter is an object that knows about your particular server\nbackend and is responsible for translating requests for and changes to\nrecords into the appropriate calls to your server.\n\nFor example, if your application asks for a person record with an ID\nof 1, how should Ember Data load it? Is it over HTTP or a WebSocket?\nIf it's HTTP, is the URL /person/1 or /resources/people/1?\n\nThe adapter is responsible for answering all of these questions.\nWhenever your app asks the store for a record that it doesn't have\ncached, it will ask the adapter for it. If you change a record and save\nit, the store will hand the record to the adapter to send the\nappropriate data to your server and confirm that the save was\nsuccessful.\nSerializer\nA serializer is responsible for turning a raw JSON payload returned\nfrom your server into a record object.\n\nJSON APIs may represent attributes and relationships in many different\nways. For example, some attribute names may be camelCased and others\nmay be under_scored. Representing relationships is even more diverse:\nthey may be encoded as an array of IDs, an array of embedded objects, or\nas foreign keys.\n\nWhen the adapter gets a payload back for a particular record, it will\ngive that payload to the serializer to normalize into the form that\nEmber Data is expecting.\n\nWhile most people will use a serializer for normalizing JSON, because\nEmber Data treats these payloads as opaque objects, there's no reason\nthey couldn't be binary data stored in a Blob or\nArrayBuffer.\nAutomatic Caching\nThe store will automatically cache records for you. If a record had already\nbeen loaded, asking for it a second time will always return the same\nobject instance. This minimizes the number of round-trips to the\nserver, and allows your application to render its UI to the user as fast as\npossible.\n\nFor example, the first time your application asks the store for a\nperson record with an ID of 1, it will fetch that information from\nyour server.\n\nHowever, the next time your app asks for a person with ID 1, the\nstore will notice that it had already retrieved and cached that\ninformation from the server. Instead of sending another request for the\nsame information, it will give your application the same record it had\nprovided it the first time.  This feature—always returning the same\nrecord object, no matter how many times you look it up—is sometimes\ncalled an identity map.\n\nUsing an identity map is important because it ensures that changes you\nmake in one part of your UI are propagated to other parts of the UI. It\nalso means that you don't have to manually keep records in sync—you can\nask for a record by ID and not have to worry about whether other parts\nof your application have already asked for and loaded it.\nArchitecture Overview\nThe first time your application asks the store for a record, the store\nsees that it doesn't have a local copy and requests it from your\nadapter. Your adapter will go and retrieve the record from your\npersistence layer; typically, this will be a JSON representation of the\nrecord served from an HTTP server.\n\n\n\nAs illustrated in the diagram above, the adapter cannot always return the \nrequested record immediately. In this case, the adapter must make an \nasynchronous request to the server, and only when that request finishes \nloading can the record be created with its backing data.\n\nBecause of this asynchronicity, the store immediately returns a\npromise from the find() method. Similarly, any requests that the\nstore makes to the adapter also return promises.\n\nOnce the request to the server returns with a JSON payload for the\nrequested record, the adapter resolves the promise it returned to the\nstore with the JSON.\n\nThe store then takes that JSON, initializes the record with the\nJSON data, and resolves the promise returned to your application\nwith the newly-loaded record.\n\n\n\nLet's look at what happens if you request a record that the store\nalready has in its cache. \n\n\n\nIn this case, because the store already knew about the record, it\nreturns a promise that it resolves with the record immediately. It does\nnot need to ask the adapter (and, therefore, the server) for a copy\nsince it already has it saved locally.\n\n\n\nThese are the core concepts you should understand to get the most out of\nEmber Data. The following sections go into more depth about each of\nthese concepts, and how to use them together.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f5cbaf46432fb32d6be26a903d80a41c","fields":[{"name":"title","value":"Persisting Records","type":"string"},{"name":"url","value":"/models/persisting-records/","type":"enum"},{"name":"body","value":"Records in Ember Data are persisted on a per-instance basis.\nCall save() on any instance of DS.Model and it will make a network request.\n\nHere are a few examples:\n\n  1\n2\n3\n4\n5\n6\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\npost.save(); // =\u003e POST to '/posts'\n\n\n\n  1\n2\n3\n4\n5\n6\n7\n\n  store.find('post', 1).then(function (post) {\n  post.get('title'); // =\u003e \"Rails is Omakase\"\n\n  post.set('title', 'A new post');\n\n  post.save(); // =\u003e PUT to '/posts/1'\n});\n\n\nPromises\nsave() returns a promise, so it is extremely easy to handle success and failure scenarios.\n Here's a common pattern:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nvar self = this;\n\nfunction transitionToPost(post) {\n  self.transitionToRoute('posts.show', post);\n}\n\nfunction failure(reason) {\n  // handle the error\n}\n\npost.save().then(transitionToPost).catch(failure);\n\n// =\u003e POST to '/posts'\n// =\u003e transitioning to posts.show route\n\n\n\nPromises even make it easy to work with failed network requests:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nvar self = this;\n\nvar onSuccess = function(post) {\n  self.transitionToRoute('posts.show', post);\n};\n\nvar onFail = function(post) {\n  // deal with the failure here\n};\n\npost.save().then(onSuccess, onFail);\n\n// =\u003e POST to '/posts'\n// =\u003e transitioning to posts.show route\n\n\n\nYou can read more about promises here, but here is another\nexample showing how to retry persisting:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  function retry(callback, nTimes) {\n  // if the promise fails\n  return callback().catch(function(reason) {\n    // if we haven't hit the retry limit\n    if (nTimes-- \u003e 0) {\n      // retry again with the result of calling the retry callback\n      // and the new retry limit\n      return retry(callback, nTimes);\n    }\n\n    // otherwise, if we hit the retry limit, rethrow the error\n    throw reason;\n  });\n}\n\n// try to save the post up to 5 times\nretry(function() {\n  return post.save();\n}, 5);\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0638f122b19f3ca7e20eca12d526a2e6","fields":[{"name":"title","value":"Pushing Records into the Store","type":"string"},{"name":"url","value":"/models/pushing-records-into-the-store/","type":"enum"},{"name":"body","value":"One way to think about the store is as a cache of all of the records\nthat have been loaded by your application. If a route or a controller in\nyour app asks for a record, the store can return it immediately if it is\nin the cache. Otherwise, the store must ask the adapter to load it,\nwhich usually means a trip over the network to retrieve it from the\nserver.\n\nInstead of waiting for the app to request a record, however, you can\npush records into the store's cache ahead of time.\n\nThis is useful if you have a good sense of what records the user\nwill need next. When they click on a link, instead of waiting for a\nnetwork request to finish, Ember.js can render the new template\nimmediately. It feels instantaneous.\n\nAnother use case for pushing in records is if your application has a\nstreaming connection to a backend. If a record is created or modified,\nyou want to update the UI immediately.\nPushing Records\nTo push a record into the store, call the store's push() method.\n\nFor example, imagine we want to preload some data into the store when\nthe application boots for the first time.\n\nWe can use the ApplicationRoute to do so. The ApplicationRoute is\nthe top-most route in the route hierarchy, and its model hook gets\ncalled once when the app starts up.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n  var attr = DS.attr;\n\nApp.Album = DS.Model.extend({\n  title: attr(),\n  artist: attr(),\n  songCount: attr()\n});\n\nApp.ApplicationRoute = Ember.Route.extend({\n  model: function() {\n    this.store.push('album', {\n      id: 1,\n      title: \"Fewer Moving Parts\",\n      artist: \"David Bazan\",\n      songCount: 10\n    });\n\n    this.store.push('album', {\n      id: 2,\n      title: \"Calgary b/w I Can't Make You Love Me/Nick Of Time\",\n      artist: \"Bon Iver\",\n      songCount: 2\n    });\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0c7ecbe81a7f70c6ee15730b1494ddea","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/models/the-basic-adapter/","type":"enum"},{"name":"body","value":"The most basic way to use Ember Data is to make your own Ajax requests\nusing jQuery's Ajax helpers and process the data yourself before loading\nit into your records.\n\nThe basic adapter allows you to implement hooks to talk to your backend,\nthen load the data returned into the store.\n\nYou provide the hooks to Ember Data by implementing a sync object on\neach model:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.Person = DS.Model.extend({\n  //...model definition...\n});\n\nApp.Person.sync = {\n  find: function(id, process) {\n    // ...\n  }\n};\n\n\nFinding Records\nWhen you use the find method on a model in your application, Ember\nData will invoke the find hook on your model's sync object.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.Person.find(1);\n\nApp.Person.sync = {\n  find: function(id, process) {\n    jQuery.getJSON(\"/people/\" + id).then(function(json) {\n      process(json).camelizeKeys().load();\n    });\n  }\n}\n\n\n\nThis will load the JSON representation returned from the server for the\nPerson with the given id.\n\nThe process function passed into find wraps a JavaScript object and\nprovides conveniences for normalizing it. Once you are done working with\nthe JSON, you call load to load the normalized data into the record.\n\nEmber Data expects that the JSON you load in will have keys with the\nsame name as the attributes and relationships that you have defined in\nthe model. For example, if you have a Person model:\n\n  1\n2\n3\n4\n5\n\n  App.Person = DS.Model.extend({\n  firstName: DS.attr('string'),\n  lastName: DS.attr('string'),\n  age: DS.attr('number')\n});\n\n\n\nYou need to load an object that looks like this:\n\n  1\n2\n3\n4\n5\n\n  {\n  firstName: \"Peter\",\n  lastName: \"Wagenet\",\n  age: 25\n}\n\n\n\nBecause underscored keys are so common, the process wrapper provides\nthe camelizeKeys method to convert all keys from underscored keys\nto camelized keys.\n\nFor other kinds of manipulations, the process wrapper provides a\nmunge method you can use to change the JSON object:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  App.Person.sync = {\n  find: function(id, process) {\n    jQuery.getJSON(\"/people/\" + id).then(function(json) {\n      process(json)\n        .munge(function(json) {\n          json.firstName = json.FIRST_NAME;\n          json.lastName = json[\"name,last\"];\n        })\n        .load();\n    });\n  }\n}\n\n\n\nYou can modify the JSON before passing it to process. The munge\nAPI is provided to make it easier to compose with other methods on\nthe process wrapper.\nQuerying for Multiple Records\nWhen you use the query method on a model, Ember Data will invoke\nthe query hook on your model's sync object.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.Person.query({ page: 1 });\n\nApp.Person.sync = {\n  query: function(query, process) {\n    jQuery.getJSON(\"/people\", query).then(function(json) {\n      process(json).camelizeKeys().load();\n    });\n  }\n}\n\n\n\nIn the case of a query, the process wrapper will wrap an Array of\nreturned objects.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f09c2a955952b6e05a52621bc49be451","fields":[{"name":"title","value":"Using Fixtures","type":"string"},{"name":"url","value":"/models/the-fixture-adapter/","type":"enum"},{"name":"body","value":"When developing client-side applications, your server may not have an API ready\nto develop against. The FixtureAdapter allows you to begin developing Ember.js\napps now, and switch to another adapter when your API is ready to consume\nwithout any changes to your application code.\nGetting Started\nUsing the fixture adapter entails three very simple setup steps:\n\n\nCreate a new store using the fixture adapter and attach it to your app.\nDefine your model using DS.Model.extend.\nAttach fixtures (also known as sample data) to the model's class.\n\nCreating a Fixture Adapter\nSimply attach it as the ApplicationAdapter property on your instance\nof Ember.Application:\n\n  1\n2\n\n  var App = Ember.Application.create();\nApp.ApplicationAdapter = DS.FixtureAdapter;\n\n\nDefine Your Model\nYou should refer to Defining a Model for a more in-depth guide on using\nEmber Data Models, but for the purposes of demonstration we'll use an example\nmodeling people who document Ember.js.\n\n  1\n2\n3\n4\n\n  App.Documenter = DS.Model.extend({\n  firstName: DS.attr( 'string' ),\n  lastName: DS.attr( 'string' )\n});\n\n\nAttach Fixtures to the Model Class\nIn order to attach fixtures to your model, you have to use reopenClass method and define\nfixtures:\n\n  1\n2\n3\n4\n5\n6\n\n  App.Documenter.reopenClass({\n  FIXTURES: [\n    { id: 1, firstName: 'Trek', lastName: 'Glowacki' },\n    { id: 2, firstName: 'Tom' , lastName: 'Dale'     }\n  ]\n});\n\n\n\nThat's it! You can now use all of methods for Finding Records in your\napplication. For example:\n\n  1\n2\n3\n4\n5\n6\n\n  App.DocumenterRoute = Ember.Route.extend({\n  model: function() {\n    return this.store.find('documenter', 1); // returns a promise that will resolve\n                                             // with the record representing Trek Glowacki\n  }\n});\n\n\nNaming Conventions\nUnlike the REST Adapter, the Fixture Adapter does not make any assumptions\nabout the naming conventions of your model. As you saw in the example above,\nif you declare the attribute as firstName during DS.Model.extend, you use\nfirstName to represent the same field in your fixture data.\n\nImportantly, you should make sure that each record in your fixture data has\na uniquely identifiable field. By default, Ember Data assumes this key\nis called id. Should you not provide an id field in your fixtures, or\nnot override the primary key, the Fixture Adapter will throw an error.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0e991ff9ce7021b901869280c0615261","fields":[{"name":"title","value":"The Rest Adapter","type":"string"},{"name":"url","value":"/models/the-rest-adapter/","type":"enum"},{"name":"body","value":"By default, your store will use\nDS.RESTAdapter to load and\nsave records. The RESTAdapter assumes that the URLs and JSON\nassociated with each model are conventional; this means that, if you\nfollow the rules, you will not need to configure the adapter or write\nany code in order to get started.\nURL Conventions\nThe REST adapter is smart enough to determine the URLs it communicates\nwith based on the name of the model. For example, if you ask for a\nPost by ID:\n\n  1\n2\n\n  store.find('post', 1).then(function(post) {\n});\n\n\n\nThe REST adapter will automatically send a GET request to /posts/1.\n\nThe actions you can take on a record map onto the following URLs in the\nREST adapter:\n\n\n  \n    ActionHTTP VerbURL\n  \n  \n    FindGET/people/123\n    Find AllGET/people\n    UpdatePUT/people/123\n    CreatePOST/people\n    DeleteDELETE/people/123\n  \n\nPluralization Customization\nIrregular or uncountable pluralizations can be specified via Ember.Inflector.inflector:\n\n  1\n2\n3\n4\n\n  var inflector = Ember.Inflector.inflector;\n\ninflector.irregular('formula', 'formulae');\ninflector.uncountable('advice');\n\n\n\nThis will tell the REST adapter that requests for App.Formula requests\nshould go to /formulae/1 instead of /formulas/1.\nEndpoint Path Customization\nEndpoint paths can be prefixed with a namespace by setting the namespace\nproperty on the adapter:\n\n  1\n2\n3\n\n  App.ApplicationAdapter = DS.RESTAdapter.extend({\n  namespace: 'api/1'\n});\n\n\n\nRequests for App.Person would now target /api/1/people/1.\nHost Customization\nAn adapter can target other hosts by setting the host property.\n\n  1\n2\n3\n\n  App.ApplicationAdapter = DS.RESTAdapter.extend({\n  host: 'https://api.example.com'\n});\n\n\n\nRequests for App.Person would now target https://api.example.com/people/1.\nJSON Conventions\nWhen requesting a record, the REST adapter expects your server to return\na JSON representation of the record that conforms to the following\nconventions.\nJSON Root\nThe primary record being returned should be in a named root. For\nexample, if you request a record from /people/123, the response should\nbe nested inside a property called person:\n\n  1\n2\n3\n4\n5\n6\n\n  {\n  \"person\": {\n    \"firstName\": \"Jeff\",\n    \"lastName\": \"Atwood\"\n  }\n}\n\n\n\nNote: Although after destroyRecord or deleteRecord/save the adapter expects an empty object e.g. {} to be returned from the server after destroying a record.\n\nIf you don't have the option to change the data that the server responds with, you can override the \nDS.JSONSerializer#extractDeleteRecord, like so:\n\n  1\n2\n3\n4\n5\n\n  extractDeleteRecord: function(store, type, payload) {\n  // payload is {delete: true} and then ember data wants to go ahead and set\n  // the new properties, return null so it doesn't try to do that\n  return null;\n}\n\n\nAttribute Names\nAttribute names should be camelized.  For example, if you have a model like this:\n\n  1\n2\n3\n4\n5\n6\n\n  App.Person = DS.Model.extend({\n  firstName: DS.attr('string'),\n  lastName:  DS.attr('string'),\n\n  isPersonOfTheYear: DS.attr('boolean')\n});\n\n\n\nThe JSON returned from your server should look like this:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  {\n  \"person\": {\n    \"firstName\": \"Barack\",\n    \"lastName\": \"Obama\",\n    \"isPersonOfTheYear\": true\n  }\n}\n\n\n\nIrregular keys can be mapped with a custom serializer. If the JSON for\nthe Person model has a key of lastNameOfPerson, and the desired\nattribute name is simply lastName, then create a custom Serializer\nfor the model and override the normalizeHash property.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  App.Person = DS.Model.extend({\n  lastName: DS.attr('string')\n});\n\nApp.PersonSerializer = DS.RESTSerializer.extend({\n  normalizeHash: {\n    lastNameOfPerson: function(hash) {\n      hash.lastName = hash.lastNameOfPerson;\n      delete hash.lastNameOfPerson;\n\n      return hash;\n    }\n  }\n});\n\n\nRelationships\nReferences to other records should be done by ID. For example, if you\nhave a model with a hasMany relationship:\n\n  1\n2\n3\n\n  App.Post = DS.Model.extend({\n  comments: DS.hasMany('comment', {async: true})\n});\n\n\n\nThe JSON should encode the relationship as an array of IDs:\n\n  1\n2\n3\n4\n5\n\n  {\n  \"post\": {\n    \"comments\": [1, 2, 3]\n  }\n}\n\n\n\nComments for a post can be loaded by post.get('comments'). The REST adapter\nwill send a GET request to /comments?ids[]=1\u0026ids[]=2\u0026ids[]=3.\n\nAny belongsTo relationships in the JSON representation should be the\ncamelized version of the Ember Data model's name, with the string\nId appended. For example, if you have a model:\n\n  1\n2\n3\n\n  App.Comment = DS.Model.extend({\n  post: DS.belongsTo('post')\n});\n\n\n\nThe JSON should encode the relationship as an ID to another record:\n\n  1\n2\n3\n4\n5\n\n  {\n  \"comment\": {\n    \"post\": 1\n  }\n}\n\n\n\nIf needed these naming conventions can be overwritten by implementing\nthe keyForRelationship method.\n\n  1\n2\n3\n4\n5\n\n   App.ApplicationSerializer = DS.RESTSerializer.extend({\n   keyForRelationship: function(key, relationship) {\n      return key + 'Ids';\n   }\n });\n\n\nSideloaded Relationships\nTo reduce the number of HTTP requests necessary, you can sideload\nadditional records in your JSON response. Sideloaded records live\noutside the JSON root, and are represented as an array of hashes:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  {\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Node is not omakase\",\n    \"comments\": [1, 2, 3]\n  },\n\n  \"comments\": [{\n    \"id\": 1,\n    \"body\": \"But is it _lightweight_ omakase?\"\n  },\n  {\n    \"id\": 2,\n    \"body\": \"I for one welcome our new omakase overlords\"\n  },\n  {\n    \"id\": 3,\n    \"body\": \"Put me on the fast track to a delicious dinner\"\n  }]\n}\n\n\nCreating Custom Transformations\nIn some circumstances, the built in attribute types of string,\nnumber, boolean, and date may be inadequate. For example, a\nserver may return a non-standard date format.\n\nEmber Data can have new JSON transforms\nregistered for use as attributes:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  App.CoordinatePointTransform = DS.Transform.extend({\n  serialize: function(value) {\n    return [value.get('x'), value.get('y')];\n  },\n  deserialize: function(value) {\n    return Ember.create({ x: value[0], y: value[1] });\n  }\n});\n\nApp.Cursor = DS.Model.extend({\n  position: DS.attr('coordinatePoint')\n});\n\n\n\nWhen coordinatePoint is received from the API, it is\nexpected to be an array:\n\n  1\n2\n3\n4\n5\n\n  {\n  cursor: {\n    position: [4,9]\n  }\n}\n\n\n\nBut once loaded on a model instance, it will behave as an object:\n\n  1\n2\n3\n\n  var cursor = App.Cursor.find(1);\ncursor.get('position.x'); //=\u003e 4\ncursor.get('position.y'); //=\u003e 9\n\n\n\nIf position is modified and saved, it will pass through the\nserialize function in the transform and again be presented as\nan array in JSON.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3701fefea474dad678c5fecd87312b01","fields":[{"name":"title","value":"Working with Records","type":"string"},{"name":"url","value":"/models/working-with-records/","type":"enum"},{"name":"body","value":"Modifying Attributes\nOnce a record has been loaded, you can begin making changes to its\nattributes. Attributes behave just like normal properties in Ember.js\nobjects. Making changes is as simple as setting the attribute you\nwant to change:\n\n  1\n2\n3\n\n  var tyrion = this.store.find('person', 1);\n// ...after the record has loaded\ntyrion.set('firstName', \"Yollo\");\n\n\n\nAll of the Ember.js conveniences are available for\nmodifying attributes. For example, you can use Ember.Object's\nincrementProperty helper:\n\n  1\n\n  person.incrementProperty('age'); // Happy birthday!\n\n\n\nYou can tell if a record has outstanding changes that have not yet been\nsaved by checking its isDirty property. You can also see what parts of\nthe record were changed and what the original value was using the\nchangedAttributes function.  changedAttributes returns an object,\nwhose keys are the changed properties and values are an array of values\n[oldValue, newValue].\n\n  1\n2\n3\n4\n5\n\n  person.get('isAdmin');      //=\u003e false\nperson.get('isDirty');      //=\u003e false\nperson.set('isAdmin', true);\nperson.get('isDirty');      //=\u003e true\nperson.changedAttributes(); //=\u003e { isAdmin: [false, true] }\n\n\n\nAt this point, you can either persist your changes via save() or you\ncan rollback your changes. Calling rollback() reverts all the\nchangedAttributes to their original value.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  person.get('isDirty');      //=\u003e true\nperson.changedAttributes(); //=\u003e { isAdmin: [false, true] }\n\nperson.rollback();\n\nperson.get('isDirty');      //=\u003e false\nperson.get('isAdmin');      //=\u003e false\nperson.changedAttributes(); //=\u003e {}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"7bdaf101518cf52ad2c7b8a7eb71a128","fields":[{"name":"title","value":"Bindings","type":"string"},{"name":"url","value":"/object-model/bindings/","type":"enum"},{"name":"body","value":"A binding creates a link between two properties such that when one changes, the\nother one is updated to the new value automatically. Bindings can connect\nproperties on the same object, or across two different objects. Unlike most other\nframeworks that include some sort of binding implementation, bindings in\nEmber.js can be used with any object, not just between views and models.\n\nThe easiest way to create a two-way binding is to use a computed alias, that\nspecifies the path to another object.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  wife = Ember.Object.create({\n  householdIncome: 80000\n});\n\nHusband = Ember.Object.extend({\n  householdIncome: Ember.computed.alias('wife.householdIncome')\n});\n\nhusband = Husband.create({\n  wife: wife\n});\n\nhusband.get('householdIncome'); // 80000\n\n// Someone gets raise.\nhusband.set('householdIncome', 90000);\nwife.get('householdIncome'); // 90000\n\n\n\nNote that bindings don't update immediately. Ember waits until all of your\napplication code has finished running before synchronizing changes, so you can\nchange a bound property as many times as you'd like without worrying about the\noverhead of syncing bindings when values are transient.\nOne-Way Bindings\nA one-way binding only propagates changes in one direction. Often, one-way\nbindings are just a performance optimization and you can safely use a two-way binding\n(as, of course, two-way bindings are de facto one-way bindings if you only ever change\none side). Sometimes one-way bindings are useful to achieve specific behaviour such\nas a default that is the same as another property but can be overriden (e.g. a\nshipping address that starts the same as a billing address but can later be changed)\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  user = Ember.Object.create({\n  fullName: \"Kara Gates\"\n});\n\nUserView = Ember.View.extend({\n  userName: Ember.computed.oneWay('user.fullName')\n});\n\nuserView = UserView.create({\n  user: user\n});\n\n// Changing the name of the user object changes\n// the value on the view.\nuser.set('fullName', \"Krang Gates\");\n// userView.userName will become \"Krang Gates\"\n\n// ...but changes to the view don't make it back to\n// the object.\nuserView.set('userName', \"Truckasaurus Gates\");\nuser.get('fullName'); // \"Krang Gates\"\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4eb2fcd4e32d72e009d1c1d9fdceee41","fields":[{"name":"title","value":"Classes and Instances","type":"string"},{"name":"url","value":"/object-model/classes-and-instances/","type":"enum"},{"name":"body","value":"To define a new Ember class, call the extend() method on\nEmber.Object:\n\n  1\n2\n3\n4\n5\n\n  App.Person = Ember.Object.extend({\n  say: function(thing) {\n    alert(thing);\n  }\n});\n\n\n\nThis defines a new App.Person class with a say() method.\n\nYou can also create a subclass from any existing class by calling\nits extend() method. For example, you might want to create a subclass\nof Ember's built-in Ember.View class:\n\n  1\n2\n3\n4\n\n  App.PersonView = Ember.View.extend({\n  tagName: 'li',\n  classNameBindings: ['isAdministrator']\n});\n\n\n\nWhen defining a subclass, you can override methods but still access the\nimplementation of your parent class by calling the special _super()\nmethod:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  App.Person = Ember.Object.extend({\n  say: function(thing) {\n    var name = this.get('name');\n    alert(name + \" says: \" + thing);\n  }\n});\n\nApp.Soldier = App.Person.extend({\n  say: function(thing) {\n    this._super(thing + \", sir!\");\n  }\n});\n\nvar yehuda = App.Soldier.create({\n  name: \"Yehuda Katz\"\n});\n\nyehuda.say(\"Yes\"); // alerts \"Yehuda Katz says: Yes, sir!\"\n\n\nCreating Instances\nOnce you have defined a class, you can create new instances of that\nclass by calling its create() method. Any methods, properties and\ncomputed properties you defined on the class will be available to\ninstances:\n\n  1\n2\n\n  var person = App.Person.create();\nperson.say(\"Hello\"); // alerts \" says: Hello\"\n\n\n\nWhen creating an instance, you can initialize the value of its properties\nby passing an optional hash to the create() method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  App.Person = Ember.Object.extend({\n  helloWorld: function() {\n    alert(\"Hi, my name is \" + this.get('name'));\n  }\n});\n\nvar tom = App.Person.create({\n  name: \"Tom Dale\"\n});\n\ntom.helloWorld(); // alerts \"Hi, my name is Tom Dale\"\n\n\n\nFor performance reasons, note that you cannot redefine an instance's\ncomputed properties or methods when calling create(), nor can you\ndefine new ones. You should only set simple properties when calling\ncreate(). If you need to define or redefine methods or computed\nproperties, create a new subclass and instantiate that.\n\nBy convention, properties or variables that hold classes are\nPascalCased, while instances are not. So, for example, the variable\nApp.Person would point to a class, while person would point to an instance\n(usually of the App.Person class). You should stick to these naming\nconventions in your Ember applications.\nInitializing Instances\nWhen a new instance is created, its init method is invoked\nautomatically. This is the ideal place to do setup required on new\ninstances:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  App.Person = Ember.Object.extend({\n  init: function() {\n    var name = this.get('name');\n    alert(name + \", reporting for duty!\");\n  }\n});\n\nApp.Person.create({\n  name: \"Stefan Penner\"\n});\n\n// alerts \"Stefan Penner, reporting for duty!\"\n\n\n\nIf you are subclassing a framework class, like Ember.View or\nEmber.ArrayController, and you override the init method, make sure\nyou call this._super()! If you don't, the system may not have an\nopportunity to do important setup work, and you'll see strange behavior\nin your application.\n\nWhen accessing the properties of an object, use the get\nand set accessor methods:\n\n  1\n2\n3\n4\n\n  var person = App.Person.create();\n\nvar name = person.get('name');\nperson.set('name', \"Tobias Fünke\");\n\n\n\nMake sure to use these accessor methods; otherwise, computed properties won't\nrecalculate, observers won't fire, and templates won't update.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e959824557e508bda4cb824e0466f1ac","fields":[{"name":"title","value":"Computed Properties and Aggregate Data with @each","type":"string"},{"name":"url","value":"/object-model/computed-properties-and-aggregate-data/","type":"enum"},{"name":"body","value":"Often, you may have a computed property that relies on all of the items in an\narray to determine its value. For example, you may want to count all of the\ntodo items in a controller to determine how many of them are completed.\n\nHere's what that computed property might look like:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  App.TodosController = Ember.Controller.extend({\n  todos: [\n    Ember.Object.create({ isDone: true }),\n    Ember.Object.create({ isDone: false }),\n    Ember.Object.create({ isDone: true })\n  ],\n\n  remaining: function() {\n    var todos = this.get('todos');\n    return todos.filterBy('isDone', false).get('length');\n  }.property('todos.@each.isDone')\n});\n\n\n\nNote here that the dependent key (todos.@each.isDone) contains the special\nkey @each. This instructs Ember.js to update bindings and fire observers for\nthis computed property when one of the following four events occurs:\n\n\nThe isDone property of any of the objects in the todos array changes.\nAn item is added to the todos array.\nAn item is removed from the todos array.\nThe todos property of the controller is changed to a different array.\n\n\nIn the example above, the remaining count is 1:\n\n  1\n2\n3\n\n  App.todosController = App.TodosController.create();\nApp.todosController.get('remaining');\n// 1\n\n\n\nIf we change the todo's isDone property, the remaining property is updated\nautomatically:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  var todos = App.todosController.get('todos');\nvar todo = todos.objectAt(1);\ntodo.set('isDone', true);\n\nApp.todosController.get('remaining');\n// 0\n\ntodo = Ember.Object.create({ isDone: false });\ntodos.pushObject(todo);\n\nApp.todosController.get('remaining');\n// 1\n\n\n\nNote that @each only works one level deep. You cannot use nested forms like\ntodos.@each.owner.name or todos.@each.owner.@each.name.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a26ec310640ced8b722a53a9ac4a703a","fields":[{"name":"title","value":"Computed Properties","type":"string"},{"name":"url","value":"/object-model/computed-properties/","type":"enum"},{"name":"body","value":"What are Computed Properties?\nIn a nutshell, computed properties let you declare functions as properties. You create one by defining a computed property as a function, which Ember will automatically call when you ask for the property. You can then use it the same way you would any normal, static property.\n\nIt's super handy for taking one or more normal properties and transforming or manipulating their data to create a new value. \nComputed properties in action\nWe'll start with a simple example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  App.Person = Ember.Object.extend({\n  // these will be supplied by `create`\n  firstName: null,\n  lastName: null,\n\n  fullName: function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  }.property('firstName', 'lastName')\n});\n\nvar ironMan = App.Person.create({\n  firstName: \"Tony\",\n  lastName:  \"Stark\"\n});\n\nironMan.get('fullName'); // \"Tony Stark\"\n\n\n\nNotice that the fullName function calls property. This declares the function to be a computed property, and the arguments tell Ember that it depends on the firstName and lastName attributes.\n\nWhenever you access the fullName property, this function gets called, and it returns the value of the function, which simply calls firstName + lastName.\nAlternate invocation\nAt this point, you might be wondering how you are able to call the .property function on a function.  This is possible because Ember extends the function prototype.  More information about extending native prototypes is available in the disabling prototype extensions guide. If you'd like to replicate the declaration from above without using these extensions you could do so with the following:\n\n  1\n2\n3\n\n    fullName: Ember.computed('firstName', 'lastName', function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  })\n\n\nChaining computed properties\nYou can use computed properties as values to create new computed properties. Let's add a description computed property to the previous example, and use the existing fullName property and add in some other properties:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  App.Person = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n  age: null,\n  country: null,\n\n  fullName: function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  }.property('firstName', 'lastName'),\n\n  description: function() {\n    return this.get('fullName') + '; Age: ' + this.get('age') + '; Country: ' + this.get('country');\n  }.property('fullName', 'age', 'country')\n});\n\nvar captainAmerica = App.Person.create({\n  firstName: 'Steve',\n  lastName: 'Rogers',\n  age: 80,\n  country: 'USA'\n});\n\ncaptainAmerica.get('description'); // \"Steve Rogers; Age: 80; Country: USA\"\n\n\nDynamic updating\nComputed properties, by default, observe any changes made to the properties they depend on and are dynamically updated when they're called. Let's use computed properties to dynamically update. \n\n  1\n2\n3\n\n  captainAmerica.set('firstName', 'William');\n\ncaptainAmerica.get('description'); // \"William Rogers; Age: 80; Country: USA\"\n\n\n\nSo this change to firstName was observed by fullName computed property, which was itself observed by the description property.\n\nSetting any dependent property will propagate changes through any computed properties that depend on them, all the way down the chain of computed properties you've created.\nSetting Computed Properties\nYou can also define what Ember should do when setting a computed property. If you try to set a computed property, it will be invoked with the key (property name), the value you want to set it to, and the previous value.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n  App.Person = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n\n  fullName: function(key, value, previousValue) {\n    // setter\n    if (arguments.length \u003e 1) {\n      var nameParts = value.split(/\\s+/);\n      this.set('firstName', nameParts[0]);\n      this.set('lastName',  nameParts[1]);\n    }\n\n    // getter\n    return this.get('firstName') + ' ' + this.get('lastName');\n  }.property('firstName', 'lastName')\n});\n\n\nvar captainAmerica = App.Person.create();\ncaptainAmerica.set('fullName', \"William Burnside\");\ncaptainAmerica.get('firstName'); // William\ncaptainAmerica.get('lastName'); // Burnside\n\n\n\nEmber will call the computed property for both setters and getters, so if you want to use a computed property as a setter, you'll need to check the number of arguments to determine whether it is being called as a getter or a setter. Note that if a value is returned from the setter, it will be cached as the property’s value.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2899adf50b491f36747129255557b93d","fields":[{"name":"title","value":"Observers","type":"string"},{"name":"url","value":"/object-model/observers/","type":"enum"},{"name":"body","value":"Ember supports observing any property, including computed properties.\nYou can set up an observer on an object by using the observes\nmethod on a function:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  Person = Ember.Object.extend({\n  // these will be supplied by `create`\n  firstName: null,\n  lastName: null,\n\n  fullName: function() {\n    var firstName = this.get('firstName');\n    var lastName = this.get('lastName');\n\n    return firstName + ' ' + lastName;\n  }.property('firstName', 'lastName'),\n\n  fullNameChanged: function() {\n    // deal with the change\n  }.observes('fullName').on('init')\n});\n\nvar person = Person.create({\n  firstName: 'Yehuda',\n  lastName: 'Katz'\n});\n\nperson.set('firstName', 'Brohuda'); // observer will fire\n\n\n\nBecause the fullName computed property depends on firstName,\nupdating firstName will fire observers on fullName as well.\nObservers and asynchrony\nObservers in Ember are currently synchronous. This means that they will fire\nas soon as one of the properties they observe changes. Because of this, it\nis easy to introduce bugs where properties are not yet synchronized:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Person.reopen({\n  lastNameChanged: function() {\n    // The observer depends on lastName and so does fullName. Because observers\n    // are synchronous, when this function is called the value of fullName is\n    // not updated yet so this will log the old value of fullName\n    console.log(this.get('fullName'));\n  }.observes('lastName')\n});\n\n\n\nThis synchronous behaviour can also lead to observers being fired multiple\ntimes when observing multiple properties:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Person.reopen({\n  partOfNameChanged: function() {\n    // Because both firstName and lastName were set, this observer will fire twice.\n  }.observes('firstName', 'lastName')\n});\n\nperson.set('firstName', 'John');\nperson.set('lastName', 'Smith');\n\n\n\nTo get around these problems, you should make use of Ember.run.once. This will\nensure that any processing you need to do only happens once, and happens in the\nnext run loop once all bindings are synchronized:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  Person.reopen({\n  partOfNameChanged: function() {\n    Ember.run.once(this, 'processFullName');\n  }.observes('firstName', 'lastName'),\n\n  processFullName: function() {\n    // This will only fire once if you set two properties at the same time, and\n    // will also happen in the next run loop once all properties are synchronized\n    console.log(this.get('fullName'));\n  }\n});\n\nperson.set('firstName', 'John');\nperson.set('lastName', 'Smith');\n\n\nObservers and object initialization\nObservers never fire until after the initialization of an object is complete.\n\nIf you need an observer to fire as part of the initialization process, you\ncannot rely on the side effect of set. Instead, specify that the observer\nshould also run after init by using .on('init'):\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.Person = Ember.Object.extend({\n  init: function() {\n    this.set('salutation', \"Mr/Ms\");\n  },\n\n  salutationDidChange: function() {\n    // some side effect of salutation changing\n  }.observes('salutation').on('init')\n});\n\n\nUnconsumed Computed Properties Do Not Trigger Observers\nIf you never get a computed property, its observers will not fire even if\nits dependent keys change. You can think of the value changing from one unknown\nvalue to another.\n\nThis doesn't usually affect application code because computed properties are\nalmost always observed at the same time as they are fetched. For example, you get\nthe value of a computed property, put it in DOM (or draw it with D3), and then\nobserve it so you can update the DOM once the property changes.\n\nIf you need to observe a computed property but aren't currently retrieving it,\njust get it in your init method.\nWithout prototype extensions\nYou can define inline observers by using the Ember.observer method if you\nare using Ember without prototype extensions:\n\n  1\n2\n3\n4\n5\n\n  Person.reopen({\n  fullNameChanged: Ember.observer('fullName', function() {\n    // deal with the change\n  })\n});\n\n\nOutside of class definitions\nYou can also add observers to an object outside of a class definition\nusing addObserver:\n\n  1\n2\n3\n\n  person.addObserver('fullName', function() {\n  // deal with the change\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f8ecff8837ebc62045275db96d37ff19","fields":[{"name":"title","value":"Reopening Classes and Instances","type":"string"},{"name":"url","value":"/object-model/reopening-classes-and-instances/","type":"enum"},{"name":"body","value":"You don't need to define a class all at once. You can reopen a class and\ndefine new properties using the reopen method.\n\n  1\n2\n3\n4\n5\n\n  Person.reopen({\n  isPerson: true\n});\n\nPerson.create().get('isPerson') // true\n\n\n\nWhen using reopen, you can also override existing methods and\ncall this._super.\n\n  1\n2\n3\n4\n5\n6\n\n  Person.reopen({\n  // override `say` to add an ! at the end\n  say: function(thing) {\n    this._super(thing + \"!\");\n  }\n});\n\n\n\nreopen is used to add instance methods and properties that are shared across all instances of a class. It does not add\nmethods and properties to a particular instance of a class as in vanilla JavaScript (without using prototype).\n\nBut when you need to create class methods or add properties to the class itself you can use reopenClass.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  Person.reopenClass({\n  createMan: function() {\n    return Person.create({isMan: true})\n  }\n});\n\nPerson.createMan().get('isMan') // true\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e85689a1d05f5ca425e72f28075b9737","fields":[{"name":"title","value":"Bindings, Observers, Computed Properties: What Do I Use When?","type":"string"},{"name":"url","value":"/object-model/what-do-i-use-when/","type":"enum"},{"name":"body","value":"Sometimes new users are confused about when to use computed properties,\nbindings and observers. Here are some guidelines to help:\n\n\nUse computed properties to build a new property by synthesizing other\nproperties. Computed properties should not contain application behavior, and\nshould generally not cause any side-effects when called. Except in rare cases,\nmultiple calls to the same computed property should always return the same\nvalue (unless the properties it depends on have changed, of course.)\nObservers should contain behavior that reacts to changes in another\nproperty. Observers are especially useful when you need to perform some\nbehavior after a binding has finished synchronizing.\nBindings are most often used to ensure objects in two different layers\nare always in sync. For example, you bind your views to your controller using\nHandlebars.\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2e1967ab300f10bb0db8e074948cdccf","fields":[{"name":"title","value":"Asynchronous Routing","type":"string"},{"name":"url","value":"/routing/asynchronous-routing/","type":"enum"},{"name":"body","value":"This section covers some more advanced features of the router and its\ncapability for handling complex async logic within your app.\nA Word on Promises...\nEmber's approach to handling asynchronous logic in the router makes\nheavy use of the concept of Promises. In short, promises are objects that\nrepresent an eventual value. A promise can either fulfill\n(successfully resolve the value) or reject (fail to resolve the\nvalue). The way to retrieve this eventual value, or handle the cases\nwhen the promise rejects, is via the promise's then method, which\naccepts two optional callbacks, one for fulfillment and one for\nrejection. If the promise fulfills, the fulfillment handler gets called\nwith the fulfilled value as its sole argument, and if the promise rejects, \nthe rejection handler gets called with a reason for the rejection as its\nsole argument. For example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  var promise = fetchTheAnswer();\n\npromise.then(fulfill, reject);\n\nfunction fulfill(answer) {\n  console.log(\"The answer is \" + answer);\n}\n\nfunction reject(reason) {\n  console.log(\"Couldn't get the answer! Reason: \" + reason);\n}\n\n\n\nMuch of the power of promises comes from the fact that they can be\nchained together to perform sequential asynchronous operations:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  // Note: jQuery AJAX methods return promises\nvar usernamesPromise = Ember.$.getJSON('/usernames.json');\n\nusernamesPromise.then(fetchPhotosOfUsers)\n                .then(applyInstagramFilters)\n                .then(uploadTrendyPhotoAlbum)\n                .then(displaySuccessMessage, handleErrors);\n\n\n\nIn the above example, if any of the methods\nfetchPhotosOfUsers, applyInstagramFilters, or\nuploadTrendyPhotoAlbum returns a promise that rejects, \nhandleErrors will be called with\nthe reason for the failure. In this manner, promises approximate an\nasynchronous form of try-catch statements that prevent the rightward\nflow of nested callback after nested callback and facilitate a saner\napproach to managing complex asynchronous logic in your applications.\n\nThis guide doesn't intend to fully delve into all the different ways\npromises can be used, but if you'd like a more thorough introduction,\ntake a look at the readme for RSVP, \nthe promise library that Ember uses. \nThe Router Pauses for Promises\nWhen transitioning between routes, the Ember router collects all of the\nmodels (via the model hook) that will be passed to the route's\ncontrollers at the end of the transition. If the model hook (or the related\nbeforeModel or afterModel hooks) return normal (non-promise) objects or \narrays, the transition will complete immediately. But if the model hook \n(or the related beforeModel or afterModel hooks) returns a promise (or \nif a promise was provided as an argument to transitionTo), the transition \nwill pause until that promise fulfills or rejects.\n\nNote: The router considers any object with a then method\ndefined on it to be a promise.\n\nIf the promise fulfills, the transition will pick up where it left off and\nbegin resolving the next (child) route's model, pausing if it too is a\npromise, and so on, until all destination route models have been\nresolved. The values passed to the setupController hook for each route\nwill be the fulfilled values from the promises.\n\nA basic example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  App.TardyRoute = Ember.Route.extend({\n  model: function() {\n    return new Ember.RSVP.Promise(function(resolve) {\n      Ember.run.later(function() {\n        resolve({ msg: \"Hold Your Horses\" });\n      }, 3000);\n    });\n  }, \n\n  setupController: function(controller, model) {\n    console.log(model.msg); // \"Hold Your Horses\"\n  }\n});\n\n\n\nWhen transitioning into TardyRoute, the model hook will be called and\nreturn a promise that won't resolve until 3 seconds later, during which time\nthe router will be paused in mid-transition. When the promise eventually\nfulfills, the router will continue transitioning and eventually call\nTardyRoute's setupController hook with the resolved object.\n\nThis pause-on-promise behavior is extremely valuable for when you need\nto guarantee that a route's data has fully loaded before displaying a\nnew template. \nWhen Promises Reject...\nWe've covered the case when a model promise fulfills, but what if it rejects? \n\nBy default, if a model promise rejects during a transition, the transition is\naborted, no new destination route templates are rendered, and an error\nis logged to the console.\n\nYou can configure this error-handling logic via the error handler on\nthe route's actions hash. When a promise rejects, an error event\nwill be fired on that route and bubble up to ApplicationRoute's\ndefault error handler unless it is handled by a custom error handler\nalong the way, e.g.:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  App.GoodForNothingRoute = Ember.Route.extend({\n  model: function() {\n    return Ember.RSVP.reject(\"FAIL\");\n  },\n\n  actions: {\n    error: function(reason) {\n      alert(reason); // \"FAIL\"\n\n      // Can transition to another route here, e.g.\n      // this.transitionTo('index');\n\n      // Uncomment the line below to bubble this error event:\n      // return true;\n    }\n  }\n});\n\n\n\nIn the above example, the error event would stop right at\nGoodForNothingRoute's error handler and not continue to bubble. To\nmake the event continue bubbling up to ApplicationRoute, you can\nreturn true from the error handler.\nRecovering from Rejection\nRejected model promises halt transitions, but because promises are chainable,\nyou can catch promise rejects within the model hook itself and convert \nthem into fulfills that won't halt the transition.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.FunkyRoute = Ember.Route.extend({\n  model: function() {\n    return iHopeThisWorks().then(null, function() {\n      // Promise rejected, fulfill with some default value to\n      // use as the route's model and continue on with the transition\n      return { msg: \"Recovered from rejected promise\" };\n    });\n  }\n});\n\n\nbeforeModel and afterModel\nThe model hook covers many use cases for pause-on-promise transitions,\nbut sometimes you'll need the help of the related hooks beforeModel\nand afterModel. The most common reason for this is that if you're\ntransitioning into a route with a dynamic URL segment via {{link-to}} or\ntransitionTo (as opposed to a transition caused by a URL change), \nthe model for the route you're transitioning into will have already been\nspecified (e.g. {{#link-to 'article' article}} or\nthis.transitionTo('article', article)), in which case the model hook\nwon't get called. In these cases, you'll need to make use of either\nthe beforeModel or afterModel hook to house any logic while the\nrouter is still gathering all of the route's models to perform a\ntransition.\nbeforeModel\nEasily the more useful of the two, the beforeModel hook is called\nbefore the router attempts to resolve the model for the given route. In\nother words, it is called before the model hook gets called, or, if\nmodel doesn't get called, it is called before the router attempts to\nresolve any model promises passed in for that route.\n\nLike model, returning a promise from beforeModel will pause the\ntransition until it resolves, or will fire an error if it rejects.\n\nThe following is a far-from-exhaustive list of use cases in which\nbeforeModel is very handy:\n\n\nDeciding whether to redirect to another route before performing a\npotentially wasteful server query in model\nEnsuring that the user has an authentication token before proceeding\nonward to model\nLoading application code required by this route \n\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.SecretArticlesRoute  = Ember.Route.extend({\n  beforeModel: function() {\n    if (!this.controllerFor('auth').get('isLoggedIn')) {\n      this.transitionTo('login');\n    }\n  }\n});\n\n\n\nSee the API Docs for beforeModel\nafterModel\nThe afterModel hook is called after a route's model (which might be a\npromise) is resolved, and follows the same pause-on-promise semantics as\nmodel and beforeModel. It is passed the already-resolved model \nand can therefore perform any additional logic that\ndepends on the fully resolved value of a model.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  App.ArticlesRoute = Ember.Route.extend({\n  model: function() {\n    // App.Article.find() returns a promise-like object\n    // (it has a `then` method that can be used like a promise)\n    return App.Article.find();\n  },\n  afterModel: function(articles) {\n    if (articles.get('length') === 1) {\n      this.transitionTo('article.show', articles.get('firstObject'));\n    }\n  }\n});\n\n\n\nYou might be wondering why we can't just put the afterModel logic\ninto the fulfill handler of the promise returned from model; the\nreason, as mentioned above, is that transitions initiated \nvia {{link-to}} or transitionTo likely already provided the\nmodel for this route, so model wouldn't be called in these cases.\n\nSee the API Docs for afterModel\nMore Resources\n\nEmbercasts: Client-side Authentication Part 2\nRC6 Blog Post describing these new features\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"bc0bfb567fedd41ba7b17f66df025608","fields":[{"name":"title","value":"Defining Your Routes","type":"string"},{"name":"url","value":"/routing/defining-your-routes/","type":"enum"},{"name":"body","value":"When your application starts, the router is responsible for displaying\ntemplates, loading data, and otherwise setting up application state.\nIt does so by matching the current URL to the routes that you've\ndefined.\n\nThe map method\nof your Ember application's router can be invoked to define URL mappings. When\ncalling map, you should pass a function that will be invoked with the value\nthis set to an object which you can use to create\nroutes and\nresources.\n\n  1\n2\n3\n4\n\n  App.Router.map(function() {\n  this.route('about', { path: '/about' });\n  this.route('favorites', { path: '/favs' });\n});\n\n\n\nNow, when the user visits /about, Ember.js will render the about\ntemplate. Visiting /favs will render the favorites template.\n\nHeads up! You get a few routes for free: the ApplicationRoute and\nthe IndexRoute (corresponding to the / path).\nSee below for more details.\n\nNote that you can leave off the path if it is the same as the route\nname. In this case, the following is equivalent to the above example:\n\n  1\n2\n3\n4\n\n  App.Router.map(function() {\n  this.route('about');\n  this.route('favorites', { path: '/favs' });\n});\n\n\n\nInside your templates, you can use {{link-to}} to navigate between\nroutes, using the name that you provided to the route method (or, in\nthe case of /, the name index).\n\n  1\n2\n3\n4\n5\n6\n\n  {{#link-to 'index'}}\u003cimg class=\"logo\"\u003e{{/link-to}}\n\n\u003cnav\u003e\n  {{#link-to 'about'}}About{{/link-to}}\n  {{#link-to 'favorites'}}Favorites{{/link-to}}\n\u003c/nav\u003e\n\n\n\nThe {{link-to}} helper will also add an active class to the link that\npoints to the currently active route.\n\nYou can customize the behavior of a route by creating an Ember.Route\nsubclass. For example, to customize what happens when your user visits\n/, create an App.IndexRoute:\n\n  1\n2\n3\n4\n5\n6\n\n  App.IndexRoute = Ember.Route.extend({\n  setupController: function(controller) {\n    // Set the IndexController's `title`\n    controller.set('title', 'My App');\n  }\n});\n\n\n\nThe IndexController is the starting context for the index template.\nNow that you've set title, you can use it in the template:\n\n  1\n2\n\n  \u003c!-- get the title from the IndexController --\u003e\n\u003ch1\u003e{{title}}\u003c/h1\u003e\n\n\n\n(If you don't explicitly define an App.IndexController, Ember.js will\nautomatically generate one for you.)\n\nEmber.js automatically figures out the names of the routes and controllers based on\nthe name you pass to this.route.\n\n\n  \n  \n    URL\n    Route Name\n    Controller\n    Route\n    Template\n  \n  \n  \n    /\n    index\n    IndexController\n    IndexRoute\n    index\n  \n  \n    /about\n    about\n    AboutController\n    AboutRoute\n    about\n  \n  \n    /favs\n    favorites\n    FavoritesController\n    FavoritesRoute\n    favorites\n  \n\nResources\nYou can define groups of routes that work with a resource:\n\n  1\n2\n3\n4\n5\n\n  App.Router.map(function() {\n  this.resource('posts', { path: '/posts' }, function() {\n    this.route('new');\n  });\n});\n\n\n\nAs with this.route, you can leave off the path if it's the same as the\nname of the route, so the following router is equivalent:\n\n  1\n2\n3\n4\n5\n\n  App.Router.map(function() {\n  this.resource('posts', function() {\n    this.route('new');\n  });\n});\n\n\n\nThis router creates three routes:\n\n\n  \n  \n    URL\n    Route Name\n    Controller\n    Route\n    Template\n  \n  \n  \n    /\n    index\n    IndexController\n    IndexRoute\n    index\n  \n  \n    N/A\n    posts1\n    PostsController\n    PostsRoute\n    posts\n  \n  \n    /posts\n    posts.index\n    PostsController↳PostsIndexController\n    PostsRoute↳PostsIndexRoute\n    posts↳posts/index\n  \n  \n    /posts/new\n    posts.new\n    PostsController↳PostsNewController\n    PostsRoute↳PostsNewRoute\n    posts↳posts/new\n  \n\n\n1 Transitioning to posts or creating a link to\nposts is equivalent to transitioning to posts.index or linking to\nposts.index\n\nNOTE: If you define a resource using this.resource and do not supply\na function, then the implicit resource.index route is not created. In\nthat case, /resource will only use the ResourceRoute, ResourceController,\nand resource template.\n\nRoutes nested under a resource take the name of the resource plus their\nname as their route name. If you want to transition to a route (either\nvia transitionTo or {{#link-to}}), make sure to use the full route\nname (posts.new, not new).\n\nVisiting / renders the index template, as you would expect.\n\nVisiting /posts is slightly different. It will first render the\nposts template. Then, it will render the posts/index template into the\nposts template's outlet.\n\nFinally, visiting /posts/new will first render the posts template,\nthen render the posts/new template into its outlet.\n\nNOTE: You should use this.resource for URLs that represent a noun,\nand this.route for URLs that represent adjectives or verbs\nmodifying those nouns. For example, in the code sample above, when\nspecifying URLs for posts (a noun), the route was defined with\nthis.resource('posts'). However, when defining the new action\n(a verb), the route was defined with this.route('new').\nMulti-word Model Names\nFor multi-word models all the names are camel cased except for the dynamic segment. For example, a model named BigMac would have a resource path of /bigMacs/:big_mac_id, route named bigMac, template named bigMac.\nDynamic Segments\nOne of the responsibilities of a resource's route handler is to convert a URL\ninto a model.\n\nFor example, if we have the resource this.resource('posts');, our\nroute handler might look like this:\n\n  1\n2\n3\n4\n5\n\n  App.PostsRoute = Ember.Route.extend({\n  model: function() {\n    return this.store.find('post');\n  }\n});\n\n\n\nThe posts template will then receive a list of all available posts as\nits context.\n\nBecause /posts represents a fixed model, we don't need any\nadditional information to know what to retrieve.  However, if we want a route\nto represent a single post, we would not want to have to hardcode every\npossible post into the router.\n\nEnter dynamic segments.\n\nA dynamic segment is a portion of a URL that starts with a : and is\nfollowed by an identifier.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  App.Router.map(function() {\n  this.resource('posts');\n  this.resource('post', { path: '/post/:post_id' });\n});\n\nApp.PostRoute = Ember.Route.extend({\n  model: function(params) {\n    return this.store.find('post', params.post_id);\n  }\n});\n\n\n\nBecause this pattern is so common, the above model hook is the\ndefault behavior.\n\nFor example, if the dynamic segment is :post_id, Ember.js is smart\nenough to know that it should use the model App.Post (with the ID\nprovided in the URL). Specifically, unless you override model, the route will\nreturn this.store.find('post', params.post_id) automatically.\n\nNot coincidentally, this is exactly what Ember Data expects. So if you\nuse the Ember router with Ember Data, your dynamic segments will work\nas expected out of the box.\n\nIf your model does not use the id property in the URL, you should\ndefine a serialize method on your route:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  App.Router.map(function() {\n  this.resource('post', {path: '/posts/:post_slug'});\n});\n\nApp.PostRoute = Ember.Route.extend({\n  model: function(params) {\n    // the server returns `{ slug: 'foo-post' }`\n    return Ember.$.getJSON('/posts/' + params.post_slug);\n  },\n\n  serialize: function(model) {\n    // this will make the URL `/posts/foo-post`\n    return { post_slug: model.get('slug') };\n  }\n});\n\n\n\nThe default serialize method inserts the model's id into the route's\ndynamic segment (in this case, :post_id).\nNested Resources\nYou can nest both routes and resources:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.Router.map(function() {\n  this.resource('post', { path: '/post/:post_id' }, function() {\n    this.route('edit');\n    this.resource('comments', function() {\n      this.route('new');\n    });\n  });\n});\n\n\n\nThis router creates five routes:\n\n\n  \n    \n    \n      URL\n      Route Name\n      Controller\n      Route\n      Template\n    \n    \n    \n      /\n      index\n      App.IndexController\n      App.IndexRoute\n      index\n    \n    \n      N/A\n      post\n      App.PostController\n      App.PostRoute\n      post\n    \n    \n      /post/:post_id2\n      post.index\n      App.PostIndexController\n      App.PostIndexRoute\n      post/index\n    \n    \n      /post/:post_id/edit\n      post.edit\n      App.PostEditController\n      App.PostEditRoute\n      post/edit\n    \n    \n      N/A\n      comments\n      App.CommentsController\n      App.CommentsRoute\n      comments\n    \n    \n      /post/:post_id/comments\n      comments.index\n      App.CommentsIndexController\n      App.CommentsIndexRoute\n      comments/index\n    \n    \n      /post/:post_id/comments/new\n      comments.new\n      App.CommentsNewController\n      App.CommentsNewRoute\n      comments/new\n    \n  \n\n\n2 :post_id is the post's id.  For a post with id = 1, the route will be:\n/post/1\n\nThe comments template will be rendered in the post outlet.\nAll templates under comments (comments/index and comments/new) will be rendered in the comments outlet.\n\nThe route, controller, and view class names for the comments resource are not prefixed with Post. Resources\nalways reset the namespace, ensuring that the classes can be re-used between multiple parent resources and that\nclass names don't get longer the deeper nested the resources are.\n\nYou are also able to create deeply nested resources in order to preserve the namespace on your routes:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.Router.map(function() {\n  this.resource('foo', function() {\n    this.resource('foo.bar', { path: '/bar' }, function() {\n      this.route('baz'); // This will be foo.bar.baz\n    });\n  });\n});\n\n\n\nThis router creates the following routes:\n\n\n  \n    \n    \n      URL\n      Route Name\n      Controller\n      Route\n      Template\n    \n    \n    \n      /\n      index\n      App.IndexController\n      App.IndexRoute\n      index\n    \n    \n      /foo\n      foo.index\n      App.FooIndexController\n      App.FooIndexRoute\n      foo/index\n    \n    \n      /foo/bar\n      foo.bar.index\n      App.FooBarIndexController\n      App.FooBarIndexRoute\n      foo/bar/index\n    \n    \n      /foo/bar/baz\n      foo.bar.baz\n      App.FooBarBazController\n      App.FooBarBazRoute\n      foo/bar/baz\n    \n  \n\nInitial routes\nA few routes are immediately available within your application:\n\n\nApp.ApplicationRoute is entered when your app first boots up. It renders\nthe application template.\nApp.IndexRoute is the default route, and will render the index template\nwhen the user visits / (unless / has been overridden by your own\ncustom route).\n\n\nRemember, these routes are part of every application, so you don't need to\nspecify them in App.Router.map.\nWildcard / globbing routes\nYou can define wildcard routes that will match multiple routes. This could be used, for example,\nif you'd like a catchall route which is useful when the user enters an incorrect URL not managed\nby your app.\n\n  1\n2\n3\n\n  App.Router.map(function() {\n  this.route('catchall', {path: '/*wildcard'});\n});\n\n\n\nLike all routes with a dynamic segment, you must provide a context when using a {{link-to}}\nor transitionTo to programatically enter this route.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.ApplicationRoute = Ember.Route.extend({\n  actions: {\n    error: function() {\n      this.transitionTo('catchall', 'application-error');\n    }\n  }\n});\n\n\n\nWith this code, if an error bubbles up to the Application route, your application will enter\nthe catchall route and display /application-error in the URL.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c5953994735a42bd20744325ddcc8f3c","fields":[{"name":"title","value":"Generated Objects","type":"string"},{"name":"url","value":"/routing/generated-objects/","type":"enum"},{"name":"body","value":"As explained in the routing guide, whenever you define a new route,\nEmber.js attempts to find corresponding Route, Controller, View, and Template\nclasses named according to naming conventions. If an implementation of any of\nthese objects is not found, appropriate objects will be generated in memory for you.\nGenerated routes\nGiven you have the following route:\n\n  1\n2\n3\n\n  App.Router.map(function() {\n  this.resource('posts');\n});\n\n\n\nWhen you navigate to /posts, Ember.js looks for App.PostsRoute.\nIf it doesn't find it, it will automatically generate an App.PostsRoute for you.\nCustom Generated Routes\nYou can have all your generated routes extend a custom route.  If you define App.Route,\nall generated routes will be instances of that route.\nGenerated Controllers\nIf you navigate to route posts, Ember.js looks for a controller called App.PostsController.\nIf you did not define it, one will be generated for you.\n\nEmber.js can generate three types of controllers:\nEmber.ObjectController, Ember.ArrayController, and Ember.Controller.\n\nThe type of controller Ember.js chooses to generate for you depends on your route's\nmodel hook:\n\n\nIf it returns an object (such as a single record), an ObjectController will be generated.\nIf it returns an array, an ArrayController will be generated.\nIf it does not return anything, an instance of Ember.Controller will be generated.\n\nCustom Generated Controllers\nIf you want to customize generated controllers, you can define your own App.Controller, App.ObjectController\nand App.ArrayController.  Generated controllers will extend one of these three (depending on the conditions above).\nGenerated Views and Templates\nA route also expects a view and a template.  If you don't define a view,\na view will be generated for you.\n\nA generated template is empty.\nIf it's a resource template, the template will simply act\nas an outlet so that nested routes can be seamlessly inserted.  It is equivalent to:\n\n  1\n\n  {{outlet}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e220634be1096dfda0635ee4cccf6449","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/routing/","type":"enum"},{"name":"body","value":"Routing\nAs users interact with your application, it moves through many\ndifferent states. Ember.js gives you helpful tools for managing\nthat state in a way that scales with your application.\n\nTo understand why this is important, imagine we are writing a web app\nfor managing a blog. At any given time, we should be able to answer\nquestions like: Is the user currently logged in? Are they an admin\nuser? What post are they looking at? Is the settings screen open?  Are\nthey editing the current post?\n\nIn Ember.js, each of the possible states in your application is\nrepresented by a URL. Because all of the questions we asked above—\nAre we logged in?  What post are we looking at? —are encapsulated by\nroute handlers for the URLs, answering them is both simple and accurate.\n\nAt any given time, your application has one or more active route\nhandlers. The active handlers can change for one of two reasons:\n\n\nThe user interacted with a view, which generated an event that caused\nthe URL to change.\nThe user changed the URL manually (e.g., via the back button), or the\npage was loaded for the first time.\n\n\nWhen the current URL changes, the newly active route handlers may do one\nor more of the following:\n\n\nConditionally redirect to a new URL.\nUpdate a controller so that it represents a particular model.\nChange the template on screen, or place a new template into an\nexisting outlet.\n\nLogging Route Changes\nAs your application increases in complexity, it can be helpful to see exactly what is going on with the router. To have Ember write out transition events to the log, simply modify your Ember.Application:\n\n  1\n2\n3\n\n  App = Ember.Application.create({\n  LOG_TRANSITIONS: true\n});\n\n\nSpecifying a Root URL\nIf your Ember application is one of multiple web applications served from the same domain, it may be necessary to indicate to the router what the root URL for your Ember application is. By default, Ember will assume it is served from the root of your domain.\n\nIf for example, you wanted to serve your blogging application from emberjs.com/blog/, it would be necessary to specify a root URL of /blog/.\n\nThis can be achieved by setting the rootURL on the router:\n\n  1\n2\n3\n\n  App.Router.reopen({\n  rootURL: '/blog/'\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"75e0b6a8b1d5599aba5e312f7024e64e","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/routing/link-to-router-flow/","type":"enum"},{"name":"body","value":"Router flow from link-to\nIn this guide we will explore the steps Ember performs when a user\nclicks on a link generated by the link-to helper. Ember has a number\nof useful hooks you can overwrite to run code during the various\nphases of the transition.\n\nLets imagine a user is on the /about/faq/ page of an application\nwith the following router.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.Router.map(function() {\n  this.resource('about', function() {\n    this.route('faq');\n  });\n\n  this.resource('user', { path: '/user/:user_id' }, function() {\n    this.route('profile');\n  });\n});\n\n\n\nThis would mean there are currently three nested active routes in this\napplication. The ApplicationRoute, AboutRoute and the AboutFaqRoute.\n\n\n\nLets assume a user clicks on a link-to for the UserProfileRoute like\nthe one below.\n\n  1\n\n  {{#link-to 'user.profile' user}}Visit your user profile{{/link-to}}\n\n\n\nEmber will perform a number of steps before transition a user to the\nuser profile page. Broadly these steps are grouped into three phases,\nthe Pre Transition Phase, the Model Resolution Phase and the Sync\nPhase. We will explore these phases in more depth below.\nPre Transition Phase\nFirst Ember will create a transition object. This object is a promise\nwhich will be resolved when the transition is complete or rejected\nwhen the random is aborted. The transition object can be used to abort\nthe transition by calling transition.abort().\n\nNext Ember will trigger a willTransition action on the currently\nactive routes starting with the leaf-most route (in this example the\nAboutFaqRoute).\n\n\n\nThe argument for the willTransition action is the transition\nobject. This gives each active route, the opportunity to decide\nwhether or not the transition should occur. The code to intercept the\nwillTransition action and abort a transition might looks something\nlike this.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  App.AboutFaqRoute = Ember.Route.extend({\n  actions: {\n    willTransition: function(transition) {\n      if (this.controllerFor('form').get('userHasEnteredData') \u0026\u0026\n          !confirm(\"Are you sure you want to abandon progress?\")) {\n        transition.abort();\n      } else {\n        // Bubble the `willTransition` action so that\n        // parent routes can decide whether or not to abort.\n        return true;\n      }\n    }\n  }\n});\n\n\n\nIf the transition is not aborted then Ember will attempt to resolve\nthe model.\nModel Resolution / Validation Phase\nThe purpose of this phase is both to collect and resolve all model\npromises for newly entered routes (or routes with updated contexts),\nas well as allow for any of the\nbeforeModel\n/\nmodel\n/\nafterModel\nhooks to reject elsewhere. If any of these hooks return a promise, the\ntransition will pause until the promise resolves/rejects.\n\n\n\nIf the promise rejects, and error action is triggered from the\nerroring route and upwards with the rejected/thrown error. Calling\ntransitionTo elsewhere will abort the transition as well (but fire\nno errors).\nSync exit/enter/setup Phase\nAfter the transition has been validated and any models are resolved\nember enters the Sync exit/enter/setup Phase. Here Ember calls\nexit on the existing\nroutes and\nenter\n/\nsetup\non the newly entered routes.\n\n\n\nIf any errors are thrown, the transition promise will be rejected and\nthe error action will be triggered from the erroring route and\nupwards with the rejected/thrown error.\n\nIf no errors are thrown then the internal transition promise is\nresolved and the user is now on the profile page.\nMore Resources\n\nPreventing and retrying transitions\nEmber.js: Transition promises, redirects\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b73d2dfe086aa008696fa624bef07e0e","fields":[{"name":"title","value":"Loading / Error Substates","type":"string"},{"name":"url","value":"/routing/loading-and-error-substates/","type":"enum"},{"name":"body","value":"In addition to the techniques described in the\nAsynchronous Routing Guide,\nthe Ember Router provides powerful yet overridable\nconventions for customizing asynchronous transitions\nbetween routes by making use of error and loading\nsubstates.\nloading substates\nThe Ember Router allows you to return promises from the various\nbeforeModel/model/afterModel hooks in the course of a transition\n(described here).\nThese promises pause the transition until they fulfill, at which point\nthe transition will resume.\n\nConsider the following:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  App.Router.map(function() {\n  this.resource('foo', function() { // -\u003e FooRoute\n    this.route('slowModel');        // -\u003e FooSlowModelRoute\n  });\n});\n\nApp.FooSlowModelRoute = Ember.Route.extend({\n  model: function() {\n    return somePromiseThatTakesAWhileToResolve();\n  }\n});\n\n\n\nIf you navigate to foo/slow_model, and in FooSlowModelRoute#model,\nyou return an AJAX query promise that takes a long time to complete.\nDuring this time, your UI isn't really giving you any feedback as to\nwhat's happening; if you're entering this route after a full page\nrefresh, your UI will be entirely blank, as you have not actually\nfinished fully entering any route and haven't yet displayed any\ntemplates; if you're navigating to foo/slow_model from another\nroute, you'll continue to see the templates from the previous route\nuntil the model finish loading, and then, boom, suddenly all the\ntemplates for foo/slow_model load.\n\nSo, how can we provide some visual feedback during the transition?\n\nEmber provides a default implementation of the loading process that implements\nthe following loading substate behavior.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.Router.map(function() {\n  this.resource('foo', function() {       // -\u003e FooRoute\n    this.resource('foo.bar', function() { // -\u003e FooBarRoute\n      this.route('baz');                  // -\u003e FooBarBazRoute\n    });\n  });\n});\n\n\n\nIf a route with the path foo.bar.baz returns a promise that doesn't immediately\nresolve, Ember will try to find a loading route in the hierarchy\nabove foo.bar.baz that it can transition into, starting with\nfoo.bar.baz's sibling:\n\n\nfoo.bar.loading\nfoo.loading\nloading\n\n\nEmber will find a loading route at the above location if either a) a\nRoute subclass has been defined for such a route, e.g.\n\n\nApp.FooBarLoadingRoute\nApp.FooLoadingRoute\nApp.LoadingRoute\n\n\nor b) a properly-named loading template has been found, e.g.\n\n\nfoo/bar/loading\nfoo/loading\nloading\n\n\nDuring a slow asynchronous transition, Ember will transition into the\nfirst loading sub-state/route that it finds, if one exists. The\nintermediate transition into the loading substate happens immediately\n(synchronously), the URL won't be updated, and, unlike other transitions\nthat happen while another asynchronous transition is active, the\ncurrently active async transition won't be aborted.\n\nAfter transitioning into a loading substate, the corresponding template\nfor that substate, if present, will be rendered into the main outlet of\nthe parent route, e.g. foo.bar.loading's template would render into\nfoo.bar's outlet. (This isn't particular to loading routes; all\nroutes behave this way by default.)\n\nOnce the main async transition into foo.bar.baz completes, the loading\nsubstate will be exited, its template torn down, foo.bar.baz will be\nentered, and its templates rendered.\nEager vs. Lazy Async Transitions\nLoading substates are optional, but if you provide one,\nyou are essentially telling Ember that you\nwant this async transition to be \"eager\"; in the absence of destination\nroute loading substates, the router will \"lazily\" remain on the pre-transition route\nwhile all of the destination routes' promises resolve, and only fully\ntransition to the destination route (and renders its templates, etc.)\nonce the transition is complete. But once you provide a destination\nroute loading substate, you are opting into an \"eager\" transition, which\nis to say that, unlike the \"lazy\" default, you will eagerly exit the\nsource routes (and tear down their templates, etc) in order to\ntransition into this substate. URLs always update immediately unless the\ntransition was aborted or redirected within the same run loop.\n\nThis has implications on error handling, i.e. when a transition into\nanother route fails, a lazy transition will (by default) just remain on the\nprevious route, whereas an eager transition will have already left the\npre-transition route to enter a loading substate.\nThe loading event\nIf you return a promise from the various beforeModel/model/afterModel hooks,\nand it doesn't immediately resolve, a loading event will be fired on that route\nand bubble upward to ApplicationRoute.\n\nIf the loading handler is not defined at the specific route,\nthe event will continue to bubble above a transition's pivot\nroute, providing the ApplicationRoute the opportunity to manage it.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  App.FooSlowModelRoute = Ember.Route.extend({\n  model: function() {\n    return somePromiseThatTakesAWhileToResolve();\n  },\n  actions: {\n    loading: function(transition, originRoute) {\n      //displayLoadingSpinner();\n\n      // Return true to bubble this event to `FooRoute`\n      // or `ApplicationRoute`.\n      return true;\n    }\n  }\n});\n\n\n\nThe loading handler provides the ability to decide what to do during\nthe loading process. If the last loading handler is not defined\nor returns true, Ember will perform the loading substate behavior.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  App.ApplicationRoute = Ember.Route.extend({\n  actions: {\n    loading: function(transition, originRoute) {\n      displayLoadingSpinner();\n\n      // substate implementation when returning `true`\n      return true;\n    }\n  }\n});\n\n\nerror substates\nEmber provides an analogous approach to loading substates in\nthe case of errors encountered during a transition.\n\nSimilar to how the default loading event handlers are implemented,\nthe default error handlers will look for an appropriate error substate to\nenter, if one can be found.\n\n  1\n2\n3\n4\n5\n\n  App.Router.map(function() {\n  this.resource('articles', function() { // -\u003e ArticlesRoute\n    this.route('overview');              // -\u003e ArticlesOverviewRoute\n  });\n});\n\n\n\nFor instance, an error thrown or rejecting promise returned from\nArticlesOverviewRoute#model (or beforeModel or afterModel)\nwill look for:\n\n\nEither ArticlesErrorRoute or articles/error template\nEither ErrorRoute or error template\n\n\nIf one of the above is found, the router will immediately transition into\nthat substate (without updating the URL). The \"reason\" for the error\n(i.e. the exception thrown or the promise reject value) will be passed\nto that error state as its model.\n\nIf no viable error substates can be found, an error message will be\nlogged.\nerror substates with dynamic segments\nRoutes with dynamic segments are often mapped to a mental model of \"two\nseparate levels.\" Take for example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  App.Router.map(function() {\n  this.resource('foo', {path: '/foo/:id'}, function() {\n    this.route('baz');\n  });\n});\n\nApp.FooRoute = Ember.Route.extend({\n  model: function(params) {\n    return new Ember.RSVP.Promise(function(resolve, reject) {\n       reject(\"Error\");\n    });\n  }\n});\n\n\n\nIn the URL hierarchy you would visit /foo/12 which would result in rendering\nthe foo template into the application template's outlet. In the event of\nan error while attempting to load the foo route you would also render the\ntop-level error template into the application template's outlet. This is\nintentionally parallel behavior as the foo route is never successfully\nentered. In order to create a foo scope for errors and render foo/error\ninto foo's outlet you would need to split the dynamic segment:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.Router.map(function() {\n  this.resource('foo', {path: '/foo'}, function() {\n    this.resource('elem', {path: ':id'}, function() {\n      this.route('baz');\n    });\n  });\n});\n\n\n\nExample JSBin\nThe error event\nIf ArticlesOverviewRoute#model returns a promise that rejects (because, for\ninstance, the server returned an error, or the user isn't logged in,\netc.), an error event will fire on ArticlesOverviewRoute and bubble upward.\nThis error event can be handled and used to display an error message,\nredirect to a login page, etc.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  App.ArticlesOverviewRoute = Ember.Route.extend({\n  model: function(params) {\n    return new Ember.RSVP.Promise(function(resolve, reject) {\n       reject(\"Error\");\n    });\n  },\n  actions: {\n    error: function(error, transition) {\n\n      if (error \u0026\u0026 error.status === 400) {\n        // error substate and parent routes do not handle this error\n        return this.transitionTo('modelNotFound');\n      }\n\n      // Return true to bubble this event to any parent route.\n      return true;\n    }\n  }\n});\n\n\n\nIn analogy with the loading event, you could manage the error event\nat the Application level to perform any app logic and based on the\nresult of the last error handler, Ember will decide if substate behavior\nmust be performed or not.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  App.ApplicationRoute = Ember.Route.extend({\n  actions: {\n    error: function(error, transition) {\n\n      // Manage your errors\n      Ember.onerror(error);\n\n      // substate implementation when returning `true`\n      return true;\n\n    }\n  }\n});\n\n\nLegacy LoadingRoute\nPrevious versions of Ember (somewhat inadvertently) allowed you to define a global LoadingRoute\nwhich would be activated whenever a slow promise was encountered during\na transition and exited upon completion of the transition. Because the\nloading template rendered as a top-level view and not within an\noutlet, it could be used for little more than displaying a loading\nspinner during slow transitions. Loading events/substates give you far\nmore control, but if you'd like to emulate something similar to the legacy\nLoadingRoute behavior, you could do as follows:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  App.LoadingView = Ember.View.extend({\n  templateName: 'global-loading',\n  elementId: 'global-loading'\n});\n\nApp.ApplicationRoute = Ember.Route.extend({\n  actions: {\n    loading: function() {\n      var view = this.container.lookup('view:loading').append();\n      this.router.one('didTransition', view, 'destroy');\n    }\n  }\n});\n\n\n\nExample JSBin\n\nThis will, like the legacy LoadingRoute, append a top-level view when the\nrouter goes into a loading state, and tear down the view once the\ntransition finishes.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"73217f11fed62d7b09ccc1c4378f49e7","fields":[{"name":"title","value":"Preventing and Retrying Transitions","type":"string"},{"name":"url","value":"/routing/preventing-and-retrying-transitions/","type":"enum"},{"name":"body","value":"During a route transition, the Ember Router passes a transition\nobject to the various hooks on the routes involved in the transition.\nAny hook that has access to this transition object has the ability\nto immediately abort the transition by calling transition.abort(), \nand if the transition object is stored, it can be re-attempted at a \nlater time by calling transition.retry().\nPreventing Transitions via willTransition\nWhen a transition is attempted, whether via {{link-to}}, transitionTo,\nor a URL change, a willTransition action is fired on the currently\nactive routes. This gives each active route, starting with the leaf-most\nroute, the opportunity to decide whether or not the transition should occur.\n\nImagine your app is in a route that's displaying a complex form for the user\nto fill out and the user accidentally navigates backwards. Unless the\ntransition is prevented, the user might lose all of the progress they\nmade on the form, which can make for a pretty frustrating user experience.\n\nHere's one way this situation could be handled:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  App.FormRoute = Ember.Route.extend({\n  actions: {\n    willTransition: function(transition) {\n      if (this.controller.get('userHasEnteredData') \u0026\u0026\n          !confirm(\"Are you sure you want to abandon progress?\")) {\n        transition.abort();\n      } else {\n        // Bubble the `willTransition` action so that\n        // parent routes can decide whether or not to abort.\n        return true;\n      }\n    }\n  }\n});\n\n\n\nWhen the user clicks on a {{link-to}} helper, or when the app initiates a \ntransition by using transitionTo, the transition will be aborted and the URL\nwill remain unchanged. However, if the browser back button is used to \nnavigate away from FormRoute, or if the user manually changes the URL, the \nnew URL will be navigated to before the willTransition action is \ncalled. This will result in the browser displaying the new URL, even if \nwillTransition calls transition.abort().\nAborting Transitions Within model, beforeModel, afterModel\nThe model, beforeModel, and afterModel hooks described in\nAsynchronous Routing\neach get called with a transition object. This makes it possible for\ndestination routes to abort attempted transitions.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.DiscoRoute = Ember.Route.extend({\n  beforeModel: function(transition) {\n    if (new Date() \u003c new Date(\"January 1, 1980\")) {\n      alert(\"Sorry, you need a time machine to enter this route.\");\n      transition.abort();\n    }\n  }\n});\n\n\nStoring and Retrying a Transition\nAborted transitions can be retried at a later time. A common use case\nfor this is having an authenticated route redirect the user to a login\npage, and then redirecting them back to the authenticated route once\nthey've logged in. \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n  App.SomeAuthenticatedRoute = Ember.Route.extend({\n  beforeModel: function(transition) {\n    if (!this.controllerFor('auth').get('userIsLoggedIn')) {\n      var loginController = this.controllerFor('login');\n      loginController.set('previousTransition', transition);\n      this.transitionTo('login');\n    }\n  }\n});\n\nApp.LoginController = Ember.Controller.extend({\n  actions: {\n    login: function() {\n      // Log the user in, then reattempt previous transition if it exists.\n      var previousTransition = this.get('previousTransition');\n      if (previousTransition) {\n        this.set('previousTransition', null);\n        previousTransition.retry();\n      } else {\n        // Default back to homepage\n        this.transitionToRoute('index');\n      }\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a10da78f7f24528b1e5d721dbc5e424b","fields":[{"name":"title","value":"Query Parameters","type":"string"},{"name":"url","value":"/routing/query-params/","type":"enum"},{"name":"body","value":"Query parameters are optional key-value pairs that appear to the right of\nthe ? in a URL. For example, the following URL has two query params,\nsort and page, with respective values ASC and 2:\n\n  1\n\n  http://example.com/articles?sort=ASC\u0026page=2\n\n\n\nQuery params allow for additional application state to be serialized\ninto the URL that can't otherwise fit into the path of the URL (i.e.\neverything to the left of the ?). Common use cases for query params include\nrepresenting the current page, filter criteria, or sorting criteria.\nSpecifying Query Parameters\nQuery params can be declared on route-driven controllers, e.g. to\nconfigure query params that are active within the articles route,\nthey must be declared on ArticlesController.\n\nNote: The controller associated with a given route can be changed\nby specifying the controllerName property on that route.\n\nLet's say we'd like to add a category\nquery parameter that will filter out all the articles that haven't\nbeen categorized as popular. To do this, we specify 'category'\nas one of ArticlesController's queryParams:\n\n  1\n2\n3\n4\n\n  App.ArticlesController = Ember.ArrayController.extend({\n  queryParams: ['category'],\n  category: null\n});\n\n\n\nThis sets up a binding between the category query param in the URL,\nand the category property on ArticlesController. In other words,\nonce the articles route has been entered, any changes to the\ncategory query param in the URL will update the category property\non ArticlesController, and vice versa.\n\nNow we just need to define a computed property of our category-filtered\narray that the articles template will render:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  App.ArticlesController = Ember.ArrayController.extend({\n  queryParams: ['category'],\n  category: null,\n\n  filteredArticles: function() {\n    var category = this.get('category');\n    var articles = this.get('model');\n\n    if (category) {\n      return articles.filterBy('category', category);\n    } else {\n      return articles;\n    }\n  }.property('category', 'model')\n});\n\n\n\nWith this code, we have established the following behaviors:\n\n\nIf the user navigates to /articles, category will be null, so\nthe articles won't be filtered.\nIf the user navigates to /articles?category=recent,\ncategory will be set to \"recent\", so articles will be filtered.\nOnce inside the articles route, any changes to the category\nproperty on ArticlesController will cause the URL to update the\nquery param. By default, a query param property change won't cause a\nfull router transition (i.e. it won't call model hooks and\nsetupController, etc.); it will only update the URL.\n\nlink-to Helper\nThe link-to helper supports specifying query params by way of the\nquery-params subexpression helper.\n\n  1\n2\n3\n4\n5\n\n  // Explicitly set target query params\n{{#link-to 'posts' (query-params direction=\"asc\")}}Sort{{/link-to}}\n\n// Binding is also supported\n{{#link-to 'posts' (query-params direction=otherDirection)}}Sort{{/link-to}}\n\n\n\nIn the above examples, direction is presumably a query param property\non the PostsController, but it could also refer to a direction property\non any of the controllers associated with the posts route hierarchy,\nmatching the leaf-most controller with the supplied property name.\n\nNote: Subexpressions are only available in Handlebars 1.3\nor later.\n\nThe link-to helper takes into account query parameters when determining\nits \"active\" state, and will set the class appropriately. The active state\nis determined by calculating whether the query params end up the same after\nclicking a link. You don't have to supply all of the current,\nactive query params for this to be true.\ntransitionTo\nRoute#transitionTo (and Controller#transitionToRoute) now\naccepts a final argument, which is an object with\nthe key queryParams.\n\n  1\n2\n3\n4\n5\n\n  this.transitionTo('post', object, {queryParams: {showDetails: true}});\nthis.transitionTo('posts', {queryParams: {sort: 'title'}});\n\n// if you just want to transition the query parameters without changing the route\nthis.transitionTo({queryParams: {direction: 'asc'}});\n\n\n\nYou can also add query params to URL transitions:\n\n  1\n\n  this.transitionTo(\"/posts/1?sort=date\u0026showDetails=true\");\n\n\nOpting into a full transition\nKeep in mind that if the arguments provided to transitionTo\nor link-to only correspond to a change in query param values,\nand not a change in the route hierarchy, it is not considered a\nfull transition, which means that hooks like model and\nsetupController won't fire by default, but rather only\ncontroller properties will be updated with new query param values, as\nwill the URL.\n\nBut some query param changes necessitate loading data from the server,\nin which case it is desirable to opt into a full-on transition. To opt\ninto a full transition when a controller query param property changes,\nyou can use the optional queryParams configuration hash on the Route\nassociated with that controller, and set that query param's\nrefreshModel config property to true:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  App.ArticlesRoute = Ember.Route.extend({\n  queryParams: {\n    category: {\n      refreshModel: true\n    }\n  },\n  model: function(params) {\n    // This gets called upon entering 'articles' route\n    // for the first time, and we opt into refiring it upon\n    // query param changes by setting `refreshModel:true` above.\n\n    // params has format of { category: \"someValueOrJustNull\" },\n    // which we can just forward to the server.\n    return this.store.findQuery('articles', params);\n  }\n});\n\nApp.ArticlesController = Ember.ArrayController.extend({\n  queryParams: ['category'],\n  category: null\n});\n\n\nUpdate URL with replaceState instead\nBy default, Ember will use pushState to update the URL in the\naddress bar in response to a controller query param property change, but\nif you would like to use replaceState instead (which prevents an\nadditional item from being added to your browser's history), you can\nspecify this on the Route's queryParams config hash, e.g. (continued\nfrom the example above):\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.ArticlesRoute = Ember.Route.extend({\n  queryParams: {\n    category: {\n      replace: true\n    }\n  }\n});\n\n\n\nNote that the name of this config property and its default value of\nfalse is similar to the link-to helper's, which also lets\nyou opt into a replaceState transition via replace=true.\nMap a controller's property to a different query param key\nBy default, specifying foo as a controller query param property will\nbind to a query param whose key is foo, e.g. ?foo=123. You can also map\na controller property to a different query param key using the\nfollowing configuration syntax:\n\n  1\n2\n3\n4\n5\n6\n\n  App.ArticlesController = Ember.ArrayController.extend({\n  queryParams: {\n    category: \"articles_category\"\n  },\n  category: null\n});\n\n\n\nThis will cause changes to the ArticlesController's category\nproperty to update the articles_category query param, and vice versa.\n\nNote that query params that require additional customization can\nbe provided along with strings in the queryParams array.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.ArticlesController = Ember.ArrayController.extend({\n  queryParams: [ \"page\", \"filter\", {\n    category: \"articles_category\"\n  }],\n  category: null,\n  page: 1,\n  filter: \"recent\"\n});\n\n\nDefault values and deserialization\nIn the following example, the controller query param property page is\nconsidered to have a default value of 1.\n\n  1\n2\n3\n4\n\n  App.ArticlesController = Ember.ArrayController.extend({\n  queryParams: 'page',\n  page: 1\n});\n\n\n\nThis affects query param behavior in two ways:\n\n\nQuery param values are cast to the same datatype as the default\nvalue, e.g. a URL change from /?page=3 to /?page=2 will set\nArticlesController's page property to the number 2, rather than\nthe string \"2\". The same also applies to boolean default values.\nWhen a controller's query param property is currently set to its\ndefault value, this value won't be serialized into the URL. So in the\nabove example, if page is 1, the URL might look like /articles,\nbut once someone sets the controller's page value to 2, the URL\nwill become /articles?page=2.\n\nSticky Query Param Values\nBy default, query param values in Ember are \"sticky\", in that if you\nmake changes to a query param and then leave and re-enter the route, the\nnew value of that query param will be preserved (rather than reset to\nits default). This is a particularly handy default for preserving sort/filter\nparameters as you navigate back and forth between routes.\n\nFurthermore, these sticky query param values are remembered/restored\naccording to the model loaded into the route. So, given a team route\nwith dynamic segment /:team_name and controller query param \"filter\",\nif you navigate to /badgers and filter by \"rookies\", then navigate\nto /bears and filter by \"best\", and then navigate to /potatoes and\nfilter by \"lamest\", then given the following nav bar links,\n\n  1\n2\n3\n\n  {{#link-to 'team' 'badgers '}}Badgers{{/link-to}}\n{{#link-to 'team' 'bears'   }}Bears{{/link-to}}\n{{#link-to 'team' 'potatoes'}}Potatoes{{/link-to}}\n\n\n\nthe generated links would be\n\n  1\n2\n3\n\n  \u003ca href=\"/badgers?filter=rookies\"\u003eBadgers\u003c/a\u003e\n\u003ca href=\"/bears?filter=best\"\u003eBears\u003c/a\u003e\n\u003ca href=\"/potatoes?filter=lamest\"\u003ePotatoes\u003c/a\u003e\n\n\n\nThis illustrates that once you change a query param, it is stored and\ntied to the model loaded into the route.\n\nIf you wish to reset a query param, you have two options:\n\n\nexplicitly pass in the default value for that query param into\nlink-to or transitionTo\nuse the Route.resetController hook to set query param values back to\ntheir defaults before exiting the route or changing the route's model\n\n\nIn the following example, the controller's page query param is reset\nto 1, while still scoped to the pre-transition ArticlesRoute model.\nThe result of this is that all links pointing back into the exited route\nwill use the newly reset value 1 as the value for the page query\nparam.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.ArticlesRoute = Ember.Route.extend({\n  resetController: function (controller, isExiting, transition) {\n    if (isExiting) {\n      // isExiting would be false if only the route's model was changing\n      controller.set('page', 1);\n    }\n  }\n});\n\n\n\nIn some cases, you might not want the sticky query param value to be\nscoped to the route's model but would rather reuse a query param's value\neven as a route's model changes. This can be accomplished by setting the\nscope option to \"controller\" within the controller's queryParams\nconfig hash:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.ArticlesController = Ember.ArrayController.extend({\n  queryParams: [{\n    showMagnifyingGlass: {\n      scope: \"controller\"\n    }\n  }]\n});\n\n\n\nThe following demonstrates how you can override both the scope and the\nquery param URL key of a single controller query param property:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  App.ArticlesController = Ember.Controller.extend({\n  queryParams: [ \"page\", \"filter\",\n    {\n      showMagnifyingGlass: {\n        scope: \"controller\",\n        as: \"glass\",\n      }\n    }\n  ]\n});\n\n\nExamples\n\nSearch queries\nSort: client-side, no refiring of model hook\nSort: server-side, refire model hook\nPagination + Sorting\nBoolean values. False value removes QP from URL\nGlobal query params on app route\nOpt-in to full transition via refresh()\nupdate query params by changing controller QP property\nupdate query params with replaceState by changing controller QP property\nw/ {{partial}} helper for easy tabbing\nlink-to with no route name, only QP change\nComplex: serializing textarea content into URL (and subexpressions))\nArrays\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"088e52d28fa44f8c93ca2f490bad93c3","fields":[{"name":"title","value":"Redirecting","type":"string"},{"name":"url","value":"/routing/redirection/","type":"enum"},{"name":"body","value":"Transitioning and Redirecting\nCalling transitionTo from a route or transitionToRoute from a controller\nwill stop any transition currently in progress and start a new one, functioning\nas a redirect. transitionTo takes parameters and behaves exactly like the link-to helper:\n\n\nIf you transition into a route without dynamic segments that route's model hook\nwill always run.\nIf the new route has dynamic segments, you need to pass either a model or an identifier for each segment.\nPassing a model will skip that segment's model hook.  Passing an identifier will run the model hook and you'll be able to access the identifier in the params. See Links for more detail.\n\nBefore the model is known\nIf you want to redirect from one route to another, you can do the transition in\nthe beforeModel hook of your route handler.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.Router.map(function() {\n  this.resource('posts');\n});\n\nApp.IndexRoute = Ember.Route.extend({\n  beforeModel: function() {\n    this.transitionTo('posts');\n  }\n});\n\n\nAfter the model is known\nIf you need some information about the current model in order to decide about\nthe redirection, you should either use the afterModel or the redirect hook. They\nreceive the resolved model as the first parameter and the transition as the second one,\nand thus function as aliases. (In fact, the default implementation of afterModel just calls redirect.)\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  \nApp.Router.map(function() {\n  this.resource('posts');\n  this.resource('post', { path: '/post/:post_id' });\n});\n\nApp.PostsRoute = Ember.Route.extend({\n  afterModel: function(posts, transition) {\n    if (posts.get('length') === 1) {\n      this.transitionTo('post', posts.get('firstObject'));\n    }\n  }\n});\n\n\n\nWhen transitioning to the PostsRoute if it turns out that there is only one post,\nthe current transition will be aborted in favor of redirecting to the PostRoute\nwith the single post object being its model.\nBased on other application state\nYou can conditionally transition based on some other application state.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n  App.Router.map(function() {\n  this.resource('topCharts', function() {\n    this.route('choose', { path: '/' });\n    this.route('albums');\n    this.route('songs');\n    this.route('artists');\n    this.route('playlists');\n  });\n});\n\nApp.TopChartsChooseRoute = Ember.Route.extend({\n  beforeModel: function() {\n    var lastFilter = this.controllerFor('application').get('lastFilter');\n    this.transitionTo('topCharts.' + (lastFilter || 'songs'));\n  }\n});\n\n// Superclass to be used by all of the filter routes below\nApp.FilterRoute = Ember.Route.extend({\n  activate: function() {\n    var controller = this.controllerFor('application');\n    controller.set('lastFilter', this.templateName);\n  }\n});\n\nApp.TopChartsSongsRoute = App.FilterRoute.extend();\nApp.TopChartsAlbumsRoute = App.FilterRoute.extend();\nApp.TopChartsArtistsRoute = App.FilterRoute.extend();\nApp.TopChartsPlaylistsRoute = App.FilterRoute.extend();\n\n\n\nIn this example, navigating to the / URL immediately transitions into\nthe last filter URL that the user was at. The first time, it transitions\nto the /songs URL.\n\nYour route can also choose to transition only in some cases. If the\nbeforeModel hook does not abort or transition to a new route, the remaining\nhooks (model, afterModel, setupController, renderTemplate) will execute\nas usual.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b1db196c912b89d4bb0d82325bb9137c","fields":[{"name":"title","value":"Rendering a Template","type":"string"},{"name":"url","value":"/routing/rendering-a-template/","type":"enum"},{"name":"body","value":"One of the most important jobs of a route handler is rendering the\nappropriate template to the screen.\n\nBy default, a route handler will render the template into the closest\nparent with a template.\n\n  1\n2\n3\n4\n5\n\n  App.Router.map(function() {\n  this.resource('posts');\n});\n\nApp.PostsRoute = Ember.Route.extend();\n\n\n\nIf you want to render a template other than the one associated with the\nroute handler, implement the renderTemplate hook:\n\n  1\n2\n3\n4\n5\n\n  App.PostsRoute = Ember.Route.extend({\n  renderTemplate: function() {\n    this.render('favoritePost');\n  }\n});\n\n\n\nIf you want to use a different controller than the route handler's\ncontroller, pass the controller's name in the controller option:\n\n  1\n2\n3\n4\n5\n\n  App.PostsRoute = Ember.Route.extend({\n  renderTemplate: function() {\n    this.render({ controller: 'favoritePost' });\n  }\n});\n\n\n\nEmber allows you to name your outlets. For instance, this code allows\nyou to specify two outlets with distinct names:\n\n  1\n2\n\n  \u003cdiv class=\"toolbar\"\u003e{{outlet \"toolbar\"}}\u003c/div\u003e\n\u003cdiv class=\"sidebar\"\u003e{{outlet \"sidebar\"}}\u003c/div\u003e\n\n\n\nSo, if you want to render your posts into the sidebar outlet, use code\nlike this:\n\n  1\n2\n3\n4\n5\n\n  App.PostsRoute = Ember.Route.extend({\n  renderTemplate: function() {\n    this.render({ outlet: 'sidebar' });\n  }\n});\n\n\n\nAll of the options described above can be used together in whatever\ncombination you'd like:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  App.PostsRoute = Ember.Route.extend({\n  renderTemplate: function() {\n    var controller = this.controllerFor('favoritePost');\n\n    // Render the `favoritePost` template into\n    // the outlet `posts`, and use the `favoritePost`\n    // controller.\n    this.render('favoritePost', {\n      outlet: 'posts',\n      controller: controller\n    });\n  }\n});\n\n\n\nIf you want to render two different templates into outlets of two different rendered templates of a route:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  App.PostRoute = App.Route.extend({\n  renderTemplate: function() {\n    this.render('favoritePost', {   // the template to render\n      into: 'posts',                // the template to render into\n      outlet: 'posts',              // the name of the outlet in that template\n      controller: 'blogPost'        // the controller to use for the template\n    });\n    this.render('comments', {\n      into: 'favoritePost',\n      outlet: 'comment',\n      controller: 'blogPost'\n    });\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8f5b0353b7bdd003571145819f2b209b","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/routing/sending-events-from-templates/","type":"enum"},{"name":"body","value":"Use the {{action}} helper to attach a handler in your view class to an event triggered on an element.\n\nTo attach an element's click event to the edit() handler in the current view:\n\n  1\n\n  \u003ca href=\"#\" {{action 'edit' on=\"click\"}}\u003eEdit\u003c/a\u003e\n\n\n\nBecause the default event is click, this could be written more concisely as:\n\n  1\n\n  \u003ca href=\"#\" {{action 'edit'}}\u003eEdit\u003c/a\u003e\n\n\n\nAlthough the view containing the {{action}} helper will be targeted by default, it is possible to target a different view:\n\n  1\n\n  \u003ca href=\"#\" {{action 'edit' target=\"parentView\"}}\u003eEdit\u003c/a\u003e\n\n\n\nThe action handler can optionally accept a jQuery event object, which will be extended to include view and context properties. These properties can be useful when targeting a different view with your action. For instance:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.ListingView = Ember.View.extend({\n  templateName: 'listing',\n\n  edit: function(event) {\n    event.view.set('isEditing', true);\n  }\n});\n\n\n\nAny of the templates discussed above will produce an HTML element like this:\n\n  1\n\n  \u003ca href=\"#\" data-ember-action=\"3\"\u003eEdit\u003c/a\u003e\n\n\n\nEmber will delegate the event you specified to your target view's handler based upon the internally assigned data-ember-action id.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d03c0729ed2df89a208ead1f07dcf9fd","fields":[{"name":"title","value":"Setting Up a Controller","type":"string"},{"name":"url","value":"/routing/setting-up-a-controller/","type":"enum"},{"name":"body","value":"Changing the URL may also change which template is displayed on\nscreen. Templates, however, are usually only useful if they have some\nsource of information to display.\n\nIn Ember.js, a template retrieves information to display from a\ncontroller.\n\nTwo built-in controllers—Ember.ObjectController and\nEmber.ArrayController—make it easy for a controller to present a\nmodel's properties to a template, along with any additional\ndisplay-specific properties.\n\nTo tell one of these controllers which model to present, set its\nmodel property in the route handler's setupController hook.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  App.Router.map(function() {\n  this.resource('post', { path: '/posts/:post_id' });\n});\n\nApp.PostRoute = Ember.Route.extend({\n  // The code below is the default behavior, so if this is all you\n  // need, you do not need to provide a setupController implementation\n  // at all.\n  setupController: function(controller, model) {\n    controller.set('model', model);\n  }\n});\n\n\n\nThe setupController hook receives the route handler's associated\ncontroller as its first argument. In this case, the PostRoute's\nsetupController receives the application's instance of\nApp.PostController.\n\nTo specify a controller other than the default, set the route's\ncontrollerName property:\n\n  1\n2\n3\n\n  App.SpecialPostRoute = Ember.Route.extend({\n  controllerName: 'post'\n});\n\n\n\nAs a second argument, it receives the route handler's model. For more\ninformation, see Specifying a Route's Model.\n\nThe default setupController hook sets the model property of the\nassociated controller to the route handler's model.\n\nIf you want to configure a controller other than the controller\nassociated with the route handler, use the controllerFor method:\n\n  1\n2\n3\n4\n5\n\n  App.PostRoute = Ember.Route.extend({\n  setupController: function(controller, model) {\n    this.controllerFor('topPost').set('model', model);\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d94b756c7278f11f9a951d1a47d8640f","fields":[{"name":"title","value":"Specifying a Route's Model","type":"string"},{"name":"url","value":"/routing/specifying-a-routes-model/","type":"enum"},{"name":"body","value":"Templates in your application are backed by models. But how do templates\nknow which model they should display?\n\nFor example, if you have a photos template, how does it know which\nmodel to render?\n\nThis is one of the jobs of an Ember.Route. You can tell a template\nwhich model it should render by defining a route with the same name as\nthe template, and implementing its model hook.\n\nFor example, to provide some model data to the photos template, we\nwould define an App.PhotosRoute object:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  App.PhotosRoute = Ember.Route.extend({\n  model: function() {\n    return [{\n      title: \"Tomster\",\n      url: \"http://emberjs.com/images/about/ember-productivity-sm.png\"\n    }, {\n      title: \"Eiffel Tower\",\n      url: \"http://emberjs.com/images/about/ember-structure-sm.png\"\n    }];\n  }\n});\n\n\n\nJS Bin\nAsynchronously Loading Models\nIn the above example, the model data was returned synchronously from the\nmodel hook. This means that the data was available immediately and\nyour application did not need to wait for it to load, in this case\nbecause we immediately returned an array of hardcoded data.\n\nOf course, this is not always realistic. Usually, the data will not be\navailable synchronously, but instead must be loaded asynchronously over\nthe network. For example, we may want to retrieve the list of photos\nfrom a JSON API available on our server.\n\nIn cases where data is available asynchronously, you can just return a\npromise from the model hook, and Ember will wait until that promise is\nresolved before rendering the template.\n\nIf you're unfamiliar with promises, the basic idea is that they are\nobjects that represent eventual values. For example, if you use jQuery's\ngetJSON() method, it will return a promise for the JSON that is\neventually returned over the network. Ember uses this promise object to\nknow when it has enough data to continue rendering.\n\nFor more about promises, see A Word on\nPromises\nin the Asynchronous Routing guide.\n\nLet's look at an example in action. Here's a route that loads the most\nrecent pull requests sent to Ember.js on GitHub:\n\n  1\n2\n3\n4\n5\n\n  App.PullRequestsRoute = Ember.Route.extend({\n  model: function() {\n    return Ember.$.getJSON('https://api.github.com/repos/emberjs/ember.js/pulls');\n  }\n});\n\n\n\nWhile this example looks like it's synchronous, making it easy to read\nand reason about, it's actually completely asynchronous. That's because\njQuery's getJSON() method returns a promise. Ember will detect the\nfact that you've returned a promise from the model hook, and wait\nuntil that promise resolves to render the pullRequests template.\n\n(For more information on jQuery's XHR functionality, see\njQuery.ajax in the jQuery\ndocumentation.)\n\nBecause Ember supports promises, it can work with any persistence\nlibrary that uses them as part of its public API. You can also use many\nof the conveniences built in to promises to make your code even nicer.\n\nFor example, imagine if we wanted to modify the above example so that\nthe template only displayed the three most recent pull requests. We can\nrely on promise chaining to modify the data returned from the JSON\nrequest before it gets passed to the template:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.PullRequestsRoute = Ember.Route.extend({\n  model: function() {\n    var url = 'https://api.github.com/repos/emberjs/ember.js/pulls';\n    return Ember.$.getJSON(url).then(function(data) {\n      return data.splice(0, 3);\n    });\n  }\n});\n\n\nSetting Up Controllers with the Model\nSo what actually happens with the value you return from the model\nhook?\n\nBy default, the value returned from your model hook will be assigned\nto the model property of the associated controller. For example, if your\nApp.PostsRoute returns an object from its model hook, that object\nwill be set as the model property of the App.PostsController.\n\n(This, under the hood, is how templates know which model to render: they\nlook at their associated controller's model property. For example, the\nphotos template will render whatever the App.PhotosController's\nmodel property is set to.)\n\nSee the Setting Up a Controller guide to learn how to change this\ndefault behavior. Note that if you override the default behavior and do\nnot set the model property on a controller, your template will not\nhave any data to render!\nDynamic Models\nSome routes always display the same model. For example, the /photos\nroute will always display the same list of photos available in the\napplication. If your user leaves this route and comes back later, the\nmodel does not change.\n\nHowever, you will often have a route whose model will change depending\non user interaction. For example, imagine a photo viewer app. The\n/photos route will render the photos template with the list of\nphotos as the model, which never changes. But when the user clicks on a\nparticular photo, we want to display that model with the photo\ntemplate. If the user goes back and clicks on a different photo, we want\nto display the photo template again, this time with a different model.\n\nIn cases like this, it's important that we include some information in\nthe URL about not only which template to display, but also which model.\n\nIn Ember, this is accomplished by defining routes with dynamic segments.\n\nA dynamic segment is a part of the URL that is filled in by the current\nmodel's ID. Dynamic segments always start with a colon (:). Our photo\nexample might have its photo route defined like this:\n\n  1\n2\n3\n\n  App.Router.map(function() {\n  this.resource('photo', { path: '/photos/:photo_id' });\n});\n\n\n\nIn this example, the photo route has a dynamic segment :photo_id.\nWhen the user goes to the photo route to display a particular photo\nmodel (usually via the {{link-to}} helper), that model's ID will be\nplaced into the URL automatically.\n\nSee Links for more information about linking\nto a route with a model using the {{link-to}} helper.\n\nFor example, if you transitioned to the photo route with a model whose\nid property was 47, the URL in the user's browser would be updated\nto:\n\n  1\n\n  /photos/47\n\n\n\nWhat happens if the user visits your application directly with a URL\nthat contains a dynamic segment? For example, they might reload the\npage, or send the link to a friend, who clicks on it. At that point,\nbecause we are starting the application up from scratch, the actual\nJavaScript model object to display has been lost; all we have is the ID\nfrom the URL.\n\nLuckily, Ember will extract any dynamic segments from the URL for\nyou and pass them as a hash to the model hook as the first argument:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.Router.map(function() {\n  this.resource('photo', { path: '/photos/:photo_id' });\n});\n\nApp.PhotoRoute = Ember.Route.extend({\n  model: function(params) {\n    return Ember.$.getJSON('/photos/'+params.photo_id);\n  }\n});\n\n\n\nIn the model hook for routes with dynamic segments, it's your job to\nturn the ID (something like 47 or post-slug) into a model that can\nbe rendered by the route's template. In the above example, we use the\nphoto's ID (params.photo_id) to construct a URL for the JSON\nrepresentation of that photo. Once we have the URL, we use jQuery to\nreturn a promise for the JSON model data.\n\nNote: A route with a dynamic segment will only have its model hook called\nwhen it is entered via the URL. If the route is entered through a transition\n(e.g. when using the link-to Handlebars helper), then a model context is\nalready provided and the hook is not executed. Routes without dynamic segments\nwill always execute the model hook.\nRefreshing your model\nIf your data represented by your model is being updated frequently, you may\nwant to refresh it periodically:\n\nJS Bin\n\nThe controller can send an action to the Route; in this example above, the\nIndexController exposes an action getLatest which sends the route an\naction called invalidateModel. Calling the route's refresh method will force\nEmber to execute the model hook again.\nEmber Data\nMany Ember developers use a model library to make finding and saving\nrecords easier than manually managing Ajax calls. In particular, using a\nmodel library allows you to cache records that have been loaded,\nsignificantly improving the performance of your application.\n\nOne popular model library built for Ember is Ember Data. To learn more\nabout using Ember Data to manage your models, see the\nModels guide.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6e746c1a547709a4f7e74f0ab1401f16","fields":[{"name":"title","value":"Specifying the URL Type","type":"string"},{"name":"url","value":"/routing/specifying-the-location-api/","type":"enum"},{"name":"body","value":"By default the Router uses the browser's hash to load the starting state of your\napplication and will keep it in sync as you move around. At present, this relies\non a hashchange event existing in the browser.\n\nGiven the following router, entering /#/posts/new will take you to the posts.new\nroute.\n\n  1\n2\n3\n4\n5\n\n  App.Router.map(function() {\n  this.resource('posts', function() {\n    this.route('new');\n  });\n});\n\n\n\nIf you want /posts/new to work instead, you can tell the Router to use the browser's\nhistory API. \n\nKeep in mind that your server must serve the Ember app from all the URLs defined in your \nRouter.map function. \n\n  1\n2\n3\n\n  App.Router.reopen({\n  location: 'history'\n});\n\n\n\nFinally, if you don't want the browser's URL to interact with your application\nat all, you can disable the location API entirely. This is useful for\ntesting, or when you need to manage state with your Router, but temporarily\ndon't want it to muck with the URL (for example when you embed your\napplication in a larger page).\n\n  1\n2\n3\n\n  App.Router.reopen({\n  location: 'none'\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"1b11151882558c3e878b1c432610d998","fields":[{"name":"title","value":"Actions","type":"string"},{"name":"url","value":"/templates/actions/","type":"enum"},{"name":"body","value":"The {{action}} Helper\nYour app will often need a way to let users interact with controls that\nchange application state. For example, imagine that you have a template\nthat shows a blog post, and supports expanding the post with additional\ninformation.\n\nYou can use the {{action}} helper to make an HTML element clickable.\nWhen a user clicks the element, the named event will be sent to your\napplication.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  \u003c!-- post.handlebars --\u003e\n\n\u003cdiv class='intro'\u003e\n  {{intro}}\n\u003c/div\u003e\n\n{{#if isExpanded}}\n  \u003cdiv class='body'\u003e{{body}}\u003c/div\u003e\n  \u003cbutton {{action 'contract'}}\u003eContract\u003c/button\u003e\n{{else}}\n  \u003cbutton {{action 'expand'}}\u003eShow More...\u003c/button\u003e\n{{/if}}\n\n\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  App.PostController = Ember.ObjectController.extend({\n  // initial value\n  isExpanded: false,\n\n  actions: {\n    expand: function() {\n      this.set('isExpanded', true);\n    },\n\n    contract: function() {\n      this.set('isExpanded', false);\n    }\n  }\n});\n\n\n\nNote that actions may be attached to any element of the DOM, but not all\nrespond to the click event. For example, if an action is attached to an a\nlink without an href attribute, or to a div, some browsers won't execute\nthe associated function. If it's really needed to define actions over such\nelements, a CSS workaround exists to make them clickable, cursor: pointer.\nFor example:\n\n  1\n2\n3\n\n  [data-ember-action] {\n  cursor: pointer;\n}\n\n\nAction Bubbling\nBy default, the {{action}} helper triggers a method on the template's\ncontroller, as illustrated above.\n\nIf the controller does not implement a method with the same name as the\naction in its actions object, the action will be sent to the router, where\nthe currently active leaf route will be given a chance to handle the action.\n\nRoutes and controllers that handle actions must place action handlers\ninside an actions hash. Even if a route has a method with the same name\nas the actions, it will not be triggered unless it is inside an actions hash.\nIn the case of a controller, while there is deprecated support for triggering\na method directly on the controller, it is strongly recommended that you\nput your action handling methods inside an actions hash for forward\ncompatibility.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  App.PostRoute = Ember.Route.extend({\n  actions: {\n    expand: function() {\n      this.controller.set('isExpanded', true);\n    },\n\n    contract: function() {\n      this.controller.set('isExpanded', false);\n    }\n  }\n});\n\n\n\nAs you can see in this example, the action handlers are called such\nthat when executed, this is the route, not the actions hash.\n\nTo continue bubbling the action, you must return true from the handler:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  App.PostRoute = Ember.Route.extend({\n  actions: {\n    expand: function() {\n      this.controller.set('isExpanded', true);\n    },\n\n    contract: function() {\n      // ...\n      if (actionShouldAlsoBeTriggeredOnParentRoute) {\n        return true;\n      }\n    }\n  }\n});\n\n\n\nIf neither the template's controller nor the currently active route\nimplements a handler, the action will continue to bubble to any parent\nroutes. Ultimately, if an ApplicationRoute is defined, it will have an\nopportunity to handle the action.\n\nWhen an action is triggered, but no matching action handler is\nimplemented on the controller, the current route, or any of the\ncurrent route's ancestors, an error will be thrown.\n\n\n\nThis allows you to create a button that has different behavior based on\nwhere you are in the application. For example, you might want to have a\nbutton in a sidebar that does one thing if you are somewhere inside of\nthe /posts route, and another thing if you are inside of the /about\nroute.\nAction Parameters\nYou can optionally pass arguments to the action handler. Any values\npassed to the {{action}} helper after the action name will be passed to\nthe handler as arguments.\n\nFor example, if the post argument was passed:\n\n  1\n\n  \u003cp\u003e\u003cbutton {{action \"select\" post}}\u003e✓\u003c/button\u003e {{post.title}}\u003c/p\u003e\n\n\n\nThe controller's select action handler would be called with a single argument\ncontaining the post model:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.PostController = Ember.ObjectController.extend({\n  actions: {\n    select: function(post) {\n      console.log(post.get('title'));\n    }\n  }\n});\n\n\nSpecifying the Type of Event\nBy default, the {{action}} helper listens for click events and triggers\nthe action when the user clicks on the element.\n\nYou can specify an alternative event by using the on option.\n\n  1\n2\n3\n4\n\n  \u003cp\u003e\n  \u003cbutton {{action \"select\" post on=\"mouseUp\"}}\u003e✓\u003c/button\u003e\n  {{post.title}}\n\u003c/p\u003e\n\n\n\nYou should use the normalized event names listed in the View guide.\nIn general, two-word event names (like keypress) become keyPress.\nSpecifying Whitelisted Modifier Keys\nBy default the {{action}} helper will ignore click events with\npressed modifier keys. You can supply an allowedKeys option\nto specify which keys should not be ignored.\n\n  1\n2\n3\n4\n5\n\n  \u003cscript type=\"text/x-handlebars\" data-template-name='a-template'\u003e\n  \u003cdiv {{action 'anActionName' allowedKeys=\"alt\"}}\u003e\n    click me\n  \u003c/div\u003e\n\u003c/script\u003e\n\n\n\nThis way the {{action}} will fire when clicking with the alt key\npressed down.\nStopping Event Propagation\nBy default, the {{action}} helper allows events it handles to bubble\nup to parent DOM nodes. If you want to stop propagation, you can disable\npropagation to the parent node.\n\nFor example, if you have a ✗ button inside of a link, you will want\nto ensure that if the user clicks on the ✗, that the link is not\nclicked.\n\n  1\n2\n3\n4\n\n  {{#link-to 'post'}}\n  Post\n  \u003cbutton {{action 'close' bubbles=false}}\u003e✗\u003c/button\u003e\n{{/link-to}}\n\n\n\nWithout bubbles=false, if the user clicked on the button, Ember.js\nwill trigger the action, and then the browser will propagate the click\nto the link.\n\nWith bubbles=false, Ember.js will stop the browser from propagating\nthe event.\nSpecifying a Target\nBy default, the {{action}} helper will send the action to the view's\ntarget, which is generally the view's controller. (Note: in the case of\nan Ember.Component, the default target is the component itself.)\n\nYou can specify an alternative target by using the target option. This\nis most commonly used to send actions to a view instead of a controller.\n\n  1\n2\n3\n4\n\n  \u003cp\u003e\n  \u003cbutton {{action \"select\" post target=view}}\u003e✓\u003c/button\u003e\n  {{post.title}}\n\u003c/p\u003e\n\n\n\nYou would handle this in an actions hash on your view.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.PostsIndexView = Ember.View.extend({\n  actions: {\n    select: function(post) {\n      // do your business.\n    }\n  }\n});\n\n\n\nNote that actions sent to views in this way do not bubble up the \ncurrently rendered view hierarchy. If you want to handle the action in\na parent view, use the following:\n\n  1\n2\n3\n4\n\n  \u003cp\u003e\n  \u003cbutton {{action \"select\" post target=view.parentView}}\u003e✓\u003c/button\u003e\n  {{post.title}}\n\u003c/p\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"59c50884dd61207af6fc0a831825eb47","fields":[{"name":"title","value":"Binding Element Attributes","type":"string"},{"name":"url","value":"/templates/binding-element-attributes/","type":"enum"},{"name":"body","value":"In addition to normal text, you may also want to have your templates\ncontain HTML elements whose attributes are bound to the controller.\n\nFor example, imagine your controller has a property that contains a URL\nto an image:\n\n  1\n2\n3\n\n  \u003cdiv id=\"logo\"\u003e\n  \u003cimg {{bind-attr src=logoUrl}} alt=\"Logo\"\u003e\n\u003c/div\u003e\n\n\n\nThis generates the following HTML:\n\n  1\n2\n3\n\n  \u003cdiv id=\"logo\"\u003e\n  \u003cimg src=\"http://www.example.com/images/logo.png\" alt=\"Logo\"\u003e\n\u003c/div\u003e\n\n\n\nIf you use {{bind-attr}} with a Boolean value, it will add or remove\nthe specified attribute. For example, given this template:\n\n  1\n\n  \u003cinput type=\"checkbox\" {{bind-attr disabled=isAdministrator}}\u003e\n\n\n\nIf isAdministrator is true, Handlebars will produce the following\nHTML element:\n\n  1\n\n  \u003cinput type=\"checkbox\" disabled\u003e\n\n\n\nIf isAdministrator is false, Handlebars will produce the following:\n\n  1\n\n  \u003cinput type=\"checkbox\"\u003e\n\n\nAdding data attributes\nBy default, view helpers do not accept data attributes. For example\n\n  1\n2\n3\n\n  {{#link-to \"photos\" data-toggle=\"dropdown\"}}Photos{{/link-to}}\n\n{{input type=\"text\" data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"Name\"}}\n\n\n\nrenders the following HTML:\n\n  1\n2\n3\n\n  \u003ca id=\"ember239\" class=\"ember-view\" href=\"#/photos\"\u003ePhotos\u003c/a\u003e\n\n\u003cinput id=\"ember257\" class=\"ember-view ember-text-field\" type=\"text\" title=\"Name\"\u003e\n\n\n\nThere are two ways to enable support for data attributes. One way would be to add an \nattribute binding on the view, e.g. Ember.LinkView or Ember.TextField for the specific attribute:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  Ember.LinkView.reopen({\n  attributeBindings: ['data-toggle']\n});\n\nEmber.TextField.reopen({\n  attributeBindings: ['data-toggle', 'data-placement']\n});\n\n\n\nNow the same handlebars code above renders the following HTML:\n\n  1\n2\n3\n4\n\n  \u003ca id=\"ember240\" class=\"ember-view\" href=\"#/photos\" data-toggle=\"dropdown\"\u003ePhotos\u003c/a\u003e\n\n\u003cinput id=\"ember259\" class=\"ember-view ember-text-field\" \n       type=\"text\" data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"Name\"\u003e\n\n\n\nYou can also automatically bind data attributes on the base view with the\nfollowing:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  Ember.View.reopen({\n  init: function() {\n    this._super();\n    var self = this;\n\n    // bind attributes beginning with 'data-'\n    Em.keys(this).forEach(function(key) {\n      if (key.substr(0, 5) === 'data-') {\n        self.get('attributeBindings').pushObject(key);\n      }\n    });\n  }\n});\n\n\n\nNow you can add as many data-attributes as you want without having to specify them by name.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e478e22e0d1033f8572e38161a50bf9a","fields":[{"name":"title","value":"Binding Element Class Names","type":"string"},{"name":"url","value":"/templates/binding-element-class-names/","type":"enum"},{"name":"body","value":"An HTML element's class attribute can be bound like any other\nattribute:\n\n  1\n2\n3\n\n  \u003cdiv {{bind-attr class=\"priority\"}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIf the controller's priority property is \"p4\", this template will emit the following HTML:\n\n  1\n2\n3\n\n  \u003cdiv class=\"p4\"\u003e\n  Warning!\n\u003c/div\u003e\n\n\nBinding to Boolean Values\nIf the value to which you bind is a Boolean, Ember.js will apply the\ndasherized version of the property name as a class:\n\n  1\n2\n3\n\n  \u003cdiv {{bind-attr class=\"isUrgent\"}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIf isUrgent is true, this emits the following HTML:\n\n  1\n2\n3\n\n  \u003cdiv class=\"is-urgent\"\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIf isUrgent is false, no class name is added:\n\n  1\n2\n3\n\n  \u003cdiv\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIf you want to explicitly provide a class name (instead of Ember.js\ndasherizing the property name), use the following syntax:\n\n  1\n2\n3\n\n  \u003cdiv {{bind-attr class=\"isUrgent:urgent\"}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nInstead of the dasherized name, this will produce:\n\n  1\n2\n3\n\n  \u003cdiv class=\"urgent\"\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nYou can also specify a class name to add when the property is false:\n\n  1\n2\n3\n\n  \u003cdiv {{bind-attr class=\"isEnabled:enabled:disabled\"}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIn this case, if the isEnabled property is true, the enabled\nclass will be added. If the property is false, the class disabled\nwill be added.\n\nThis syntax can also be used to add a class if a property is false\nand remove it if the property is true, so this:\n\n  1\n2\n3\n\n  \u003cdiv {{bind-attr class=\"isEnabled::disabled\"}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nWill add the class disabled when isEnabled is false and add no\nclass if isEnabled is true.\nStatic Classes\nIf you need an element to have a combination of static and bound\nclasses, you should include the static class in the list of bound\nproperties, prefixed by a colon:\n\n  1\n2\n3\n\n  \u003cdiv {{bind-attr class=\":high-priority isUrgent\"}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nThis will add the literal high-priority class to the element:\n\n  1\n2\n3\n\n  \u003cdiv class=\"high-priority is-urgent\"\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nBound class names and static class names cannot be combined. The\nfollowing example will not work:\n\n  1\n2\n3\n\n  \u003cdiv class=\"high-priority\" {{bind-attr class=\"isUrgent\"}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\nBinding Multiple Classes\nUnlike other element attributes, you can bind multiple classes:\n\n  1\n2\n3\n\n  \u003cdiv {{bind-attr class=\"isUrgent priority\"}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nThis works how you would expect, applying the rules described above in\norder:\n\n  1\n2\n3\n\n  \u003cdiv class=\"is-urgent p4\"\u003e\n  Warning!\n\u003c/div\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"95d724148efe2cc1481ae51952ecf2b7","fields":[{"name":"title","value":"Conditionals","type":"string"},{"name":"url","value":"/templates/conditionals/","type":"enum"},{"name":"body","value":"Sometimes you may only want to display part of your template if a property\nexists.\n\nWe can use the {{#if}} helper to conditionally render a block:\n\n  1\n2\n3\n\n  {{#if person}}\n  Welcome back, \u003cb\u003e{{person.firstName}} {{person.lastName}}\u003c/b\u003e!\n{{/if}}\n\n\n\nHandlebars will not render the block if the argument passed evaluates to\nfalse, undefined, null or [] (i.e., any \"falsy\" value).\n\nIf the expression evaluates to falsy, we can also display an alternate template\nusing {{else}}:\n\n  1\n2\n3\n4\n5\n\n  {{#if person}}\n  Welcome back, \u003cb\u003e{{person.firstName}} {{person.lastName}}\u003c/b\u003e!\n{{else}}\n  Please log in.\n{{/if}}\n\n\n\nTo only render a block if a value is falsy, use {{#unless}}:\n\n  1\n2\n3\n\n  {{#unless hasPaid}}\n  You owe: ${{total}}\n{{/unless}}\n\n\n\n{{#if}} and {{#unless}} are examples of block expressions. These allow you\nto invoke a helper with a portion of your template. Block expressions look like\nnormal expressions except that they contain a hash (#) before the helper name,\nand require a closing expression.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a114533ff2793c31df860c375985bcb","fields":[{"name":"title","value":"Development Helpers","type":"string"},{"name":"url","value":"/templates/development-helpers/","type":"enum"},{"name":"body","value":"Development Helpers\nHandlebars and Ember come with a few helpers that can make developing your\ntemplates a bit easier. These helpers make it simple to output variables into\nyour browser's console, or activate the debugger from your templates.\nLogging\nThe {{log}} helper makes it easy to output variables or expressions in the\ncurrent rendering context into your browser's console:\n\n  1\n\n  {{log 'Name is:' name}}\n\n\n\nThe {{log}} helper also accepts primitive types such as strings or numbers.\nAdding a breakpoint\nThe {{debugger}} helper provides a handlebars equivalent to JavaScript's\ndebugger keyword.  It will halt execution inside the debugger helper and give\nyou the ability to inspect the current rendering context:\n\n  1\n\n  {{debugger}}\n\n\n\nJust before the helper is invoked two useful variables are defined:\n\n\ntemplateContext The current context that variables are fetched from. This\nis likely a controller.\ntypeOfTemplateContext A string describing what the templateContext is.\n\n\nFor example, if you are wondering why a specific variable isn't displaying in\nyour template, you could use the {{debugger}} helper. When the breakpoint is\nhit, you can use the templateContext in your console to lookup properties:\n\n  1\n2\n\n  \u003e templateContext.get('name')\n\"Bruce Lee\"\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"94f518795fa706013cfd0ed73c5a9d3c","fields":[{"name":"title","value":"Displaying a List of Items","type":"string"},{"name":"url","value":"/templates/displaying-a-list-of-items/","type":"enum"},{"name":"body","value":"If you need to enumerate over a list of objects, use Handlebars' {{#each}} helper:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each person in people}}\n    \u003cli\u003eHello, {{person.name}}!\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nThe template inside of the {{#each}} block will be repeated once for\neach item in the array, with the each item set to the person keyword.\n\nThe above example will print a list like this:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003eHello, Yehuda!\u003c/li\u003e\n  \u003cli\u003eHello, Tom!\u003c/li\u003e\n  \u003cli\u003eHello, Trek!\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\nLike everything in Handlebars, the {{#each}} helper is bindings-aware.\nIf your application adds a new item to the array, or removes an item,\nthe DOM will be updated without having to write any code.\n\nThe {{#each}} helper can have a matching {{else}}.\nThe contents of this block will render if the collection is empty:\n\n  1\n2\n3\n4\n5\n\n  {{#each person in people}}\n  Hello, {{person.name}}!\n{{else}}\n  Sorry, nobody is here.\n{{/each}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"619a7f1e4091d5852889772b71be63d0","fields":[{"name":"title","value":"Handlebars Basics","type":"string"},{"name":"url","value":"/templates/handlebars-basics/","type":"enum"},{"name":"body","value":"Ember.js uses the Handlebars templating library\nto power your app's user interface. Handlebars templates are just like\nregular HTML, but also give you the ability to embed expressions that\nchange what is displayed.\n\nWe take Handlebars and extend it with many powerful features. It may\nhelp to think of your Handlebars templates as an HTML-like DSL for\ndescribing the user interface of your app. And, once you've told\nEmber.js to render a given template on the screen, you don't need to\nwrite any additional code to make sure it keeps up-to-date.\n\nIf you'd prefer an indentation-based alternative to Handlebars syntax, \ntry Emblem.js, but make sure you're comfortable\nwith Handlebars first!\nDefining Templates\nIf you're not using build tools, you can define your application's main\ntemplate inside your HTML by putting it inside a \u003cscript\u003e tag, like so:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003chtml\u003e\n  \u003cbody\u003e\n    \u003cscript type=\"text/x-handlebars\"\u003e\n      Hello, \u003cstrong\u003e{{firstName}} {{lastName}}\u003c/strong\u003e!\n    \u003c/script\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n\n\n\nThis template will be compiled automatically and become your\napplication template,\nwhich will be displayed on the page when your app loads.\n\nYou can also define templates by name that can be used later. For\nexample, you may want to define a reusable control that is used in many\ndifferent places in your user interface. To tell Ember.js to save the\ntemplate for later, instead of displaying it immediately, you can add\nthe data-template-name attribute:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003chtml\u003e\n  \u003chead\u003e\n    \u003cscript type=\"text/x-handlebars\" data-template-name=\"say-hello\"\u003e\n      \u003cdiv class=\"my-cool-control\"\u003e{{name}}\u003c/div\u003e\n    \u003c/script\u003e\n  \u003c/head\u003e\n\u003c/html\u003e\n\n\n\nIf you are using build tools to manage your application's assets, most\nwill know how to precompile Handlebars templates and make them available\nto Ember.js.\nHandlebars Expressions\nEach template has an associated controller: this is where the template \nfinds the properties that it displays.\n\nYou can display a property from your controller by wrapping the property\nname in curly braces, like this:\n\n  1\n\n  Hello, \u003cstrong\u003e{{firstName}} {{lastName}}\u003c/strong\u003e!\n\n\n\nThis would look up the firstName and lastName properties from the\ncontroller, insert them into the HTML described in the template, then\nput them into the DOM.\n\nBy default, your top-most application template is bound to your ApplicationController:\n\n  1\n2\n3\n4\n\n  App.ApplicationController = Ember.Controller.extend({\n  firstName: \"Trek\",\n  lastName: \"Glowacki\"\n});\n\n\n\nThe above template and controller would combine to display the following\nrendered HTML:\n\n  1\n\n  Hello, \u003cstrong\u003eTrek Glowacki\u003c/strong\u003e!\n\n\n\nThese expressions (and the other Handlebars features you will learn\nabout next) are bindings aware. That means that if the values used\nby your templates ever change, your HTML will be updated automatically.\n\nAs your application grows in size, it will have many templates, each\nbound to different controllers.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"cbc42197752a02e932444274327e4808","fields":[{"name":"title","value":"Input Helpers","type":"string"},{"name":"url","value":"/templates/input-helpers/","type":"enum"},{"name":"body","value":"Input Helpers\nThe {{input}} and {{textarea}} helpers in Ember.js are the easiest way to\ncreate common form controls. The {{input}} helper wraps the built-in\nEmber.TextField and Ember.Checkbox views, while {{textarea}} wraps\nEmber.TextArea. Using these helpers, you can create these views with\ndeclarations almost identical to how you'd create a traditional \u003cinput\u003e or\n\u003ctextarea\u003e element.\nText fields\n  1\n\n  {{input value=\"http://www.facebook.com\"}}\n\n\n\nWill become:\n\n  1\n\n  \u003cinput type=\"text\" value=\"http://www.facebook.com\"/\u003e\n\n\n\nYou can pass the following standard \u003cinput\u003e attributes within the input\nhelper:\n\n\n  `readonly``required``autofocus`\n  `value``placeholder``disabled`\n  `size``tabindex``maxlength`\n  `name``min``max`\n  `pattern``accept``autocomplete`\n  `autosave``formaction``formenctype`\n  `formmethod``formnovalidate``formtarget`\n  `height``inputmode``multiple`\n  `step``width``form`\n  `selectionDirection``spellcheck` \n\n\nIf these attributes are set to a quoted string, their values will be set\ndirectly on the element, as in the previous example. However, when left\nunquoted, these values will be bound to a property on the template's current\nrendering context. For example:\n\n  1\n\n  {{input type=\"text\" value=firstName disabled=entryNotAllowed size=\"50\"}}\n\n\n\nWill bind the disabled attribute to the value of entryNotAllowed in the\ncurrent context.\nActions\nTo dispatch an action on specific events, such as enter or key-press, use the following\n\n  1\n\n  {{input value=firstName action=\"updateFirstName\" on=\"key-press\"}}\n\n\n\nEvent Names must be dasherized when assigned to on.\nCheckboxes\nYou can also use the {{input}} helper to create a checkbox by setting its\ntype:\n\n  1\n\n  {{input type=\"checkbox\" name=\"isAdmin\" checked=isAdmin}}\n\n\n\nCheckboxes support the following properties:\n\n\nchecked\ndisabled\ntabindex\nindeterminate\nname\nautofocus\nform\n\n\nWhich can be bound or set as described in the previous section.\nText Areas\n  1\n\n  {{textarea value=name cols=\"80\" rows=\"6\"}}\n\n\n\nWill bind the value of the text area to name on the current context.\n\n{{textarea}} supports binding and/or setting the following properties:\n\n\nvalue\nname\nrows\ncols\nplaceholder\ndisabled\nmaxlength\ntabindex\nselectionEnd\nselectionStart\nselectionDirection\nwrap\nreadonly\nautofocus\nform\nspellcheck\nrequired\n\nExtending Built-In Controls\nSee the Built-in Views section of these guides to learn how to further\nextend these views.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a3506f82f88ccbc90b445c4c8d73f39a","fields":[{"name":"title","value":"Links","type":"string"},{"name":"url","value":"/templates/links/","type":"enum"},{"name":"body","value":"The {{link-to}} Helper\nYou create a link to a route using the {{link-to}} helper.\n\n  1\n2\n3\n4\n5\n\n  App.Router.map(function() {\n  this.resource(\"photos\", function(){\n    this.route(\"edit\", { path: \"/:photo_id\" });\n  });\n});\n\n\n\n  1\n2\n3\n4\n5\n6\n7\n\n  {{! photos.handlebars }}\n\n\u003cul\u003e\n{{#each photo in photos}}\n  \u003cli\u003e{{#link-to 'photos.edit' photo}}{{photo.title}}{{/link-to}}\u003c/li\u003e\n{{/each}}\n\u003c/ul\u003e\n\n\n\nIf the model for the photos template is a list of three photos, the\nrendered HTML would look something like this:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003e\u003ca href=\"/photos/1\"\u003eHappy Kittens\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/2\"\u003ePuppy Running\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/3\"\u003eMountain Landscape\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\nWhen the rendered link matches the current route, and the same\nobject instance is passed into the helper, then the link is given\nclass=\"active\".\n\nThe {{link-to}} helper takes:\n\n\nThe name of a route. In this example, it would be index, photos, or\nphotos.edit.\nAt most one model for each dynamic segment.\nBy default, Ember.js will replace each segment with the value of the corresponding object's id property.\nIf there is no model to pass to the helper, you can provide an explicit identifier value instead.\nThe value will be filled into the dynamic segment\nof the route, and will make sure that the model hook is triggered.\nAn optional title which will be bound to the a title attribute\n\n\n  1\n2\n3\n4\n5\n\n  {{! photos.handlebars }}\n\n{{#link-to 'photo.edit' 1}}\n  First Photo Ever\n{{/link-to}}\n\n\nExample for Multiple Segments\nIf the route is nested, you can supply a model or an identifier for each dynamic\nsegment.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.Router.map(function() {\n  this.resource(\"photos\", function(){\n    this.resource(\"photo\", { path: \"/:photo_id\" }, function(){\n      this.route(\"comments\");\n      this.route(\"comment\", { path: \"/comments/:comment_id\" });\n    });\n  });\n});\n\n\n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003c!-- photoIndex.handlebars --\u003e\n\n\u003cdiv class=\"photo\"\u003e\n  {{body}}\n\u003c/div\u003e\n\n\u003cp\u003e{{#link-to 'photo.comment' primaryComment}}Main Comment{{/link-to}}\u003c/p\u003e\n\n\n\nIf you specify only one model, it will represent the innermost dynamic segment :comment_id.\nThe :photo_id segment will use the current photo.\n\nAlternatively, you could pass both a photo and a comment to the helper:\n\n  1\n2\n3\n4\n5\n\n  \u003cp\u003e\n  {{#link-to 'photo.comment' 5 primaryComment}}\n    Main Comment for the Next Photo\n  {{/link-to}}\n\u003c/p\u003e\n\n\n\nIn the above example, the model hook for PhotoRoute will run with params.photo_id = 5.  The model hook for\nCommentRoute won't run since you supplied a model object for the comment segment. The comment's id will\npopulate the url according to CommentRoute's serialize hook.\nUsing link-to as an inline helper\nIn addition to being used as a block expression, the link-to helper\ncan also be used in inline form by specifying the link text as the first\nargument to the helper:\n\n  1\n2\n\n  A link in {{#link-to 'index'}}Block Expression Form{{/link-to}},\nand a link in {{link-to 'Inline Form' 'index'}}.\n\n\n\nThe output of the above would be:\n\n  1\n2\n\n  A link in \u003ca href='/'\u003eBlock Expression Form\u003c/a\u003e,\nand a link in \u003ca href='/'\u003eInline Form\u003c/a\u003e.\n\n\nAdding additional attributes on a link\nWhen generating a link you might want to set additional attributes for it. You can do this with additional\narguments to the link-to helper:\n\n  1\n2\n3\n\n  \u003cp\u003e\n  {{link-to 'Edit this photo' 'photo.edit' photo class=\"btn btn-primary\"}}\n\u003c/p\u003e\n\n\n\nMany of the common HTML properties you would want to use like class, and rel will work. When\nadding class names, Ember will also apply the standard ember-view and possibly active class names.\nReplacing history entries\nThe default behavior for link-to is to add entries to the browser's history\nwhen transitioning between the routes. However, to replace the current entry in\nthe browser's history you can use the replace=true option:\n\n  1\n2\n3\n4\n5\n\n  \u003cp\u003e\n  {{#link-to 'photo.comment' 5 primaryComment replace=true}}\n    Main Comment for the Next Photo\n  {{/link-to}}\n\u003c/p\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"bc7ea295f86185ac867cf8954eef551a","fields":[{"name":"title","value":"Rendering with Helpers","type":"string"},{"name":"url","value":"/templates/rendering-with-helpers/","type":"enum"},{"name":"body","value":"Ember.js provides several helpers that allow you to render other views and templates in different ways.\nThe {{partial}} Helper\n{{partial}} takes the template to be rendered as an argument, and renders that template in place.\n\n{{partial}} does not change context or scope.  It simply drops the given template into place with the current scope.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  \u003cscript type=\"text/x-handlebars\" data-template-name='_author'\u003e\n  Written by {{author.firstName}} {{author.lastName}}\n\u003c/script\u003e\n\n\u003cscript type=\"text/x-handlebars\" data-template-name='post'\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cdiv\u003e{{body}}\u003c/div\u003e\n  {{partial \"author\"}}\n\u003c/script\u003e\n\n\n\n  1\n2\n3\n4\n5\n\n  \u003cdiv\u003e\n  \u003ch1\u003eWhy You Should Use Ember.JS\u003c/h1\u003e\n  \u003cdiv\u003eBecause it's awesome!\u003c/div\u003e\n  Written by Yehuda Katz\n\u003c/div\u003e\n\n\nThe {{view}} Helper\nThis helper works like the partial helper, except instead of providing a template to be rendered within the current template, you provide a view class.  The view controls what template is rendered.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  App.AuthorView = Ember.View.extend({\n  // We are setting templateName manually here to the default value\n  templateName: \"author\",\n\n  // A fullName property should probably go on App.Author,\n  // but we're doing it here for the example\n  fullName: (function() {\n    return this.get(\"author\").get(\"firstName\") + \" \" + this.get(\"author\").get(\"lastName\");\n  }).property(\"firstName\",\"lastName\")\n})\n\n\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  \u003cscript type=\"text/x-handlebars\" data-template-name='author'\u003e\n  Written by {{view.fullName}}\n\u003c/script\u003e\n\n\u003cscript type=\"text/x-handlebars\" data-template-name='post'\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cdiv\u003e{{body}}\u003c/div\u003e\n  {{view \"author\"}}\n\u003c/script\u003e\n\n\n\n  1\n2\n3\n4\n5\n\n  \u003cdiv\u003e\n  \u003ch1\u003eWhy You Should Use Ember.JS\u003c/h1\u003e\n  \u003cdiv\u003eBecause it's awesome!\u003c/div\u003e\n  Written by Yehuda Katz\n\u003c/div\u003e\n\n\n\nWhen using {{partial \"author\"}}:\n\n\nNo instance of App.AuthorView will be created\nThe given template will be rendered\n\n\nWhen using {{view \"author\"}}:\n\n\nAn instance of App.AuthorView will be created\nIt will be rendered here, using the template associated with that view (the default template being \"author\")\n\n\nFor more information, see Inserting Views in Templates\nThe {{render}} Helper\n{{render}} takes two parameters:\n\n\nThe first parameter describes the context to be setup\nThe optional second parameter is a model, which will be passed to the controller if provided\n\n\n{{render}} does several things:\n\n\nWhen no model is provided it gets the singleton instance of the corresponding controller\nWhen a model is provided it gets a unique instance of the corresponding controller\nRenders the named template using this controller\nSets the model of the corresponding controller\n\n\nModifying the post / author example slightly:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  \u003cscript type=\"text/x-handlebars\" data-template-name='author'\u003e\n  Written by {{firstName}} {{lastName}}.\n  Total Posts: {{postCount}}\n\u003c/script\u003e\n\n\u003cscript type=\"text/x-handlebars\" data-template-name='post'\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cdiv\u003e{{body}}\u003c/div\u003e\n  {{render \"author\" author}}\n\u003c/script\u003e\n\n\n\n  1\n2\n3\n4\n5\n\n  App.AuthorController = Ember.ObjectController.extend({\n  postCount: function() {\n    return this.get(\"model.posts.length\");\n  }.property(\"model.posts.[]\")\n})\n\n\n\nIn this example, render will:\n\n\nGet an instance of App.AuthorView if that class exists, otherwise uses a default generated view\nUse the corresponding template (in this case the default of \"author\")\nGet (or generate) the singleton instance of AuthorController\nSet the AuthorController's model to the 2nd argument passed to render, here the author field on the post\nRender the template in place, with the context created in the previous steps.\n\n\n{{render}} does not require the presence of a matching route.\n\n{{render}} is similar to {{outlet}}. Both tell Ember.js to devote this portion of the page to something.\n\n{{outlet}}: The router determines the route and sets up the appropriate controllers/views/models.\n{{render}}: You specify (directly and indirectly) the appropriate controllers/views/models.\n\nNote: {{render}} cannot be called multiple times for the same route when not specifying a model.\nComparison TableGeneral\n\n  \n  \n    Helper\n    Template\n    Model\n    View\n    Controller\n  \n  \n  \n  \n    {{partial}}\n    Specified Template\n    Current Model\n    Current View\n    Current Controller\n  \n  \n    {{view}}\n    View's Template\n    Current Model\n    Specified View\n    Current Controller\n  \n  \n    {{render}}\n    View's Template\n    Specified Model\n    Specified View\n    Specified Controller\n  \n  \n\nSpecific\n\n  \n  \n    Helper\n    Template\n    Model\n    View\n    Controller\n  \n  \n  \n  \n    {{partial \"author\"}}\n    author.hbs\n    Post\n    App.PostView\n    App.PostController\n  \n  \n    {{view \"author\"}}\n    author.hbs\n    Post\n    App.AuthorView\n    App.PostController\n  \n  \n    {{render \"author\" author}}\n    author.hbs\n    Author\n    App.AuthorView\n    App.AuthorController\n  \n  \n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b691fc4bca513d0a74056434e4d51519","fields":[{"name":"title","value":"The Application Template","type":"string"},{"name":"url","value":"/templates/the-application-template/","type":"enum"},{"name":"body","value":"The application template is the default template that is rendered when\nyour application starts. \n\nYou should put your header, footer, and any other decorative content\nhere. Additionally, you should have at least one {{outlet}}:\na placeholder that the router will fill in with the appropriate template,\nbased on the current URL.\n\nHere's an example template:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  \u003cheader\u003e\n  \u003ch1\u003eIgor's Blog\u003c/h1\u003e\n\u003c/header\u003e\n\n\u003cdiv\u003e\n  {{outlet}}\n\u003c/div\u003e\n\n\u003cfooter\u003e\n  \u0026copy;2013 Igor's Publishing, Inc.\n\u003c/footer\u003e\n\n\n\nThe header and footer will always be displayed on screen, but the\ncontents of the \u003cdiv\u003e will change depending on if the user is\ncurrently at /posts or /posts/15, for example.\n\nFor more information about how outlets are filled in by the router, see\nRouting.\n\nIf you are keeping your templates in HTML, create a \u003cscript\u003e tag\nwithout a template name. Ember will use the template without a name as the application template and it will automatically be compiled and appended\nto the screen.\n\n  1\n2\n3\n4\n5\n\n  \u003cscript type=\"text/x-handlebars\"\u003e\n  \u003cdiv\u003e\n    {{outlet}}\n  \u003c/div\u003e\n\u003c/script\u003e\n\n\n\nIf you're using build tools to load your templates, make sure you name\nthe template application.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4d51ca61c042a6e0f4dfd8e0cdb116ed","fields":[{"name":"title","value":"Writing Helpers","type":"string"},{"name":"url","value":"/templates/writing-helpers/","type":"enum"},{"name":"body","value":"Sometimes, you may use the same HTML in your application multiple times. In those cases, you can register a custom helper that can be invoked from any Handlebars template.\n\nFor example, imagine you are frequently wrapping certain values in a \u003cspan\u003e tag with a custom class. You can register a helper from your JavaScript like this:\n\n  1\n2\n3\n4\n\n  Ember.Handlebars.helper('highlight', function(value, options) {\n  var escaped = Handlebars.Utils.escapeExpression(value);\n  return new Ember.Handlebars.SafeString('\u003cspan class=\"highlight\"\u003e' + escaped + '\u003c/span\u003e');\n});\n\n\n\nIf you return HTML from a helper, and you don't want it to be escaped,\nmake sure to return a new SafeString. Make sure you first escape any\nuser data!\n\nAnywhere in your Handlebars templates, you can now invoke this helper:\n\n  1\n\n  {{highlight name}}\n\n\n\nand it will output the following:\n\n  1\n\n  \u003cspan class=\"highlight\"\u003ePeter\u003c/span\u003e\n\n\n\nIf the name property on the current context changes, Ember.js will\nautomatically execute the helper again and update the DOM with the new\nvalue.\nDependencies\nImagine you want to render the full name of an App.Person. In this\ncase, you will want to update the output if the person itself changes,\nor if the firstName or lastName properties change.\n\n  1\n2\n3\n\n  Ember.Handlebars.helper('fullName', function(person) {\n  return person.get('firstName') + ' ' + person.get('lastName');\n}, 'firstName', 'lastName');\n\n\n\nYou would use the helper like this:\n\n  1\n\n  {{fullName person}}\n\n\n\nNow, whenever the context's person changes, or when any of the\ndependent keys change, the output will automatically update.\n\nBoth the path passed to the fullName helper and its dependent keys may\nbe full property paths (e.g. person.address.country).\nCustom View Helpers\nYou may also find yourself rendering your view classes in multiple\nplaces using the {{view}} helper. In this case, you can save yourself\nsome typing by registering a custom view helper.\n\nFor example, let’s say you have a view called App.CalendarView.\nYou can register a helper like this:\n\n  1\n\n  Ember.Handlebars.helper('calendar', App.CalendarView);\n\n\n\nUsing App.CalendarView in a template then becomes as simple as:\n\n  1\n\n  {{calendar}}\n\n\n\nWhich is functionally equivalent to, and accepts all the same\narguments as:\n\n  1\n\n  {{view \"calendar\"}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d111ada688dff43a36c7d27aea287dc5","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/testing/","type":"enum"},{"name":"body","value":"Testing is a core part of the Ember framework and its development cycle.\n\nLet's assume you are writing an Ember application which will serve as a blog. \nThis application would likely include models such as user and post. It would \nalso include interactions such as login and create post. Let's finally \nassume that you would like to have automated tests in place for your application. \n\nThere are two different classifications of tests that you will need: \nIntegration and Unit.\nIntegration Tests\nIntegration tests are used to test user interaction and application flow. With \nthe example scenario above, some integration tests you might write are:\n\n\nA user is able to log in via the login form.\nA user is able to create a blog post.\nA visitor does not have access to the admin panel.\n\nUnit Tests\nUnit tests are used to test isolated chunks of functionality, or \"units\" without \nworrying about their dependencies. Some examples of unit tests for the scenario \nabove might be:\n\n\nA user has a role\nA user has a username\nA user has a fullname attribute which is the aggregate of its first and last \nnames with a space between\nA post has a title\nA post's title must be no longer than 50 characters\n\nTesting Frameworks\nQUnit is the default testing framework for this guide, but others are \nsupported through third-party adapters.\nContributing\nThe Ember testing guide provides best practices and examples on how to test your\nEmber applications. If you find any errors or believe the documentation can be\nimproved, please feel free to contribute.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"bcdf87ecce6b890f14b1c68c490ed7f5","fields":[{"name":"title","value":"Integration Tests","type":"string"},{"name":"url","value":"/testing/integration/","type":"enum"},{"name":"body","value":"Integration tests are generally used to test important workflows within your application. They emulate user interaction and confirm expected results.\nSetup\nIn order to integration test the Ember application, you need to run the app within your test framework. Set the root element of the application to an arbitrary element you know will exist. It is useful, as an aid to test-driven development, if the root element is visible while the tests run. You can potentially use #qunit-fixture, which is typically used to contain fixture html for use in tests, but you will need to override css to make it visible.\n\n  1\n\n  App.rootElement = '#arbitrary-element-to-contain-ember-application';\n\n\n\nThis hook defers the readiness of the application, so that you can start the app when your tests are ready to run. It also sets the router's location to 'none', so that the window's location will not be modified (preventing both accidental leaking of state between tests and interference with your testing framework).\n\n  1\n\n  App.setupForTesting();\n\n\n\nThis injects the test helpers into the window's scope.\n\n  1\n\n  App.injectTestHelpers();\n\n\n\nWith QUnit, setup and teardown functions can be defined in each test module's configuration. These functions are called for each test in the module. If you are using a framework other than QUnit, use the hook that is called before each individual test.\n\nAfter each test, reset the application: App.reset() completely resets the state of the application.\n\n  1\n2\n3\n4\n5\n\n  module('Integration Tests', {\n  teardown: function() {\n    App.reset();\n  }\n});\n\n\nTest adapters for other libraries\nIf you use a library other than QUnit, your test adapter will need to provide methods for asyncStart and asyncEnd. To facilitate asynchronous testing, the default test adapter for QUnit uses methods that QUnit provides: (globals) stop() and start().\n\nPlease note:\n\nThe ember-testing package is not included in the production builds, only development builds of Ember include the testing package. The package can be loaded in your dev or qa builds to facilitate testing your application. By not including the ember-testing package in production, your tests will not be executable in a production environment.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8339b4dfcf839b8409d37b5417877c11","fields":[{"name":"title","value":"Test Helpers","type":"string"},{"name":"url","value":"/testing/test-helpers/","type":"enum"},{"name":"body","value":"One of the major issues in testing web applications is that all code is\nevent-driven, therefore has the potential to be asynchronous (ie output can\nhappen out of sequence from input). This has the ramification that code can be\nexecuted in any order.\n\nAn example may help here: Let's say a user clicks two buttons, one after another\nand both load data from different servers. They take different times to respond.\n\nWhen writing your tests, you need to be keenly aware of the fact that you cannot\nbe sure that the response will return immediately after you make your requests,\ntherefore your assertion code (the \"tester\") needs to wait for the thing being\ntested (the \"testee\") to be in a synchronized state. In the example above, that\nwould be when both servers have responded and the test code can go about its\nbusiness checking the data (whether it is mock data, or real data).\n\nThis is why all Ember's test helpers are wrapped in code that ensures Ember is\nback in a synchronized state when it makes its assertions. It saves you from\nhaving to wrap everything in code that does that, and it makes it easier to read\nyour tests because there's less boilerplate in them.\n\nEmber includes several helpers to facilitate integration testing. There are two\ntypes of helpers: asynchronous and synchronous.\nAsynchronous Helpers\nAsynchronous helpers are \"aware\" of (and wait for) asynchronous behavior within\nyour application, making it much easier to write deterministic tests.\n\nAlso, these helpers register themselves in the order that you call them and will\nbe run in a chain; each one is only called after the previous one finishes, in a\nchain. You can rest assured, therefore, that the order you call them in will also\nbe their execution order, and that the previous helper has finished before the\nnext one starts.\n\n\nvisit(url)\n\n\nVisits the given route and returns a promise that fulfills when all resulting\nasync behavior is complete.\n\nfillIn(selector, text)\n\n\nFills in the selected input with the given text and returns a promise that\nfulfills when all resulting async behavior is complete.\n\nclick(selector)\n\n\nClicks an element and triggers any actions triggered by the element's click\nevent and returns a promise that fulfills when all resulting async behavior\nis complete.\n\nkeyEvent(selector, type, keyCode)\n\n\nSimulates a key event type, e.g. keypress, keydown, keyup with the\ndesired keyCode on element found by the selector.\n\ntriggerEvent(selector, type, options)\n\n\nTriggers the given event, e.g. blur, dblclick on the element identified\nby the provided selector.\n\n\nSynchronous Helpers\nSynchronous helpers are performed immediately when triggered.\n\n\nfind(selector, context)\n\n\nFinds an element within the app's root element and within the context\n(optional). Scoping to the root element is especially useful to avoid\nconflicts with the test framework's reporter, and this is done by default\nif the context is not specified.\n\ncurrentPath()\n\n\nReturns the current path.\n\ncurrentRouteName()\n\n\nReturns the currently active route name.\n\ncurrentURL()\n\n\nReturns the current URL.\n\n\nWait Helpers\nThe andThen helper will wait for all preceding asynchronous helpers to\ncomplete prior to progressing forward. Let's take a look at the following\nexample.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  test('simple test', function() {\n  expect(1); // Ensure that we will perform one assertion\n\n  visit('/posts/new');\n  fillIn('input.title', 'My new post');\n  click('button.submit');\n\n  // Wait for asynchronous helpers above to complete\n  andThen(function() {\n    equal(find('ul.posts li:last').text(), 'My new post');\n  });\n});\n\n\n\nFirst we tell qunit that this test should have one assertion made by the end \nof the test by calling expect with an argument of 1. We then visit the new\nposts URL \"/posts/new\", enter the text \"My new post\" into an input control\nwith the CSS class \"title\", and click on a button whose class is \"submit\".\n\nWe then make a call to the andThen helper which will wait for the preceding\nasynchronous test helpers to complete (specifically, andThen will only be\ncalled after the new posts URL was visited, the text filled in and the\nsubmit button was clicked, and the browser has returned from doing whatever\nthose actions required). Note andThen has a single argument of the function\nthat contains the code to execute after the other test helpers have finished.\n\nIn the andThen helper, we finally make our call to equal which makes an\nassertion that the text found in the last li of the ul whose class is \"posts\"\nis equal to \"My new post\".\nCustom Test Helpers\nEmber.Test.registerHelper and Ember.Test.registerAsyncHelper are used to\nregister test helpers that will be injected when App.injectTestHelpers is\ncalled. The difference between Ember.Test.registerHelper and\nEmber.Test.registerAsyncHelper is that the latter will not run until any\nprevious async helper has completed and any subsequent async helper will wait\nfor it to finish before running.\n\nThe helper method will always be called with the current Application as the\nfirst parameter. Helpers need to be registered prior to calling\nApp.injectTestHelpers().\n\nHere is an example of a non-async helper:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Ember.Test.registerHelper('shouldHaveElementWithCount',\n  function(app, selector, n, context) {\n    var el = findWithAssert(selector, context);\n    var count = el.length;\n    equal(n, count, 'found ' + count + ' times');\n  }\n);\n\n// shouldHaveElementWithCount(\"ul li\", 3);\n\n\n\nHere is an example of an async helper:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  Ember.Test.registerAsyncHelper('dblclick',\n  function(app, selector, context) {\n    var $el = findWithAssert(selector, context);\n    Ember.run(function() {\n      $el.dblclick();\n    });\n  }\n);\n\n// dblclick(\"#person-1\")\n\n\n\nAsync helpers also come in handy when you want to group interaction\ninto one helper. For example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Ember.Test.registerAsyncHelper('addContact',\n  function(app, name, context) {\n    fillIn('#name', name);\n    click('button.create');\n  }\n);\n\n// addContact(\"Bob\");\n// addContact(\"Dan\");\n\n\nExample\nHere is an example using both registerHelper and\nregisterAsyncHelper.\n\nCustom Test Helpers\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2de9a7cec028db6259a6c19e206a6306","fields":[{"name":"title","value":"Automating Tests with Runners","type":"string"},{"name":"url","value":"/testing/test-runners/","type":"enum"},{"name":"body","value":"When it comes to running your tests there are multiple approaches that you can take depending on what best suits your workflow. Finding a low friction method of running your tests is important because it is something that you will be doing quite often.\nThe Browser\nThe simplest way of running your tests is just opening a page in the browser. The following is how to put a test \"harness\" around your app with qunit so you can run tests against it:\n\nFirst, get a copy of qunit (both the JavaScript and the css) from here.\n\nNext, create an HTML file that includes qunit and its css that looks like the following example.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  \u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"utf-8\"\u003e\n  \u003ctitle\u003eQUnit Example\u003c/title\u003e\n  \u003clink rel=\"stylesheet\" href=\"qunit.css\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003cdiv id=\"qunit\"\u003e\u003c/div\u003e\n  \u003cdiv id=\"qunit-fixture\"\u003e\u003c/div\u003e\n  \u003cscript src=\"qunit.js\"\u003e\u003c/script\u003e\n  \u003cscript src=\"your_ember_code_here.js\"\u003e\u003c/script\u003e\n  \u003cscript src=\"your_test_code_here.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n\n\n\nFinally, launch your browser of choice and open the above html file.\n\nThat's it. You're done and your tests are running. No need to install and configure any other tools or have any other processes running. After adding or updating tests and/or code just reload the page and you're off to the races running your tests.\n\nIf that meets your needs, read no further. However, if you would like a more automated way of running your tests, read on.\n\nManually opening and refreshing a browser may prove to be a bit of a tedious workflow for you. While you get the benefit of knowing that your code (and your tests) work in every browser that you are able to launch, it's still up to you to do the launching (and then refreshing) each time you make a change. Getting rid of repetition is why we use computers, so this can be a problem.\n\nLuckily there are tools to help with this. These tools allow you to run your tests in actual browsers (yes browsers - as in more than one at the same time) and then report the results back to you in a consolidated view. These tools are run from the command line and they are also capable of automatically re-running tests when changes are made to files. They require a bit more setup than creating a simple html file but they will likely save time in the long run.\nThe Testem Runner\nTestem is a simple tool to setup and use. In a nutshell it will collect all of your application code, your test code, your testing framework of choice and build a test \"harness\" automatically.  It will then launch each browser (that you specify), run the tests and report the results back to you. It has a nice terminal-based user interface that will display test results for each browser. There are many features built into testem, but it does not seem to have any 3rd party plugins or extensions available.\n\nTo get started using testem, you'll need to install the testem node.js module. Assuming you have node installed, run the following command:\n\n  1\n\n  npm install -g --save-dev testem\n\n\n\nTestem is now available to run your tests. There is just a little bit of configuration that needs to be done first.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // testem.json\n{\n    \"framework\": \"qunit\",\n    \"src_files\": [\n      \"your_ember_code_here.js\",\n      \"your_test_code_here.js\"\n    ],\n    \"launch_in_dev\": [\"PhantomJS\"],\n    \"launch_in_ci\": [\"PhantomJS\"]\n}\n\n\n\nThat's it. Everything you need is installed and configured. Let's go over the configuration in more detail.\n\n\nframework\n\n\nThis represents the testing framework that you are going to be using. Qunit is what we are using in this example. Testem takes care of getting the qunit library loaded up so you don't have to worry about it.\n\nsrc_files\n\n\nThis represents which of your source files (including both production and test code) that you want testem to load when running tests.\n\nlaunch_in_dev\n\n\nThis allows you to configure which browsers to launch and run the tests. This can be one or more browsers. When multiple are specified your tests will run in all browsers concurrently.\n\nlaunch_in_ci\n\n\nThis allows you to configure which browsers to launch and run the tests in 'ci' mode. This is specifically geared towards continuous integration environments that may be headless.\n\n\n\nThere are plenty of other options that you can configure as well if you would like. To see a list of available options you can check out the testem documentation.\n\nTo start testem run the following command.\n\n  1\n\n  testem\n\n\n\nThis will start testem and launch all of your browsers listed in the launch_in_dev setting. A tabbed view, one tab for each browser listed, will appear that you can cycle through using the arrow keys to see the test results in each browser. There are other commands that you can use as well, run testem -h to see the list of all available commands in the tabbed view. Testem will continually run and re-run your tests when changes are made to your files listed in the src_files setting.\n\nThe launch_in_ci setting comes into play when you run testem with the following command.\n\n  1\n\n  testem ci\n\n\n\nMuch like running testem with no arguments, the ci option will use your same configuration except it will use the launch_in_ci rather than the launch_in_dev list of browsers. This ci option will also cause testem to run all of the tests once and exit printing the results to the terminal.\nThe Karma Test Runner\nKarma is another simple tool to setup and use. It is similar to testem in that it will collect all of your application code, your test code, your testing framework of choice and build a test \"harness\" automatically. It will then launch each browser (that you specify), run the tests and report the results back to you. The terminal user interface is not as fancy as testem, but there is a colored display of test results for each browser. Karma has many features as well as many plugins. For information about writing karma plugins checkout the docs. To find some available karma plugins start with karma_runner on github.\n\nTo get started using karma you will need to install a few node modules. Here is an example of a package.json file which includes everything that you will need to get started.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // package.json\n{\n  \"name\": \"your_project_name\",\n  \"version\": \"0.1.0\",\n  \"devDependencies\": {\n    \"karma-qunit\": \"0.1.1\",\n    \"karma-phantomjs-launcher\": \"0.1.2\",\n    \"karma\": \"0.12.1\"\n  }\n}\n\n\n\nThe three dependencies are karma itself, karma-qunit which includes everything that you will need to run qunit tests and karma-phantomjs-launcher which is what karma will use to fire up an instance of the headless PhantomJS browser to run your tests in. There are a number of different launchers that you can plug into the karma test runner including but not limited to Google Chrome, FireFox, Safari, IE, and even Sauce Labs. To see a complete list of all of the available launchers check out Karma's Github.\n\nNow that you've got a package.json containing everything that you will need to get started with karma run the following command (in the same directory as your package.json file) to download and install everything.\n\n  1\n\n  npm install\n\n\n\nKarma along with everything else that you need to start running your tests is now available. There is a little bit of configuration that needs to be done first. If you want to generate the default karma configuration you can run karma init and that will create a karma.conf.js file in your current directory. There are many configuration options available, so here's a pared down version: ie, the minimum configuration that Karma requires to run your tests.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  // karma.conf.js\nmodule.exports = function(config) {\n  config.set({\n    frameworks: ['qunit'],\n    files: [\n      'your_ember_code_here.js',\n      'your_test_code_here.js'\n    ],\n    autoWatch: true,\n    singleRun: true,\n    browsers: ['PhantomJS']\n  });\n};\n\n\n\nThere is one last thing that you need to install: Karma's command line interface.\n\n  1\n\n  npm install -g karma-cli\n\n\n\nThat's it. Everything you need is installed and configured. Let's go over the configuration in more detail.\n\n\nframeworks\n\n\nThis represents the testing frameworks that you're going to use. We're using QUnit in this example. Karma takes care of loading up the QUnit library for you.\n\nfiles\n\n\nThis represents which of your source files (including both production and test code) that you want karma to load when running tests.\n\nautoWatch\n\n\nA value of true will mean that karma will watch all of the files for changes and rerun the tests only when singleRun is false.\n\nsingleRun\n\n\nA value of true will run all of the tests one time and shut down, whereas a value of false will run all of your tests once, then wait for any files to change which will trigger re-running all your tests.\n\nbrowsers\n\n\nThis allows you to configure which browsers to launch and run the tests. This can be one or more browsers. When multiple are specified your tests will run in all browsers concurrently.\n\n\n\nThere are plenty of other options that you can configure as well if you would like. To see a list of available options you can check out the Karma documentation or instead of manually creating karma.conf.js you can run the following command.\n\n  1\n\n  karma init\n\n\n\nTo start karma run\n\n  1\n\n  karma start\n\n\n\nDepending on your configuration it will either run the tests and exit or run the tests and wait for file changes to run the tests again.\nBuild Integration\nBoth testem and karma are capable of being integrated into larger build processes. For example, you may be using CoffeeScript, ES6 or something else and need to transpile your source into JavaScript. If you happen to be using grunt you can use grunt-contrib-testem for testem or grunt-karma for karma integration into your existing build process. Both testem and karma have preprocessing configuration options available as well. For more information on other available configuration options see the docs for karma or testem.\nGenerating Reports\nOftentimes it's useful to get the results of your tests in different formats. For example, if you happen to use Jenkins as a ci server, you may want to get your test results in XML format so Jenkins can build some graphs of your test results over time. Also, you may want to measure your code coverage and have Jenkins track that over time as well. With these test runners, it's possible to generate reports from the results in various formats, as well as record other information such as code-test coverage, etc.\nXML Test Results from Testem\nTo get junit xml from the testem test runner you can simply add a flag to the command when you run testem and pipe the output to a file like the following command.\n\n  1\n\n  testem ci -R xunit \u003e test-results.xml\n\n\n\nThat's it! Now you can use test-results.xml to feed into another tool.\nXML Test Results from Karma\nTo get junit xml from the karma test runner you will need to install a new node.js module. You can do so with the following command.\n\n  1\n\n  npm install --save-dev karma-junit-reporter\n\n\n\nOnce that is done you will need to update your karma configuration to include the following.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  module.exports = function(config) {\n  config.set({\n    /* snip */\n    reporters: ['progress', 'junit'],\n    /* snip */\n  });\n};\n\n\n\nThe reporters option determines how your test results are communicated back to you. The progress reporter will display a line that says something like this.\n\n  1\n\n  PhantomJS 1.9.7 (Mac OS X): Executed 2 of 2 SUCCESS (0.008 secs / 0.002 secs)\n\n\n\nThe junit reporter will create an xml file called test-results.xml in the current directory that contains junit xml which can be used as input to other tools. This file can be renamed to whatever you would like. For more information see the docs for karma junit reporter.\nCode Coverage from Testem\nGetting coverage from testem is a bit more involved at the moment, though there is a way to do it. Check the testem docs for more information.\nCode Coverage from Karma\nTo measure your code coverage from the karma test runner you will need to install a new node.js module. You can do so with the following command.\n\n  1\n\n  npm install --save-dev karma-coverage\n\n\n\nOnce that's done you will need to update your karma configuration to include the following.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  module.exports = function(config) {\n  config.set({\n    /* snip */\n    reporters: ['progress', 'coverage'],\n    preprocessors: {\n      \"your_ember_code_here.js\": \"coverage\",\n      \"your_test_code_here.js\": \"coverage\"\n    },\n    coverageReporter: {\n        type: \"text\",\n    }\n    /* snip */\n  });\n};\n\n\n\nThat's it. Now, running karma normally will display code coverage information in the terminal. The coverageReporter.type option can be set to a number of different values. The value in the example, text, will only display to the console. Some other options are lcov, html and cobertura which can be used as input to other tools. For additional configuration options on coverage reporting from karma check out their docs.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a0e26dbd7878af23525081f7441c1b0","fields":[{"name":"title","value":"Testing Components","type":"string"},{"name":"url","value":"/testing/testing-components/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown \nin Unit Testing Basics because Ember.Component extends Ember.Object.\nSetup\nBefore testing components, be sure to add the testing application div to your testing html file:\n\n  1\n2\n\n  \u003c!-- as of time writing, ID attribute needs to be named exactly ember-testing --\u003e\n\u003cdiv id=\"ember-testing\"\u003e\u003c/div\u003e\n\n\n\nYou'll also need to tell Ember to use this element for rendering the application:\n\n  1\n\n  App.rootElement = '#ember-testing'\n\n\n\nYou can test components using the moduleForComponent helper. Testing this \nsimple Ember component:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.PrettyColorComponent = Ember.Component.extend({\n  classNames: ['pretty-color'],\n  attributeBindings: ['style'],\n  style: function() {\n    return 'color: ' + this.get('name') + ';';\n  }.property('name')\n});\n\n\n\n... with an accompanying Handlebars template:\n\n  1\n\n  Pretty Color: {{name}}\n\n\n\nUnit testing this component can be done using the moduleForComponent helper.\nThis helper will find the component by name (pretty-color) and its template (if\navailable).\n\n  1\n\n  moduleForComponent('pretty-color');\n\n\n\nNow each test following the moduleForComponent call has a subject() function,\nwhich aliases the create method on the component factory.\n\nWe can test to make sure that changing the component's color property updates\nthe rendered HTML:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  test('changing colors', function() {\n\n  // this.subject() is available because we used moduleForComponent\n  var component = this.subject();\n\n  // we wrap this with Ember.run because it is an async function\n  Ember.run(function() {\n    component.set('name','red');\n  });\n\n  // first call to $() renders the component.\n  equal(this.$().attr('style'), 'color: red;');\n\n  // another async function, so we need to wrap it with Ember.run\n  Ember.run(function() {\n    component.set('name', 'green');\n  });\n\n  equal(this.$().attr('style'), 'color: green;');\n});\n\n\n\nWe might also test this component to ensure the template is being \nrendered properly.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  test('template is rendered with the color name', function() {\n\n  // this.subject() is available because we used moduleForComponent\n  var component = this.subject();\n\n  // first call to $() renders the component.\n  equal($.trim(this.$().text()), 'Pretty Color:');\n\n  // we wrap this with Ember.run because it is an async function\n  Ember.run(function() {\n    component.set('name', 'green');\n  });\n\n  equal($.trim(this.$().text()), 'Pretty Color: green');\n});\n\n\nLive Example\nUnit Testing\nComponents\nInteracting with Components in the DOM\nEmber Components are a great way to create powerful, interactive, self-contained \ncustom HTML elements. Because of this, it is important to test the \ncomponent's methods and the user's interaction with the component.\n\nLet's look at a very simple component that simply sets its own\ntitle when clicked:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.MyFooComponent = Em.Component.extend({\n  title:'Hello World',\n\n  actions: {\n    updateTitle: function() {\n      this.set('title', 'Hello Ember World');\n    }\n  }\n});\n\n\n\nWe would use Integration Test Helpers to interact with the rendered component\nand test its behavior:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  moduleForComponent('my-foo', 'MyFooComponent');\n\ntest('clicking link updates the title', function() {\n  var component = this.subject();\n\n  // append the component to the DOM\n  this.append();\n\n  // assert default state\n  equal(find('h2').text(), 'Hello World');\n\n  // perform click action\n  click('button');\n\n  andThen(function() { // wait for async helpers to complete\n    equal(find('h2').text(), 'Hello Ember World');\n  });\n});\n\n\nLive Example\nUnit\nTesting Components\nComponents with embedded layout\nSome components do not use a separate template. Instead, the template is embedded\ninto the component via the layout property and inline HTML. For example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  App.MyFooComponent = Ember.Component.extend({\n\n  // layout supercedes template when rendered\n  layout: Ember.Handlebars.compile(\n    \"\u003ch2\u003eI'm a little {{noun}}\u003c/h2\u003e\u003cbr/\u003e\" +\n    \"\u003cbutton {{action 'changeName'}}\u003eClick Me\u003c/button\u003e\"\n  ),\n\n  noun: 'teapot',\n\n  actions: {\n    changeName: function() {\n      this.set('noun', 'embereño');\n    }\n  }\n});\n\n\n\nIn this example, we would still use Integration Test Helpers to\ntest a user's DOM interaction.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  moduleForComponent('my-foo', 'MyFooComponent');\n\ntest('clicking link updates the title', function() {\n  var component = this.subject();\n\n  // append the component to the DOM\n  this.append();\n\n  // assert default state\n  equal(find('h2').text(), \"I'm a little teapot\");\n\n  // perform click action\n  click('button');\n\n  andThen(function() { // wait for async helpers to complete\n    equal(find('h2').text(), \"I'm a little embereño\");\n  });\n});\n\n\nLive Example\nTesting\nComponents with Built-in Layout\nProgrammatically interacting with components\nAnother way we can test our components is to perform function calls directly\non the component instead of through DOM interaction. Let's use the same component\nexample from above, but perform the tests programatically:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  moduleForComponent('my-foo', 'MyFooComponent');\n\ntest('sending changeName message updates the title', function() {\n  var component = this.subject();\n\n  // append the component to the DOM, returns DOM instance\n  var $component = this.append();\n\n  // assert default state\n  equal($component.find('h2').text(), \"I'm a little teapot\");\n\n  // send action programmatically\n  Ember.run(function() {\n    component.send('changeName');\n  });\n\n  equal($component.find('h2').text(), \"I'm a little embereño\");\n});\n\n\nLive Example\nProgramatically\nTesting Components\nsendAction validation in components\nComponents often utilize sendAction, which is a way to interact with the Ember\napplication. Here's a simple component that sends the action internalAction\nwhen a button is clicked:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.MyFooComponent = Ember.Component.extend({\n  layout:Ember.Handlebars.compile(\"\u003cbutton {{action 'doSomething'}}\u003e\u003c/button\u003e\"),\n\n  actions: {\n    doSomething: function() {\n      this.sendAction('internalAction');\n    }\n  }\n});\n\n\n\nIn our test, we will create a test double (dummy object) that receives \nthe action being sent by the component.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n  moduleForComponent('my-foo', 'MyFooComponent');\n\ntest('trigger external action when button is clicked', function() {\n  // tell our test to expect 1 assertion\n  expect(1);\n\n  // component instance\n  var component = this.subject();\n\n  // component dom instance\n  var $component = this.append();\n\n  var targetObject = {\n    externalAction: function() {\n      // we have the assertion here which will be\n      // called when the action is triggered\n      ok(true, 'external Action was called!');\n    }\n  }; \n\n  // setup a fake external action to be called when \n  // button is clicked\n  component.set('internalAction', 'externalAction');\n\n  // set the targetObject to our dummy object (this\n  // is where sendAction will send its action to)\n  component.set('targetObject', targetObject);\n\n  // click the button\n  click('button');\n});\n\n\nLive Example\nsendAction\nValidation in Components\nComponents Using Other Components\nSometimes components are easier to maintain if they're broken up into parent and child\ncomponents. Here is a simple example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  App.MyAlbumComponent = Ember.Component.extend({\n  tagName: 'section',\n  layout: Ember.Handlebars.compile(\n      \"\u003csection\u003e\" +\n      \"  \u003ch3\u003e{{title}}\u003c/h3\u003e\" +\n      \"  {{yield}}\" +\n      \"\u003c/section\u003e\"\n  ),\n  titleBinding: ['title']\n});\n\nApp.MyKittenComponent = Ember.Component.extend({\n  tagName: 'img',\n  attributeBindings: ['width', 'height', 'src'],\n  src: function() {\n    return 'http://placekitten.com/' + this.get('width') + '/' + this.get('height');\n  }.property('width', 'height')\n});\n\n\n\nUsage of this component might look something like this:\n\n  1\n2\n3\n4\n5\n\n  {{#my-album title=\"Cats\"}}\n  {{my-kitten width=\"200\" height=\"300\"}}\n  {{my-kitten width=\"100\" height=\"100\"}}\n  {{my-kitten width=\"50\" height=\"50\"}}\n{{/my-album}}\n\n\n\nUsing the needs callback greatly simplifies testing components \nwith a parent-child relationship.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n  moduleForComponent('my-album', 'MyAlbumComponent', {\n  needs: ['component:my-kitten']\n});\n\ntest('renders kittens', function() {\n  expect(2);\n\n  // component instance\n  var component = this.subject({\n    title: 'Cats',\n    template: Ember.Handlebars.compile(\n      '{{my-kitten width=\"200\" height=\"300\"}}' +\n      '{{my-kitten width=\"100\" height=\"100\"}}' +\n      '{{my-kitten width=\"50\" height=\"50\"}}'\n    )\n  });\n\n  // append component to the dom\n  var $component = this.append();\n\n  // perform assertions\n  equal($component.find('h3:contains(\"Cats\")').length, 1);\n  equal($component.find('img').length, 3);\n});\n\n\nLive Example\nComponents\nwith Embedded Components\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b52674636f495b78ec905a98c63e1233","fields":[{"name":"title","value":"Testing Controllers","type":"string"},{"name":"url","value":"/testing/testing-controllers/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown \nin Unit Testing Basics because Ember.Controller extends Ember.Object.\n\nUnit testing controllers is very simple using the unit test helper \nmoduleFor which is part of the ember-qunit framework.\nTesting Controller Actions\nHere we have a controller PostsController with some computed properties and an \naction setProps.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  App.PostsController = Ember.ArrayController.extend({\n\n  propA: 'You need to write tests',\n  propB: 'And write one for me too',\n\n  setPropB: function(str) {\n    this.set('propB', str);\n  },\n\n  actions: {\n    setProps: function(str) {\n      this.set('propA', 'Testing is cool');\n      this.setPropB(str);\n    }\n  }\n});\n\n\n\nsetProps sets a property on the controller and also calls a method. To write a\ntest for this action, we would use the moduleFor helper to setup a test \ncontainer:\n\n  1\n\n  moduleFor('controller:posts', 'Posts Controller');\n\n\n\nNext we use this.subject() to get an instance of the PostsController and \nwrite a test to check the action. this.subject() is a helper method from the \nember-qunit library that returns a singleton instance of the module set up \nusing moduleFor.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  test('calling the action setProps updates props A and B', function() {\n  expect(4);\n\n  // get the controller instance\n  var ctrl = this.subject();\n\n  // check the properties before the action is triggered\n  equal(ctrl.get('propA'), 'You need to write tests');\n  equal(ctrl.get('propB'), 'And write one for me too');\n\n  // trigger the action on the controller by using the `send` method, \n  // passing in any params that our action may be expecting\n  ctrl.send('setProps', 'Testing Rocks!');\n\n  // finally we assert that our values have been updated \n  // by triggering our action.\n  equal(ctrl.get('propA'), 'Testing is cool');\n  equal(ctrl.get('propB'), 'Testing Rocks!');\n});\n\n\nLive Example\nUnit Testing\nControllers \"Actions\"\nTesting Controller Needs\nSometimes controllers have dependencies on other controllers. This is \naccomplished by using needs. For example, here are two simple controllers. The\nPostController is a dependency of the CommentsController:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.PostController = Ember.ObjectController.extend({\n  // ...\n});\n\nApp.CommentsController = Ember.ArrayController.extend({\n  needs: 'post',\n  title: Ember.computed.alias('controllers.post.title'),\n});\n\n\n\nThis time when we setup our moduleFor we need to pass an options object as\nour third argument that has the controller's needs.\n\n  1\n2\n3\n\n  moduleFor('controller:comments', 'Comments Controller', {\n  needs: ['controller:post']\n});\n\n\n\nNow let's write a test that sets a property on our post model in the \nPostController that would be available on the CommentsController.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n  test('modify the post', function() {\n  expect(2);\n\n  // grab an instance of `CommentsController` and `PostController`\n  var ctrl = this.subject(),\n      postCtrl = ctrl.get('controllers.post');\n\n  // wrap the test in the run loop because we are dealing with async functions\n  Ember.run(function() {\n\n    // set a generic model on the post controller\n    postCtrl.set('model', Ember.Object.create({ title: 'foo' }));\n\n    // check the values before we modify the post\n    equal(ctrl.get('title'), 'foo');\n\n    // modify the title of the post\n    postCtrl.get('model').set('title', 'bar');\n\n    // assert that the controllers title has changed\n    equal(ctrl.get('title'), 'bar');\n\n  });\n});\n\n\nLive Example\nUnit Testing Controllers \"Needs\"\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"cbcfe4192e61b1789eeb36d03367781d","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/testing/testing-handlebars-helpers/","type":"enum"},{"name":"body","value":"By the end of this document, the reader should understand:\n\n\n*** Special test helpers for testing handlebars helpers should be in place ***\nwhen they would want to test handlebars helpers individually\nhow to test handlebars helpers\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9e4b1c3650cd96bd8485e0b98d722871","fields":[{"name":"title","value":"Testing Models","type":"string"},{"name":"url","value":"/testing/testing-models/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown \nin Unit Testing Basics because DS.Model extends Ember.Object.\n\nEmber Data Models can be tested using the moduleForModel helper.\n\nLet's assume we have a Player model that has level and levelName \nattributes. We want to call levelUp() to increment the level and assign a \nnew levelName when the player reaches level 5.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  App.Player = DS.Model.extend({\n  level:     DS.attr('number', { defaultValue: 0 }),\n  levelName: DS.attr('string', { defaultValue: 'Noob' }),\n\n  levelUp: function() {\n    var newLevel = this.incrementProperty('level');\n    if (newLevel === 5) {\n      this.set('levelName', 'Professional');      \n    }\n  }\n});\n\n\n\nNow let's create a test which will call levelUp on the player when they are\nlevel 4 to assert that the levelName changes. We will use moduleForModel:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  moduleForModel('player', 'Player Model');\n\ntest('levelUp', function() {\n  // this.subject aliases the createRecord method on the model\n  var player = this.subject({ level: 4 });\n\n  // wrap asynchronous call in run loop\n  Ember.run(function() {\n    player.levelUp();\n  });\n\n  equal(player.get('level'), 5);\n  equal(player.get('levelName'), 'Professional');\n});\n\n\nLive Example\nUnit Testing\nEmber Data Models\nTesting Relationships\nFor relationships you probably only want to test that the relationship\ndeclarations are setup properly.\n\nAssume that a User can own a Profile.\n\n  1\n2\n3\n4\n5\n\n  App.Profile = DS.Model.extend({});\n\nApp.User = DS.Model.extend({\n  profile: DS.belongsTo('profile')\n});\n\n\n\nThen you could test that the relationship is wired up correctly\nwith this test.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  moduleForModel('user', 'User Model', {\n  needs: ['model:profile']\n});\n\ntest('profile relationship', function() {\n  var User = this.store().modelFor('user');\n  var relationship = Ember.get(User, 'relationshipsByName').get('profile');\n\n  equal(relationship.key, 'profile');\n  equal(relationship.kind, 'belongsTo');\n});\n\n\nLive Example\nUnit Testing Models (Relationships : One-to-One)\n\n\n\nEmber Data contains extensive tests around the functionality of\nrelationships, so you probably don't need to duplicate those tests.  You could\nlook at the Ember Data tests for examples of deeper relationship testing if you\nfeel the need to do it.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"50d7d9948190dd788cabc6f1e832ec60","fields":[{"name":"title","value":"Testing Routes","type":"string"},{"name":"url","value":"/testing/testing-routes/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown \nin Unit Testing Basics because Ember.Route extends Ember.Object.\n\nTesting routes can be done both via integration or unit tests. Integration tests \nwill likely provide better coverage for routes because routes are typically used \nto perform transitions and load data, both of which are tested more easily in \nfull context rather than isolation.\n\nThat being said, sometimes it is important to unit test your routes. For example, \nlet's say we'd like to have an alert that can be triggered from anywhere within \nour application. The alert function displayAlert should be put into the \nApplicationRoute because all actions and events bubble up to it from \nsub-routes, controllers and views.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  App.ApplicationRoute = Em.Route.extend({\n  actions: {\n    displayAlert: function(text) {\n      this._displayAlert(text);\n    }\n  },\n\n  _displayAlert: function(text) {\n    alert(text);\n  }\n});\n\n\n\nThis is made possible by using moduleFor.\n\nIn this route we've separated our concerns:\nThe action displayAlert contains the code that is called when the action is \nreceived, and the private function _displayAlert performs the work. While not \nnecessarily obvious here because of the small size of the functions, separating \ncode into smaller chunks (or \"concerns\"), allows it to be more readily isolated \nfor testing, which in turn allows you to catch bugs more easily.\n\nHere is an example of how to unit test this route:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n  \nmoduleFor('route:application', 'Unit: route/application', {\n  setup: function() {\n    originalAlert = window.alert; // store a reference to the window.alert\n  },\n  teardown: function() {\n    window.alert = originalAlert; // restore original functions\n  }\n});\n\ntest('Alert is called on displayAlert', function() {\n  expect(1);\n\n  // with moduleFor, the subject returns an instance of the route\n  var route = this.subject(),\n      expectedText = 'foo';\n\n  // stub window.alert to perform a qunit test\n  window.alert = function(text) {\n    equal(text, expectedText, 'expected ' + text + ' to be ' + expectedText);\n  }\n\n  // call the _displayAlert function which triggers the qunit test above\n  route._displayAlert(expectedText);\n});\n\n\nLive Example\nCustom Test Helpers\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8cbbc37817038e7af55d7494378a4c9f","fields":[{"name":"title","value":"Testing User Interaction","type":"string"},{"name":"url","value":"/testing/testing-user-interaction/","type":"enum"},{"name":"body","value":"Almost every test has a pattern of visiting a route, interacting with the page\n(using the helpers), and checking for expected changes in the DOM.\n\nExamples:\n\n  1\n2\n3\n4\n5\n6\n\n  test('root lists first page of posts', function(){\n  visit('/posts');\n  andThen(function() {\n    equal(find('ul.posts li').length, 3, 'The first page should have 3 posts');\n  });\n});\n\n\n\nThe helpers that perform actions use a global promise object and automatically\nchain onto that promise object if it exists. This allows you to write your tests\nwithout worrying about async behaviour your helper might trigger.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  module('Integration: Transitions', {\n  teardown: function() {\n    App.reset();\n  }\n});\n\ntest('add new post', function() {\n  visit('/posts/new');\n  fillIn('input.title', 'My new post');\n  click('button.submit');\n\n  andThen(function() {\n    equal(find('ul.posts li:last').text(), 'My new post');\n  });\n});\n\n\nLive Example\nTesting User\nInteraction\nTesting Transitions\nSuppose we have an application which requires authentication. When a visitor\nvisits a certain URL as an unauthenticated user, we expect them to be transitioned\nto a login page.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.ProfileRoute = Ember.Route.extend({\n  beforeModel: function() {\n    var user = this.modelFor('application');\n    if (Em.isEmpty(user)) {\n      this.transitionTo('login');\n    }\n  }\n});\n\n\n\nWe could use the route helpers to ensure that the user would be redirected to the login page\nwhen the restricted URL is visited.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  module('Integration: Transitions', {\n  teardown: function() {\n    App.reset();\n  }\n});\n\ntest('redirect to login if not authenticated', function() {\n  visit('/');\n  click('.profile');\n\n  andThen(function() {\n    equal(currentRouteName(), 'login');\n    equal(currentPath(), 'login');\n    equal(currentURL(), '/login');\n  });\n});\n\n\nLive Example\nTesting Transitions\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b1f1b40052089184a7778e00f7889079","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/testing/testing-views/","type":"enum"},{"name":"body","value":"By the end of this document, the reader should understand:\n\n\nwhen and when not to test views (unit vs integration)\nhow to test views (integration)\nhow to test views (unit)\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"72508d70501c4e8539a09fa62fbdde89","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/testing/testing-xhr/","type":"enum"},{"name":"body","value":"Testing with asynchronous calls and promises in Ember may seem tricky at first, but with a little explanation things should become clearer.\nPromises, Ember and the Run Loop\nIn order to fully explain testing promises \u0026 asynchronous code, it's important that you have a clear grasp of the Ember run loop. If you haven't yet done so, please read about them in the Promises and Understanding Ember run loop guide.\n\nNow that you grasp the general concepts regarding the run loop, recall from reading about the basics of testing Ember applications that the run loop is suspended when in testing mode.  This helps ensure the procedure of your code and the tests you write around that code. Note that in testing promises and asynchronous code, you're effectively \"stepping through\" your application in chunks.\n\nWhen a promise runs, it schedules fulfillment/rejection to be executed by the run loop, therefore in order for promises to work the run loop must be on. In short: no run loop, no promise fulfillment/rejection.\n\nGetting the results of a promise requires you to use the then method. Calling the then function on an existing promise:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // let's call the existing promise promise1, so you'd write:\npromise1.then(fulfillmentCallback, rejectionCallback);\n\nfunction fulfillmentCallback(successfulResults) {\n  // do something wonderful with the results\n}\n\nfunction rejectionCallback(failureResults) {\n  // tell someone important about the failure\n}\n\n\n\nIn the case that promise1 succeeds, then the fulfillmentCallback function will be called and passed the successful results of promise1 as its argument. If the promise rejects (ie failure), then the rejectionCallback will be called with the failure reason as its argument.\n\nIf you pass in a function to then it casts the function into a promise and returns the promise.  The results of that promise will be what's returned from the function.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n  // let's call the existing promise promise1 and will have the result `3`, so you'd write:\nvar promise2 = promise1.then(function(results){\n  return results + 2;\n});\n\n// the results of this promise would be 10\nvar promise3a = promise2.then(function(results){\n  return results + 5;\n});\n\n// the results of this promise would be 6\nvar promise3b = promise2.then(function(results){\n return results + 1;\n});\n\n// or we can chain without the intermediary variables like so,\nvar promise4 = promise1.then(function(results){\n  return results + 2;\n}).then(function(results){\n  return results + 5;\n}).then(function(results){\n  return results + 90;\n}).then(function(results){\n  alert(results); // this will alert `100`\n});\n\n\n\nIf you pass a promise into then it will return the results of that promise.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  // let's call the existing promises promise1 and promise2, so you'd write:\nvar promise3 = promise1.then(promise2);\n\npromise3.then(function(result){\n  // this will be the results from promise2\n  // this callback won't be called until promise1 and promise2 have fulfilled\n  alert(result);\n});\n\n\n\n**None of this will work if the run loop isn't running due to these callbacks and/or chained promises getting scheduled on the run loop.  **\nWhere the run loop and Promises intersectPromise Resolution\n  1\n2\n3\n4\n5\n\n  var promise = new Ember.RSVP.Promise(function(resolve){\n  // calling resolve will schedule an action to fulfill the promise \n  // and call observers/chained promises.\n  resolve('hello world'); // Run loop needs to be on here\n});\n\n\nChaining/Observing Promises\n  1\n2\n3\n4\n5\n\n  // once the above promise has been resolved it will then notify \n// the observers/chained promises to.\npromise.then(function(result){  // Run loop might* need to be on here\n  alert(result);\n});\n\n\n\n\nCalling then (observing/chaining) only needs to be implicitely wrapped in a run call statement (eg Ember.run(...)) if there is a possibility you will chain/observe the promise after it's been fulfilled.  See the examples below which will help explain the different scenarios.\n\nWalk through example of observing/chaining before the promise has fulfilled\n\nRun loop is off (testing mode)\nCode: Create Promise1 (new Ember.RSVP.Promise....)\nCode: Observe Promise1 (promise.then(....))\nCode: Begin run loop (this will only finish once the run loop has cleared out all of the scheduled items)\nCode: Resolve Promise1 (this will scheduled a task in the run loop to fulfill the promise)\nRun loop: run \"fulfill the promise\" task (which includes notifying all chained promises/observers of fulfillment)\nRun loop is off since there are no more tasks\n\n\n  1\n2\n3\n4\n5\n6\n\n  new Ember.RSVP.Promise(function(resolve){\n  // resolve will run ~10 ms after the then has been called and is observing\n  Ember.run.later(this, resolve, 'hello', 10);\n}).then(function(result){\n  alert(result);\n});\n\n\nWalk through example of observing/chaining after the promise has fulfilled\n\nRun loop is off (testing mode)\nCode: Create Promise1\nCode: Begin run loop (this will finish once all scheduled tasks have been executed)\nCode: Resolve Promise1 (this will add a scheduled task to fulfill the promise)\nRun loop: run \"fulfill the promise\" task (which includes notifying all chained promises/observers of fulfillment)\nRun loop is off since there are no more tasks\nCode: Observe Promise1 (since the promise has already fulfilled, schedule an async task to notify this observer of fulfillment)\nUncaught Error: Assertion Failed: You have turned on testing mode, which disabled the run-loop's autorun. You will need to wrap any code with asynchronous side-effects in an Ember.run\n\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  var promise = new Ember.RSVP.Promise(function(resolve){\n  // this will run before the then has happened below\n  // and finish the triggered run loop\n  Ember.run(this, resolve, 'hello');\n});\n\n// incorrect the run loop isn't on any more\npromise.then(function(result){\n  alert(result);\n});\n\n// correct, start the run loop again\nEmber.run(function(){\n  promise.then(function(result){\n    alert(result);\n  });\n});\n\n\nTesting promises and the run loop\nWhen you are using Ember normally (ie when not in testing mode), the run loop is actively running, so you don't need to worry about wrapping these events in calls to Ember.run(). In testing mode, the run loop is passive and must be triggered manually.  Testing asynchronous code not wrapped in calls to Ember.run will result in the error: Uncaught Error: Assertion Failed: You have turned on testing mode, which disabled the run-loop's autorun. You will need to wrap any code with asynchronous side-effects in an Ember.run.\nGeneral Example\nHere we are setting up a promise, and intentionally using setTimeout to mimic a delayed response from a fake server.  Once our fake server has responded we need to invoke the run loop manually, by wrapping the statement in a run call.\n\n  1\n2\n3\n4\n5\n\n  var promise = new Ember.RSVP.Promise(function(resolve){\n  setTimeout(function(){\n    Ember.run(this, resolve, 'hello world');\n  }, 20);\n});\n\n\n\nIf you were to pass the above promise around to multiple methods, and they choose to observe/chain to the promise, it is likely that at some point the promise may already be resolved.  In that case you will need to wrap the observer/chained promise in a run call.\n\n  1\n2\n3\n4\n5\n\n  Ember.run(function(){\n  promise.then(function(result){\n    alert(result);\n  });\n});\n\n\nSynchronous Example using promises\nIf you're using a promise, but it resolves immediately then you can simply follow the pattern above of wrapping the resolve and observer/chained promises in a run call without harm.  In this example we wrap the resolve and the observer (due to the promise resolving immediately) in a run call.\n\n\n\nSimple promise example\nAsynchronous Example using promises\nIf you're using a promise, but there's a chance it might resolves after the test would finish you'll need to use the stop and start global qunit methods.  These methods will give you the ability to tell qunit to stop the test run on the current test (makes qunit wait) and start again when ready.  In this example we delay execution and wrap the resolve in a run call.  Since the chained promise begins observing before the promise has been resolved you won't need to wrap  the chained promise in a run call.\n\nAsync promise example\nAJAX\nAJAX requests are the most prevelant use case where you will be creating promises.  While testing it's likely you will want to mock your AJAX requests to the server.  Below we've included examples for ic-ajax. Feel free to use other mocking libraries such as Mockjax, but it's important to note, that Mockjax and other libraries are unaware of the run loop and won't wrap their resolve in a run call.  This may resolve in promises being run outside the realm of the run loop and will result in errors.\nic-ajax\n[ic-ajax] is an Ember-friendly jQuery-ajax wrapper, which is very convenient for building up fixture data and mocking ajax calls for unit/integration testing. The most common use case for promises is when you're making an asynchronous call to a server, and ic-ajax can help alleviate having to worry about wrapping resolve in a run call.\nSimple ic-ajax example:\nImagine you wanted to request a list of colors from a server.  Using ic-ajax you would use the following syntax\n\n  1\n\n  var promise = ic.ajax.request('/colors');\n\n\n\nThis is an asynchronous call which returns a promise. When the promise has resolved, it will contain the list of colors. The convenient thing about ic-ajax is that it wraps the resolve of your ajax call in a call to Ember.run so you don't need to worry about it. We're going to set up some fixture data that can be returned instead of making an ajax call to fake the server so we can test our code\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  ic.ajax.defineFixture('/colors', {\n  response: [\n    {\n      id: 1,\n      color: \"red\"\n    },\n    {\n      id: 2,\n      color: \"green\"\n    },\n    {\n      id: 3,\n      color: \"blue\"\n    }\n  ],\n  jqXHR: {},\n  textStatus: 'success'\n});\n\n\n\nUsing ic-ajax\nSimple ic-ajax example with Ember Data:\nEmber Data can be dealt with just as easily, you will just need to define the fixtures in the same format that Ember Data is expecting it.\n\nUsing ic-ajax\nIntegration test using ic-ajax and Ember Data\nOften while doing integration tests, you don't actually want to hit the server because its state won't be consistent. Using the previously established patterns you can set up fixture data which will be returned in place of real ajax call responses so you can isolate your code as being the only thing under test. Below we'e provided you with a simple example test using ic-ajax and Ember Data.\n\nUsing ic-ajax\njquery-mockjax\njquery-mockjax is a jQuery plugin that provides the ability to simulate ajax requests.\nSimple jquery-mockjax example:\nImagine you wanted to request a list of colors from a server.  Using vanilla jQuery you would use the following syntax\n\n  1\n\n  $.getJSON('/colors', function(response){ /* ... */ });\n\n\n\nThis is an asynchronous call which will pass the server's response to the callback provided. Unlike ic-ajax, with vanilla jQuery you need to wrap the callback syntax in a promise.\n\n  1\n2\n3\n4\n5\n\n  var promise = new Ember.RSVP.Promise(function(resolve){\n  $.getJSON('/colors', function(data){\n    resolve(data.response);\n  });\n});\n\n\n\nWe're going to set up some fixture data that can be returned instead of making an ajax call to fake the server so we can test our code\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n  $.mockjax({\n  type: 'GET',\n  url: '/colors',\n  status: '200',\n  dataType: 'json',\n  responseText: {\n    response: [\n      {\n        id: 1,\n        color: \"red\"\n      },\n      {\n        id: 2,\n        color: \"green\"\n      },\n      {\n        id: 3,\n        color: \"blue\"\n      }\n     ]\n  }\n});\n\n\n\nAs you can see, there is a lot of flexibility in the jquery-mockjax api. You can specify not only the url and the response but the method, status code and data type. For the full jquery-mockax api check their docs.\n\nUsing jquery-mockjax\nSimple jquery-mockjax example with Ember Data:\nEmber Data can be dealt with just as easily. You will just need to define the fixtures in the format that Ember Data is expecting.\n\nUsing jquery-mockjax\nIntegration test using jquery-mockjax and Ember Data\nOften while writing integration tests, you don't actually want to hit the server because its state won't be consistent. Using the previously established patterns you can set up fixture data which will be returned in place of real ajax call responses so you can isolate your code as being the only thing under test. Below we've provided you with a simple example test using jquery-mockjax and Ember Data.\n\nUsing jquery-mockjax\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"1ce450bb46bb44d1336b990817414fae","fields":[{"name":"title","value":"Unit Test Helpers","type":"string"},{"name":"url","value":"/testing/unit-test-helpers/","type":"enum"},{"name":"body","value":"Globals vs Modules\nIn the past, it has been difficult to test portions of your Ember application\nwithout loading the entire app as a global. By having your application written\nusing modules (CommonJS, AMD, etc), you are able to require just code that\nis to be tested without having to pluck the pieces out of your global\napplication.\nUnit Testing Helpers\nEmber-QUnit is the default unit testing helper suite for Ember. It can and\nshould be used as a template for other test framework helpers. It uses your\napplication's resolver to find and automatically create test subjects for you\nusing the moduleFor and test helpers.\n\nA test subject is simply an instance of the object that a particular test is\nmaking assertions about. Usually test subjects are manually created by the\nwriter of the test.\n\n\n\nThe unit testing section of this guide will use the Ember-QUnit library, but\nthe concepts and examples should translate easily to other frameworks.\nAvailable Helpers\nBy including Ember-QUnit, you will have access to a number of test helpers.\n\n\nmoduleFor(fullName [, description [, callbacks]])\n\n\nfullName: The full name of the unit, (ie. controller:application,\nroute:index, etc.)\ndescription: the description of the module\ncallbacks: normal QUnit callbacks (setup and teardown), with addition to\nneeds, which allows you specify the other units the tests will need.\n\nmoduleForComponent(name [, description [, callbacks]])\n\n\nname: the short name of the component that you'd use in a template, (ie.\nx-foo, ic-tabs, etc.)\ndescription: the description of the module\ncallbacks: normal QUnit callbacks (setup and teardown), with addition to\nneeds, which allows you specify the other units the tests will need.\n\nmoduleForModel(name [, description [, callbacks]])\n\n\nname: the short name of the model you'd use in store\noperations (ie. user, assignmentGroup, etc.)\ndescription: the description of the module\ncallbacks: normal QUnit callbacks (setup and teardown), with addition to\nneeds, which allows you specify the other units the tests will need.\n\ntest\n\n\nSame as QUnit test except it includes the subject function which is used\nto create the test subject.\n\nsetResolver\n\n\nSets the resolver which will be used to lookup objects from the application\ncontainer.\n\n\nUnit Testing Setup\nIn order to unit test your Ember application, you need to let Ember know it is in\ntest mode. To do so, you must call Ember.setupForTesting().\n\n  1\n\n  Ember.setupForTesting();\n\n\n\nThe setupForTesting() function call makes ember turn off its automatic run\nloop execution. This gives us an ability to control the flow of the run loop\nourselves, to a degree. Its default behaviour of resolving all promises and\ncompleting all async behaviour are suspended to give you a chance to set up\nstate and make assertions in a known state. In other words, you know that if you\nrun \"visit\" to get to a particular URL, you can be sure the URL has been visited\nand that's the only behaviour that has transpired. If we didn't use this mode,\nour assertions would most likely be executed before the async behaviour had taken place, so\nour assertion results would be unpredictable.\n\nWith a module-based application, you have access to the unit test helpers simply\nby requiring the exports of the module. However, if you are testing a global\nEmber application, you are still able to use the unit test helpers. Instead of\nimporting the ember-qunit module, you need to make the unit test helpers\nglobal with emq.globalize():\n\n  1\n\n  emq.globalize();\n\n\n\nThis will make the above helpers available globally.\nThe Resolver\nThe Ember resolver plays a huge role when unit testing your application. It\nprovides the lookup functionality based on name, such as route:index or\nmodel:post.\n\nIf you do not have a custom resolver or are testing a global Ember application,\nthe resolver should be set like this:\n\nMake sure to replace \"App\" with your application's namespace in the following line\n\n  1\n\n  setResolver(Ember.DefaultResolver.create({ namespace: App }))\n\n\n\nOtherwise, you would require the custom resolver and pass it to setResolver\nlike this (ES6 example):\n\n  1\n2\n3\n\n  import Resolver from './path/to/resolver';\nimport { setResolver } from 'ember-qunit';\nsetResolver(Resolver.create());\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8da16330e9a3a38299664dcc2f2233af","fields":[{"name":"title","value":"Unit Testing Basics","type":"string"},{"name":"url","value":"/testing/unit-testing-basics/","type":"enum"},{"name":"body","value":"Unit tests are generally used to test a small piece of code and ensure that it\nis doing what was intended. Unlike integration tests, they are narrow in scope\nand do not require the Ember application to be running.\n\nAs it is the basic object type in Ember, being able to test a simple\nEmber.Object sets the foundation for testing more specific parts of your\nEmber application such as controllers, components, etc. Testing an Ember.Object\nis as simple as creating an instance of the object, setting its state, and\nrunning assertions against the object. By way of example lets look at a few\ncommon cases.\nTesting Computed Properties\nLet's start by looking at an object that has a computedFoo computed property\nbased on a foo property.\n\n  1\n2\n3\n4\n5\n6\n\n  App.SomeThing = Ember.Object.extend({\n  foo: 'bar',\n  computedFoo: function(){\n    return 'computed ' + this.get('foo');\n  }.property('foo')\n});\n\n\n\nWithin the test we'll create an instance, update the foo property (which\nshould trigger the computed property), and assert that the logic in our\ncomputed property is working correctly.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  module('Unit: SomeThing');\n\ntest('computedFoo correctly concats foo', function() {\n  var someThing = App.SomeThing.create();\n  someThing.set('foo', 'baz');\n  equal(someThing.get('computedFoo'), 'computed baz');\n});\n\n\nLive Example\nUnit Testing\nBasics: Computed Properties\nTesting Object Methods\nNext let's look at testing logic found within an object's method. In this case\nthe testMethod method alters some internal state of the object (by updating\nthe foo property).\n\n  1\n2\n3\n4\n5\n6\n\n  App.SomeThing = Ember.Object.extend({\n  foo: 'bar',\n  testMethod: function() {\n    this.set('foo', 'baz');\n  }\n});\n\n\n\nTo test it, we create an instance of our class SomeThing as defined above, \ncall the testMethod method and assert that the internal state is correct as a \nresult of the method call.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  module('Unit: SomeThing');\n\ntest('calling testMethod updates foo', function() {\n  var someThing = App.SomeThing.create();\n  someThing.testMethod();\n  equal(someThing.get('foo'), 'baz');\n});\n\n\nLive Example\nUnit Testing\nBasics: Method Side Effects\n\nIn the event the object's method returns a value you can simply assert that the\nreturn value is calculated correctly. Suppose our object has a calc method\nthat returns a value based on some internal state.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.SomeThing = Ember.Object.extend({\n  count: 0,\n  calc: function() {\n    this.incrementProperty('count');\n    return 'count: ' + this.get('count');\n  }\n});\n\n\n\nThe test would call the calc method and assert it gets back the correct value.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  module('Unit: SomeThing');\n\ntest('testMethod returns incremented count', function() {\n  var someThing = App.SomeThing.create();\n  equal(someThing.calc(), 'count: 1');\n  equal(someThing.calc(), 'count: 2');\n});\n\n\nLive Example\nUnit Testing\nBasics: Method Side Effects\nTesting Observers\nSuppose we have an object that has a property and a method observing that property.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.SomeThing = Ember.Object.extend({\n  foo: 'bar',\n  other: 'no',\n  doSomething: function(){\n    this.set('other', 'yes');\n  }.observes('foo')\n});\n\n\n\nIn order to test the doSomething method we create an instance of SomeThing,\nupdate the observed property (foo), and assert that the expected effects are present.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  module('Unit: SomeThing');\n\ntest('doSomething observer sets other prop', function() {\n  var someThing = App.SomeThing.create();\n  someThing.set('foo', 'baz');\n  equal(someThing.get('other'), 'yes');\n});\n\n\nLive Example\nUnit Testing Basics: Observers\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ee5ea607aecd946ab8c953297847e0b8","fields":[{"name":"title","value":"Debugging","type":"string"},{"name":"url","value":"/understanding-ember/debugging/","type":"enum"},{"name":"body","value":"Debugging Ember and Ember Data\nHere are some tips you can use to help debug your Ember application.\n\nAlso, check out the\nember-extension\nproject, which adds an Ember tab to Chrome DevTools that allows you\nto inspect Ember objects in your application.\nRoutingLog router transitions\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  window.App = Ember.Application.create({\n  // Basic logging, e.g. \"Transitioned into 'post'\"\n  LOG_TRANSITIONS: true, \n\n  // Extremely detailed logging, highlighting every internal\n  // step made while transitioning into a route, including\n  // `beforeModel`, `model`, and `afterModel` hooks, and\n  // information about redirects and aborted transitions\n  LOG_TRANSITIONS_INTERNAL: true\n});\n\n\nView all registered routes\n  1\n\n  Ember.keys(App.Router.router.recognizer.names)\n\n\nGet current route name / path\nEmber installs the current route name and path on your\napp's ApplicationController as the properties\ncurrentRouteName and currentPath. currentRouteName's\nvalue (e.g. \"comments.edit\") can be used as the destination parameter of \ntransitionTo and the {{linkTo}} Handlebars helper, while \ncurrentPath serves as a full descriptor of each\nparent route that has been entered (e.g.\n\"admin.posts.show.comments.edit\").\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  // From within a Route\nthis.controllerFor(\"application\").get(\"currentRouteName\");\nthis.controllerFor(\"application\").get(\"currentPath\");\n\n// From within a controller, after specifying `needs: ['application']`\nthis.get('controllers.application.currentRouteName');\nthis.get('controllers.application.currentPath');\n\n// From the console:\nApp.__container__.lookup(\"controller:application\").get(\"currentRouteName\")\nApp.__container__.lookup(\"controller:application\").get(\"currentPath\")\n\n\nViews / TemplatesLog view lookups\n  1\n2\n3\n\n  window.App = Ember.Application.create({\n  LOG_VIEW_LOOKUPS: true\n});\n\n\nGet the View object from its DOM Element's ID\n  1\n\n  Ember.View.views['ember605']\n\n\nView all registered templates\n  1\n\n  Ember.keys(Ember.TEMPLATES)\n\n\nHandlebars Debugging Helpers\n  1\n2\n\n  {{debugger}}\n{{log record}}\n\n\nControllersLog generated controller\n  1\n2\n3\n\n  window.App = Ember.Application.create({\n  LOG_ACTIVE_GENERATION: true\n});\n\n\nEmber DataView ember-data's type maps\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  // all type maps in memory\nApp.__container__.lookup('store:main').typeMaps \n\n// specific type map in memory\nApp.__container__.lookup('store:main').typeMapFor(App.Color)\n\n// map of id to record for all cached records for a type\nApp.__container__.lookup('store:main').typeMapFor(App.Color).idToRecord\n\n// array of all cached records for a type\nApp.__container__.lookup('store:main').typeMapFor(App.Color).records\n\n// grab a property off record id \"33\"\nApp.__container__.lookup('store:main').typeMapFor(App.Color).idToRecord[\"33\"].get('color')\n\n\nObservers / BindingSee all observers for a object, key\n  1\n\n  Ember.observersFor(comments, keyName);\n\n\nLog object bindings\n  1\n\n  Ember.LOG_BINDINGS = true\n\n\nMiscellaneousTurn on resolver resolution logging\nThis option logs all the lookups that are done to the console. Custom objects\nyou've created yourself have a tick, and Ember generated ones don't.\n\nIt's useful for understanding which objects Ember is finding when it does a lookup\nand which it is generating automatically for you.\n\n  1\n2\n3\n\n  App = Ember.Application.create({\n  LOG_RESOLVER: true\n});\n\n\nView an instance of something from the container\n  1\n2\n\n  App.__container__.lookup(\"controller:posts\")\nApp.__container__.lookup(\"route:application\")\n\n\nDealing with deprecations\n  1\n2\n\n  Ember.ENV.RAISE_ON_DEPRECATION = true\nEmber.LOG_STACKTRACE_ON_DEPRECATION = true\n\n\nImplement an Ember.onerror hook to log all errors in production\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Ember.onerror = function(error) {\n  Ember.$.ajax('/error-notification', {\n    type: 'POST',\n    data: {\n      stack: error.stack,\n      otherInformation: 'exception message'\n    }\n  });\n}\n\n\nImport the console\nIf you are using imports with Ember, be sure to import the console:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  Ember = {\n  imports: {\n    Handlebars: Handlebars,\n    jQuery: $,\n    console: window.console\n  }\n};\n\n\nErrors within an RSVP.Promise\nThere are times when dealing with promises that it seems like any errors\nare being 'swallowed', and not properly raised. This makes it extremely\ndifficult to track down where a given issue is coming from. Thankfully,\nRSVP has a solution for this problem built in.\n\nYou can provide an onerror function that will be called with the error\ndetails if any errors occur within your promise. This function can be anything\nbut a common practice is to call console.assert to dump the error to the\nconsole.\n\n  1\n2\n3\n\n  Ember.RSVP.on('error', function(error) {\n  Ember.Logger.assert(false, error);\n});\n\n\nErrors within Ember.run.later (Backburner.js)\nBackburner has support for stitching the stacktraces together so that you can\ntrack down where an erroring Ember.run.later is being initiated from. Unfortunately,\nthis is quite slow and is not appropriate for production or even normal development.\n\nTo enable this mode you can set:\n\n  1\n\n  Ember.run.backburner.DEBUG = true;\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ba55166358a3df3672dfc989bc7eee52","fields":[{"name":"title","value":"Dependency Injection \u0026 Service Lookup","type":"string"},{"name":"url","value":"/understanding-ember/dependency-injection-and-service-lookup/","type":"enum"},{"name":"body","value":"Dependency injection and service lookup are two important framework concepts. The first, dependency injection, refers to a dependent object being injected onto another object during instantiation. For example, all route objects have the property router set on them during instantiation. We say that the dependency of the router has been injected onto the route object.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.IndexRoute = Ember.Route.extend({\n  actions: {\n    showPath: function(){\n      // Dependency injection provides the router object to the route instance.\n      alert(this.router.get('currentPath'));\n    }\n  }\n});\n\n\n\nSometimes an Ember.js library will use dependency injection to expose its API to developers. An example of this is Ember-Data, which injects its store into all routes and controllers.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  App.IndexController = Ember.ObjectController.extend({\n  actions: {\n    findItems: function(){\n      var controller = this;\n      // Dependency injection provides the store object to the controller instance.\n      this.store.find('item').then(function(items){\n        controller.set('items', items);\n      });\n    }\n  }\n});\n\n\n\nThese are just two examples of how dependency injection, or DI, is used in Ember applications.\n\nThe second tool, service lookup, describes when a dependency is created or fetched on demand. Service lookup is the simpler pattern, and will be discussed first. Fundamentally, these two patterns share the same goals:\n\n\nIsolate responsibilities in an application\nAvoid the use of global variables and instances (important for testing)\nAllow a single object instance to represent state, but share that state with other objects.\n\nLightweight Services with needs\nA common use-case for service lookup is that of a singleton service. Often, these services will live near application state, and thus Ember provides an API that makes controller services easy to write.\n\nFor example, a session service can easily be made available to this index controller:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var App = Ember.Application.create();\nApp.SessionController = Ember.Controller.extend({\n  isAuthenticated: false\n});\n// The index controller may need access to that state:\nApp.IndexController = Ember.Controller.extend({\n  needs: ['session'],\n  // Using needs, the controller instance will be available on `controllers`\n  isLoggedIn: Ember.computed.alias('controllers.session.isAuthenticated')\n});\n\n\n\nThe controllers computed property returns a hash of the controllers listed in needs. Controllers in Ember.js are singletons, meaning the same instance is always returned when they are requested.\n\nA second controller can take advantage of this singleton nature to access the same session object:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  App.SignInController = Ember.Controller.extend({\n  needs: ['session'],\n  isLoggedIn: Ember.computed.alias('controllers.session.isAuthenticated'),\n  actions: {\n    signIn: function(){\n      // There is an alias to the session property, so this change propagates\n      // to the session object then the IndexController.\n      this.set('isLoggedIn', true);\n    }\n  }\n});\n\n\n\nThe session object returned in both classes is the same. needs provides us an easy way to share state across controllers.\nServices with DOM via needs\nThe needs array can fetch any singleton controller in an Ember application. This can be combined with the render helper to create services that also have access to the DOM.\n\nLet's build a controller that manages audio playback and makes it available to other controllers.\n\nFirst, we create AudioController and attach it to the DOM by using the render helper. This helper renders a template, and backs that template with a controller of the same name.\n\n  1\n2\n3\n\n  {{! application.hbs }}\n{{render \"audio\"}}\n{{outlet}}\n\n\n\nAnd we must create an audio.hbs template to render:\n\n  1\n2\n3\n4\n5\n\n  {{! audio.hbs }}\n\u003caudio id=\"audio\" controls loop\u003e\n  \u003csource {{bind-attr src=currentSrc}} type=\"audio/mpeg\"\u003e\u003c/source\u003e\n\u003c/audio\u003e\n\u003cdiv\u003e{{currentSrc}}\u003c/div\u003e\n\n\n\nThe render helper will back this template with a controller of the same name. We create that controller, and have it maintain the currentSrc property:\n\n  1\n2\n3\n4\n5\n6\n\n  App.AudioController = Ember.Controller.extend({\n  currentSrc: null,\n  play: function(src){\n    this.set('currentSrc', src);\n  }\n});\n\n\n\nTo allow other controllers to play audio, we use the needs array to look up our new service:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.IndexController = Ember.Controller.extend({\n  needs: ['audio'],\n  actions: {\n    selectSrc: function(src){\n      this.get('controllers.audio').play(src);\n    }\n  }\n});\n\n\n\nWhen the index controller calls this.get('controllers.audio'), the audio service is returned. Other controllers can also use needs to access the audio service.\n\nA functional version of this example is provided below:\n\nEmber Starter Kit\n\nServices are a simple way to share behavior between controllers and isolate responsibilities in an application. needs is an easy and quick way to create services and share them between an application's controllers.\n\nFor a more powerful way to connect Ember.js components, let's look at dependency injection.\nDependency Management in Ember.js\nWhen an Ember application starts running, it will create and use a single instance of the\nEmber.Container object. This container object is responsible for managing factories and the dependencies between them. At the level of the container, a factory can be any framework component. The index template is a factory with the name template:index, and the application route is a factory with the name route:application. The container understands how to use these factories (are they singleton? Should they be instantiated?) and manages their dependencies.\n\nFactory names have two parts segmented by a :. The first segment is the framework component type, and the second is the name of the component requested. Hence, an application view would be named view:application.\n\nIf the container does not already have a requested factory, it uses a resolver to discover that factory. The resolver is responsible for mapping the factory name of view:application to the global variable of App.ApplicationView. Tools like ember-cli may use alternative rules for resolving factories. After optionally adding dependencies to the requested factory, that factory is cached and returned.\n\nEmber's container should be viewed as an implementation detail, and is not part of the supported public API.\nDependency Injection with register/inject\nInstead of accessing the container directly, Ember provides an API for registering factories and managing injections on the application instance.\n\nThere are two ways to access this API. Many Ember applications can access this API directly on the application instance:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App = Ember.Application.create();\n\nApp.register('logger:main', {\n  log: function(m) {\n    console.log(m);\n  }\n}, { instantiate: false });\n\nApp.inject('route', 'logger', 'logger:main');\n\n\n\nBut ember-cli applications (and libraries) will need to use a more flexible hook, an initializer:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  Ember.Application.initializer({\n  name: 'logger',\n\n  initialize: function(container, application) {\n    var logger = {\n      log: function(m) {\n        console.log(m);\n      }\n    };\n\n    application.register('logger:main', logger, { instantiate: false });\n    application.inject('route', 'logger', 'logger:main');\n  }\n});\n\n\n\nInitializers can be declared at any time before an application is instantiated, making them easier to declare than directly registering factories on the application.\n\nAny dependency injection is comprised of two parts. The first is the factory registration:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var logger = {\n  log: function(m) {\n    console.log(m);\n  }\n};\n\napplication.register('logger:main', logger, { instantiate: false });\n\n\n\nThe register function adds the factory (logger) into the container. It adds it with the full name of logger:main, and with the option not to instantiate. When the factory is injected onto another object, it will be injected \"as-is\".\n\nOften, it is preferable to register a factory that can be instantiated:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var Logger = Ember.Object.extend({\n  log: function(m) {\n    console.log(m);\n  }\n});\n\napplication.register('logger:main', Logger);\n\n\n\nThis class will be instantiated before it is used by the container. This gives it the important benefit of being able to accept injections of its own.\n\nThe second part of dependency injection is, you guessed it, the dependency injection:\n\n  1\n\n  application.inject('route', 'logger', 'logger:main');\n\n\n\nThis is an example of a type injection. Onto all factories of the type route the property, logger will be injected with the factory named logger:main. Routes in this example application can now access the logger:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n  App = Ember.Application.extend();\n\nApp.Logger = Ember.Object.extend({\n  log: function(m) {\n    console.log(m);\n  }\n});\n\nApp.IndexRoute = Ember.Route.extend({\n  activate: function(){\n    // The logger property is injected into all routes\n    this.logger.log('Entered the index route!');\n  }\n});\n\nEmber.Application.initializer({\n  name: 'logger',\n\n  initialize: function(container, application) {\n    application.register('logger:main', App.Logger);\n    application.inject('route', 'logger', 'logger:main');\n  }\n});\n\nApp.create();\n\n\n\nInjections can also be made on a specific factory by using its full name:\n\n  1\n\n  application.inject('route:index', 'logger', 'logger:main');\n\n\n\nInjections can be made onto all of Ember's major framework classes, including views, helpers, components, controllers, routes, and the router.\n\nNote: For injections into models (if not using ember-cli), you need to enable the MODEL_FACTORY_INJECTIONS \nflag before you initialize your application. You can do this like so:\n\n  1\n2\n3\n4\n5\n\n  Ember.MODEL_FACTORY_INJECTIONS = true;\n\nvar App = Ember.Application.create({\n  // Enable any options\n});\n\n\n\nWhat follows is a full implementation of the above logger service:\n\nEmber Starter Kit\n\nDependency injection and service lookup are two powerful tools in your Ember.js toolset, and every mature Ember application will require their use.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"584ce5644ebfd4f0be66c39ddb81c173","fields":[{"name":"title","value":"Keeping Templates Up-to-Date","type":"string"},{"name":"url","value":"/understanding-ember/keeping-templates-up-to-date/","type":"enum"},{"name":"body","value":"In order to know which part of your HTML to update when an underlying property changes, Handlebars will insert marker elements with a unique ID. If you look at your application while it's running, you might notice these extra elements:\n\n  1\n2\n3\n4\n\n  My new car is\n\u003cscript id=\"metamorph-0-start\" type=\"text/x-placeholder\"\u003e\u003c/script\u003e\nblue\n\u003cscript id=\"metamorph-0-end\" type=\"text/x-placeholder\"\u003e\u003c/script\u003e.\n\n\n\nBecause all Handlebars expressions are wrapped in these markers, make sure each HTML tag stays inside the same block. For example, you shouldn't do this:\n\n  1\n2\n\n  {{! Don't do it! }}\n\u003cdiv {{#if isUrgent}}class=\"urgent\"{{/if}}\u003e\n\n\n\nIf you want to avoid your property output getting wrapped in these markers, use the unbound helper:\n\n  1\n\n  My new car is {{unbound color}}.\n\n\n\nYour output will be free of markers, but be careful, because the output won't be automatically updated!\n\n  1\n\n  My new car is blue.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3c7603802d3fb0216ad6bea9eb81df5b","fields":[{"name":"title","value":"Managing Asynchrony","type":"string"},{"name":"url","value":"/understanding-ember/managing-asynchrony/","type":"enum"},{"name":"body","value":"Many Ember concepts, like bindings and computed properties, are designed\nto help manage asynchronous behavior.\nWithout Ember\nWe'll start by taking a look at ways to manage asynchronous behavior\nusing jQuery or event-based MVC frameworks.\n\nLet's use the most common asynchronous behavior in a web application,\nmaking an Ajax request, as an example. The browser APIs for making Ajax\nrequests provide an asynchronous API. jQuery's wrapper does as well:\n\n  1\n2\n3\n4\n\n  jQuery.getJSON('/posts/1', function(post) {\n  $(\"#post\").html(\"\u003ch1\u003e\" + post.title + \"\u003c/h1\u003e\" +\n    \"\u003cdiv\u003e\" + post.body + \"\u003c/div\u003e\");\n});\n\n\n\nIn a raw jQuery application, you would use this callback to make\nwhatever changes you needed to make to the DOM.\n\nWhen using an event-based MVC framework, you move the logic out of the\ncallback and into model and view objects. This improves things, but\ndoesn't get rid of the need to explicitly deal with asynchronous\ncallbacks:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n  Post = Model.extend({\n  author: function() {\n    return [this.salutation, this.name].join(' ')\n  },\n\n  toJSON: function() {\n    var json = Model.prototype.toJSON.call(this);\n    json.author = this.author();\n    return json;\n  }\n});\n\nPostView = View.extend({\n  init: function(model) {\n    model.bind('change', this.render, this);\n  },\n\n  template: _.template(\"\u003ch1\u003e\u003c%= title %\u003e\u003c/h1\u003e\u003ch2\u003e\u003c%= author %\u003e\u003c/h2\u003e\u003cdiv\u003e\u003c%= body %\u003e\u003c/div\u003e\"),\n\n  render: function() {\n    jQuery(this.element).html(this.template(this.model.toJSON());\n    return this;\n  }\n});\n\nvar post = Post.create();\nvar postView = PostView.create({ model: post });\njQuery('#posts').append(postView.render().el);\n\njQuery.getJSON('/posts/1', function(json) {\n  // set all of the JSON properties on the model\n  post.set(json);\n});\n\n\n\nThis example doesn't use any particular JavaScript library beyond\njQuery, but its approach is typical of event-driven MVC frameworks. It\nhelps organize the asynchronous events, but asynchronous behavior is\nstill the core programming model.\nEmber's Approach\nIn general, Ember's goal is to eliminate explicit forms of asynchronous\nbehavior. As we'll see later, this gives Ember the ability to coalesce\nmultiple events that have the same result.\n\nIt also provides a higher level of abstraction, eliminating the need to\nmanually register and unregister event listeners to perform most common\ntasks.\n\nYou would normally use ember-data for this example, but let's see how\nyou would model the above example using jQuery for Ajax in Ember.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n  App.Post = Ember.Object.extend({\n\n});\n\nApp.PostController = Ember.ObjectController.extend({\n  author: function() {\n    return [this.get('salutation'), this.get('name')].join(' ');\n  }.property('salutation', 'name')\n});\n\nApp.PostView = Ember.View.extend({\n  // the controller is the initial context for the template\n  controller: null,\n  template: Ember.Handlebars.compile(\"\u003ch1\u003e{{title}}\u003c/h1\u003e\u003ch2\u003e{{author}}\u003c/h2\u003e\u003cdiv\u003e{{body}}\u003c/div\u003e\")\n});\n\nvar post = App.Post.create();\nvar postController = App.PostController.create({ model: post });\n\nApp.PostView.create({ controller: postController }).appendTo('body');\n\njQuery.getJSON(\"/posts/1\", function(json) {\n  post.setProperties(json);\n});\n\n\n\nIn contrast to the above examples, the Ember approach eliminates the\nneed to explicitly register an observer when the post's properties\nchange.\n\nThe {{title}}, {{author}} and {{body}} template elements are bound\nto those properties on the PostController. When the PostController's\nmodel changes, it automatically propagates those changes to the DOM.\n\nUsing a computed property for author eliminated the need to explicitly\ninvoke the computation in a callback when the underlying property\nchanged.\n\nInstead, Ember's binding system automatically follows the trail from the\nsalutation and name set in the getJSON callback to the computed\nproperty in the PostController and all the way into the DOM.\nBenefits\nBecause Ember is usually responsible for propagating changes, it can\nguarantee that a single change is only propagated one time in response\nto each user event.\n\nLet's take another look at the author computed property.\n\n  1\n2\n3\n4\n5\n\n  App.PostController = Ember.ObjectController.extend({\n  author: function() {\n    return [this.get('salutation'), this.get('name')].join(' ');\n  }.property('salutation', 'name')\n});\n\n\n\nBecause we have specified that it depends on both salutation and\nname, changes to either of those two dependencies will invalidate the\nproperty, which will trigger an update to the {{author}} property in\nthe DOM.\n\nImagine that in response to a user event, I do something like this:\n\n  1\n2\n\n  post.set('salutation', \"Mrs.\");\npost.set('name', \"Katz\");\n\n\n\nYou might imagine that these changes will cause the computed property to\nbe invalidated twice, causing two updates to the DOM. And in fact, that\nis exactly what would happen when using an event-driven framework.\n\nIn Ember, the computed property will only recompute once, and the DOM\nwill only update once.\n\nHow?\n\nWhen you make a change to a property in Ember, it does not immediately\npropagate that change. Instead, it invalidates any dependent properties\nimmediately, but queues the actual change to happen later.\n\nChanging both the salutation and name properties invalidates the\nauthor property twice, but the queue is smart enough to coalesce those\nchanges.\n\nOnce all of the event handlers for the current user event have finished,\nEmber flushes the queue, propagating the changes downward. In this case,\nthat means that the invalidated author property will invalidate the\n{{author}} in the DOM, which will make a single request to recompute\nthe information and update itself once.\n\nThis mechanism is fundamental to Ember. In Ember, you should always\nassume that the side-effects of a change you make will happen later. By\nmaking that assumption, you allow Ember to coalesce repetitions of the\nsame side-effect into a single call.\n\nIn general, the goal of evented systems is to decouple the data\nmanipulation from the side effects produced by listeners, so you\nshouldn't assume synchronous side effects even in a more event-focused\nsystem. The fact that side effects don't propagate immediately in Ember\neliminates the temptation to cheat and accidentally couple code together\nthat should be separate.\nSide-Effect Callbacks\nSince you can't rely on synchronous side-effects, you may be wondering\nhow to make sure that certain actions happen at the right time.\n\nFor example, imagine that you have a view that contains a button, and\nyou want to use jQuery UI to style the button. Since a view's append\nmethod, like everything else in Ember, defers its side-effects, how can\nyou execute the jQuery UI code at the right time?\n\nThe answer is lifecycle callbacks.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  App.Button = Ember.View.extend({\n  tagName: 'button',\n  template: Ember.Handlebars.compile(\"{{view.title}}\"),\n\n  didInsertElement: function() {\n    this.$().button();\n  }\n});\n\nvar button = App.Button.create({\n  title: \"Hi jQuery UI!\"\n}).appendTo('#something');\n\n\n\nIn this case, as soon as the button actually appears in the DOM, Ember\nwill trigger the didInsertElement callback, and you can do whatever\nwork you want.\n\nThe lifecycle callbacks approach has several benefits, even if we didn't\nhave to worry about deferred insertion.\n\nFirst, relying on synchronous insertion means leaving it up to the\ncaller of appendTo to trigger any behavior that needs to run\nimmediately after appending. As your application grows, you may find\nthat you create the same view in many places, and now need to worry\nabout that concern everywhere.\n\nThe lifecycle callback eliminates the coupling between the code that\ninstantiates the view and its post-append behavior. In general, we find\nthat making it impossible to rely on synchronous side-effects leads to\nbetter design in general.\n\nSecond, because everything about the lifecycle of a view is inside the\nview itself, it is very easy for Ember to re-render parts of the DOM\non-demand.\n\nFor example, if this button was inside of an {{#if}} block, and Ember\nneeded to switch from the main branch to the else section, Ember can\neasily instantiate the view and call the lifecycle callbacks.\n\nBecause Ember forces you to define a fully-defined view, it can take\ncontrol of creating and inserting views in appropriate situations.\n\nThis also means that all of the code for working with the DOM is in a\nfew sanctioned parts of your application, so Ember has more freedom in\nthe parts of the render process outside of these callbacks.\nObservers\nIn some rare cases, you will want to perform certain behavior after a\nproperty's changes have propagated. As in the previous section, Ember\nprovides a mechanism to hook into the property change notifications.\n\nLet's go back to our salutation example.\n\n  1\n2\n3\n4\n5\n\n  App.PostController = Ember.ObjectController.extend({\n  author: function() {\n    return [this.get('salutation'), this.get('name')].join(' ');\n  }.property('salutation', 'name')\n});\n\n\n\nIf we want to be notified when the author changes, we can register an\nobserver. Let's say that the view object wants to be notified:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.PostView = Ember.View.extend({\n  controller: null,\n  template: Ember.Handlebars.compile(\"\u003ch1\u003e{{title}}\u003c/h1\u003e\u003ch2\u003e{{author}}\u003c/h2\u003e\u003cdiv\u003e{{body}}\u003c/div\u003e\"),\n\n  authorDidChange: function() {\n    alert(\"New author name: \" + this.get('controller.author'));\n  }.observes('controller.author')\n});\n\n\n\nEmber triggers observers after it successfully propagates the change. In\nthis case, that means that Ember will only call the authorDidChange\ncallback once in response to each user event, even if both of salutation\nand name changed.\n\nThis gives you the benefits of executing code after the property has\nchanged, without forcing all property changes to be synchronous. This\nbasically means that if you need to do some manual work in response to a\nchange in a computed property, you get the same coalescing benefits as\nEmber's binding system.\n\nFinally, you can also register observers manually, outside of an object\ndefinition:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  App.PostView = Ember.View.extend({\n  controller: null,\n  template: Ember.Handlebars.compile(\"\u003ch1\u003e{{title}}\u003c/h1\u003e\u003ch2\u003e{{author}}\u003c/h2\u003e\u003cdiv\u003e{{body}}\u003c/div\u003e\"),\n\n  didInsertElement: function() {\n    this.addObserver('controller.author', function() {\n      alert(\"New author name: \" + this.get('controller.author'));\n    });\n  }\n});\n\n\n\nHowever, when you use the object definition syntax, Ember will\nautomatically tear down the observers when the object is destroyed. For\nexample, if an {{#if}} statement changes from truthy to falsy, Ember\ndestroys all of the views defined inside the block. As part of that\nprocess, Ember also disconnects all bindings and inline observers.\n\nIf you define an observer manually, you need to make sure you remove it.\nIn general, you will want to remove observers in the opposite callback\nto when you created it. In this case, you will want to remove the\ncallback in willDestroyElement.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  App.PostView = Ember.View.extend({\n  controller: null,\n  template: Ember.Handlebars.compile(\"\u003ch1\u003e{{title}}\u003c/h1\u003e\u003ch2\u003e{{author}}\u003c/h2\u003e\u003cdiv\u003e{{body}}\u003c/div\u003e\"),\n\n  didInsertElement: function() {\n    this.addObserver('controller.author', function() {\n      alert(\"New author name: \" + this.get('controller.author'));\n    });\n  },\n\n  willDestroyElement: function() {\n    this.removeObserver('controller.author');\n  }\n});\n\n\n\nIf you added the observer in the init method, you would want to tear\nit down in the willDestroy callback.\n\nIn general, you will very rarely want to register a manual observer in\nthis way. Because of the memory management guarantees, we strongly\nrecommend that you define your observers as part of the object\ndefinition if possible.\nRouting\nThere's an entire page dedicated to managing async within the Ember\nRouter: Asynchronous Routing\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ead09a4fdf3e0a0ce7e4f5b67db647d7","fields":[{"name":"title","value":"The Run Loop","type":"string"},{"name":"url","value":"/understanding-ember/run-loop/","type":"enum"},{"name":"body","value":"Ember's internals and most of the code you will write in your applications takes place in a run loop. The run loop is used to\nbatch, and order (or reorder) work in a way that is most effective and efficient.\n\nIt does so by scheduling work on specific queues. These queues have a priority,\nand are processed to completion in priority order.\nWhy is this useful?\nVery often, batching similar work has benefits. Web browsers do something quite similar\nby batching changes to the DOM.\n\nConsider the following HTML snippet:\n\n  1\n2\n3\n\n  \u003cdiv id=\"foo\"\u003e\u003c/div\u003e\n\u003cdiv id=\"bar\"\u003e\u003c/div\u003e\n\u003cdiv id=\"baz\"\u003e\u003c/div\u003e\n\n\n\nand executing the following code:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  foo.style.height = \"500px\" // write\nfoo.offsetHeight // read (recalculate style, layout, expensive!)\n\nbar.style.height = \"400px\" // write\nbar.offsetHeight // read (recalculate style, layout, expensive!)\n\nbaz.style.height = \"200px\" // write\nbaz.offsetHeight // read (recalculate style, layout, expensive!)\n\n\n\nIn this example, the sequence of code forced the browser to recalculate style,\nand relayout after each step. However, if we were able to batch similar jobs together,\nthe browser would have only needed to recalulate the style and layout once.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  foo.style.height = \"500px\" // write\nbar.style.height = \"400px\" // write\nbaz.style.height = \"200px\" // write\n\nfoo.offsetHeight // read (recalculate style, layout, expensive!)\nbar.offsetHeight // read (fast since style and layout is already known)\nbaz.offsetHeight // read (fast since style and layout is already known)\n\n\n\nInterestingly, this pattern holds true for many other types of work. Essentially,\nbatching similar work allows for better pipelining, and further optimization.\n\nLet's look at a similar example that is optimized in Ember, starting with a User object:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var User = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n  fullName: function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  }.property('firstName', 'lastName')\n});\n\n\n\nand a template to display its attributes:\n\n  1\n2\n\n  {{firstName}}\n{{fullName}}\n\n\n\nIf we execute the following code without the run loop:\n\n  1\n2\n3\n4\n5\n6\n\n  var user = User.create({firstName:'Tom', lastName:'Huda'});\nuser.set('firstName', 'Yehuda');\n// {{firstName}} and {{fullName}} are updated\n\nuser.set('lastName', 'Katz');\n// {{lastName}} and {{fullName}} are updated\n\n\n\nWe see that the browser will rerender the template twice.\n\n  1\n2\n3\n4\n5\n\n  var user = User.create({firstName:'Tom', lastName:'Huda'});\nuser.set('firstName', 'Yehuda');\nuser.set('lastName', 'Katz');\n\n// {{firstName}}  {{lastName}} and {{fullName}} are updated\n\n\n\nHowever, if we have the run loop in the above code, the browser will only rerender the template once the attributes have all been set.\n\n  1\n2\n3\n4\n5\n\n  var user = User.create({firstName:'Tom', lastName:'Huda'});\nuser.set('firstName', 'Yehuda');\nuser.set('lastName', 'Katz');\nuser.set('firstName', 'Tom');\nuser.set('lastName', 'Huda');\n\n\n\nIn the above example with the run loop, since the user's attributes end up at the same values as before execution, the template will not even rerender!\n\nIt is of course possible to optimize these scenarios on a case-by-case basis,\nbut getting them for free is much nicer. Using the run loop, we can apply these\nclasses of optimizations not only for each scenario, but holistically app-wide.\nHow does the Run Loop work in Ember?\nAs mentioned earlier, we schedule work (in the form of function invocations) on\nqueues, and these queues are processed to completion in priority order.\n\nWhat are the queues, and what is their priority order?\n\n  1\n2\n\n  Ember.run.queues\n// =\u003e [\"sync\", \"actions\", \"routerTransitions\", \"render\", \"afterRender\", \"destroy\"]\n\n\n\nBecause the priority is first to last, the \"sync\" queue has higher priority than the \"render\" or \"destroy\" queue.\nWhat happens in these queues?\n\nThe sync queue contains binding synchronization jobs\nThe actions queue is the general work queue and will typically contain scheduled tasks e.g. promises\nThe routerTransitions queue contains transition jobs in the router\nThe render queue contains jobs meant for rendering, these will typically update the DOM\nThe afterRender contains jobs meant to be run after all previously scheduled render tasks are complete. This is often good for 3rd-party DOM manipulation libraries, that should only be run after an entire tree of DOM has been updated\nThe destroy queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy\n\nIn what order are jobs executed on the queues?\nThe algorithm works this way:\n\n\nLet the highest priority queue with pending jobs be: CURRENT_QUEUE, if there are no queues with pending jobs the run loop is complete\nLet a new temporary queue be defined as WORK_QUEUE\nMove jobs from CURRENT_QUEUE into WORK_QUEUE\nProcess all the jobs sequentially in WORK_QUEUE\nReturn to Step 1\n\nAn example of the internals\nRather than writing the higher level app code that internally invokes the various\nrun loop scheduling functions, we have stripped away the covers, and shown the raw run-loop interactions.\n\nWorking with this API directly is not common in most Ember apps, but understanding this example will\nhelp you to understand the run-loops algorithm, which will make you a better Ember developer.\n\n\nFAQsWhat do I need to know to get started with Ember?\nFor basic Ember app development scenarios, nothing. All common paths are paved nicely\nfor you and don't require working with the run loop directly.\nWhat do I need to know to actually build an app?\nIt is possible to build good apps without working with the run loop directly, so if\nyou don't feel the need to do so, don't.\nWhat scenarios will require me to understand the run loop?\nThe most common case you will run into is integrating with a non-Ember API\nthat includes some sort of asynchronous callback. For example:\n\n\nAJAX callbacks\nDOM update and event callbacks\nWebsocket callbacks\nsetTimeout and setInterval callbacks\npostMessage and messageChannel event handlers\n\n\nYou should begin a run loop when the callback fires.\nHow do I tell Ember to start a run loop?\n  1\n2\n3\n4\n5\n\n  $('a').click(function(){\n  Ember.run(function(){  // begin loop\n    // Code that results in jobs being scheduled goes here\n  }); // end loop, jobs are flushed and executed\n});\n\n\nWhat happens if I forget to start a run loop in an async handler?\nAs mentioned above, you should wrap any non-Ember async callbacks in\nEmber.run. If you don't, Ember will try to approximate a beginning and end for you.\nConsider the following callback:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  $('a').click(function(){\n  console.log('Doing things...');\n\n  Ember.run.schedule('actions', this, function() {\n    // Do more things\n  });\n  Ember.run.scheduleOnce('afterRender', this, function() {\n    // Yet more things\n  });\n});\n\n\n\nThe runloop API calls that schedule work i.e. run.schedule,\nrun.scheduleOnce, run.once have the property that they will approximate a\nrunloop for you if one does not already exist. These automatically created\nrunloops we call autoruns.\n\nHere is some pseudocode to describe what happens using the example above:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n  $('a').click(function(){\n  // 1. autoruns do not change the execution of arbitrary code in a callback.\n  //    This code is still run when this callback is executed and will not be\n  //    scheduled on an autorun.\n  console.log('Doing things...');\n\n  Ember.run.schedule('actions', this, function() {\n    // 2. schedule notices that there is no currently available runloop so it\n    //    creates one. It schedules it to close and flush queues on the next\n    //    turn of the JS event loop.\n    if (! Ember.run.hasOpenRunloop()) {\n      Ember.run.start();\n      nextTick(function() {\n          Ember.run.end()\n      }, 0);\n    }\n\n    // 3. There is now a runloop available so schedule adds its item to the\n    //    given queue\n    Ember.run.schedule('actions', this, function() {\n      // Do more things\n    });\n\n  });\n\n  // 4. scheduleOnce sees the autorun created by schedule above as an available\n  //    runloop and adds its item to the given queue.\n  Ember.run.scheduleOnce('afterRender', this, function() {\n    // Yet more things\n  });\n\n});\n\n\n\nAlthough autoruns are convenient, they are suboptimal. The current JS frame is\nallowed to end before the run loop is flushed, which sometimes means the browser\nwill take the opportunity to do other things, like garbage collection. GC\nrunning in between data changing and DOM rerendering can cause visual lag and\nshould be minimized.\n\nRelying on autoruns is not a rigorous or efficient way to use the runloop.\nWrapping event handlers manually is preferred.\nHow is runloop behaviour different when testing?\nWhen Ember.testing is set i.e. your application is in testing mode then\nEmber will throw an error if you try to schedule work without an available\nrunloop.\n\nAutoruns are disabled in testing for several reasons:\n\n\nAutoruns are Embers way of not punishing you in production if you forget to\nopen a runloop before you schedule callbacks on it. While this is useful in\nproduction, these are still situations that should be revealed in testing to\nhelp you find and fix them.\nSome of Ember's test helpers are promises that wait for the run loop to empty\nbefore resolving. If your application has code that runs outside a runloop,\nthese will resolve too early and give erroneous test failures which are\ndifficult to find. Disabling autoruns help you identify these scenarios and\nhelps both your testing and your application!\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4a4f3da3e525930a038b9a17e34a8945","fields":[{"name":"title","value":"The View Layer","type":"string"},{"name":"url","value":"/understanding-ember/the-view-layer/","type":"enum"},{"name":"body","value":"This guide goes into extreme detail about the Ember.js view layer. It is\nintended for an experienced Ember developer, and includes details that\nare unnecessary for getting started with Ember.\n\nEmber.js has a sophisticated system for creating, managing and rendering a hierarchy of views that connect to the browser's DOM. Views are responsible for responding to user events, like clicks, drags, and scrolls, as well as updating the contents of the DOM when the data underlying the view changes.\n\nView hierarchies are usually created by evaluating a Handlebars template. As the template is evaluated, child views are added. As the templates for those child views are evaluated, they may have child views added, and so on, until an entire hierarchy is created.\n\nEven if you do not explicitly create child views from your Handlebars templates, Ember.js internally uses the view system to update bound values. For example, every Handlebars expression {{value}} creates a view behind-the-scenes that knows how to update the bound value if it changes.\n\nYou can also dynamically make changes to the view hierarchy at application runtime using the Ember.ContainerView class. Rather than being template-driven, a container view exposes an array of child view instances that can be manually managed.\n\nViews and templates work in tandem to provide a robust system for creating whatever user interface you dream up. End users should be isolated from the complexities of things like timing issues while rendering and event propagation. Application developers should be able to describe their UI once, as a string of Handlebars markup, and then carry on with their application without having to worry about making sure that it remains up-to-date.\nWhat problems does it solve?Child Views\nIn a typical client-side application, views may represent elements nested inside of each other in the DOM. In the naïve solution to this problem, separate view objects represent each DOM element, and ad-hoc references help the various view objects keep track of the views conceptually nested inside of them.\n\nHere is a simple example, representing one main app view, a collection nested inside of it, and individual items nested inside of the collection.\n\n\n  \n\n\nThis system works well at first glance, but imagine that we want to open Joe's Lamprey Shack at 8am instead of 9am. In this situation, we will want to re-render the App View. Because the developer needed to build up the references to the children on an ad-hoc basis, this re-rendering process has several problems.\n\nIn order to re-render the App View, the App View must also manually re-render the child views and re-insert them into App View's element. If implemented perfectly, this process works well, but it relies upon a perfect, ad hoc implementation of a view hierarchy. If any single view fails to implement this precisely, the entire re-render will fail.\n\nIn order to avoid these problems, Ember's view hierarchy has the concept of child views baked in.\n\n\n  \n\n\nWhen the App View re-renders, Ember is responsible for re-rendering and inserting the child views, not application code. This also means that Ember can perform any memory management for you, such as cleaning up observers and bindings.\n\nNot only does this eliminate quite a bit of boilerplate code, but it eliminates the possibility that an imperfectly implemented view hierarchy will cause unexpected failures.\nEvent Delegation\nIn the past, web developers have added event listeners to individual elements in order to know when the user interacts with them. For example, you might have a \u003cdiv\u003e element on which you register a function that gets called when the user clicks it.\n\nHowever, this approach often does not scale when dealing with large numbers of interactive elements. For example, imagine a \u003cul\u003e with 100 \u003cli\u003es in it, with a delete button next to each item. Since the behavior is the same for all of these items, it would be inefficient to create 100 event listeners, one for each delete button.\n\n\n  \n\n\nTo solve this problem, developers discovered a technique called \"event delegation\". Instead of registering a listener on each element in question, you can register a single listener for the containing element and use event.target to identify which element the user clicked on.\n\n\n  \n\n\nImplementing this is a bit tricky, because some events (like focus, blur and change) don't bubble. Fortunately, jQuery has solved this problem thoroughly; using jQuery's on method reliably works for all native browser events.\n\nOther JavaScript frameworks tackle this problem in one of two ways. In the first approach, they ask you to implement the naïve solution yourself, creating a separate view for each element. When you create the view, it sets up an event listener on the view's element. If you had a list of 500 items, you would create 500 views and each would set up a listener on its own element.\n\nIn the second approach, the framework builds in event delegation at the view level. When creating a view, you can supply a list of events to delegate and a method to call when the event occurs. This leaves identifying the context of the click (for example, which item in the list) to the method receiving the event.\n\nYou are now faced with an uncomfortable choice: create a new view for each item and lose the benefits of event delegation, or create a single view for all of the items and have to store information about the underlying JavaScript object in the DOM.\n\nIn order to solve this problem, Ember delegates all events to the application's root element (usually the document body) using jQuery. When an event occurs, Ember identifies the nearest view that handles the event and invokes its event handler. This means that you can create views to hold a JavaScript context, but still get the benefit of event delegation.\n\nFurther, because Ember registers only one event for the entire Ember application, creating new views never requires setting up event listeners, making re-renders efficient and less error-prone. When a view has child views, this also means that there is no need to manually undelegate views that the re-render process replaces.\nThe Rendering Pipeline\nMost web applications specify their user interface using the markup of a particular templating language. For Ember.js, we've done the work to make templates written using the Handlebars templating language automatically update when the values used inside of them are changed.\n\nWhile the process of displaying a template is automatic for developers, under the hood there are a series of steps that must be taken to go from the original template to the final, live DOM representation that the user sees.\n\nThis is the approximate lifecycle of an Ember view:\n\n\n  \n\n1. Template Compilation\nThe application's templates are loaded over the network or as part of the application payload in string form. When the application loads, it sends the template string to Handlebars to be compiled into a function. Once compiled, the template function is saved, and can be used by multiple views repeatedly, each time they need to re-render.\n\nThis step may be omitted in applications where the templates are pre-compiled on the server. In those cases, the template is transferred not as the original, human-readable template string but as the compiled code.\n\nBecause Ember is responsible for template compilation, you don't have to do any additional work to ensure that compiled templates are reused.\n2. String Concatenation\nA view's rendering process is kickstarted when the application calls append or appendTo on the view. Calling append or appendTo schedules the view to be rendered and inserted later. This allows any deferred logic in your application (such as binding synchronization) to happen before rendering the element.\n\nTo begin the rendering process, Ember creates a RenderBuffer and gives it to the view to append its contents to. During this process, a view can create and render child views. When it does so, the parent view creates and assigns a RenderBuffer for the child, and links it to the parent's RenderBuffer.\n\nEmber flushes the binding synchronization queue before rendering each view. By syncing bindings before rendering each view, Ember guarantees that it will not render stale data it needs to replace right away.\n\nOnce the main view has finished rendering, the render process has created a tree of views (the \"view hierarchy\"), linked to a tree of buffers. By walking down the tree of buffers and converting them into Strings, we have a String that we can insert into the DOM.\n\nHere is a simple example:\n\n\n  \n\n\nIn addition to children (Strings and other RenderBuffers), a RenderBuffer also encapsulates the element's tag name, id, classes, style, and other attributes. This makes it possible for the render process to modify one of these properties (style, for example), even after its child Strings have rendered. Because many of these properties are controlled via bindings (e.g. using bind-attr), this makes the process robust and transparent.\n3. Element Creation and Insertion\nAt the end of the rendering process, the root view asks the RenderBuffer for its element. The RenderBuffer takes its completed string and uses jQuery to convert it into an element. The view assigns that element to its element property and places it into the correct place in the DOM (the location specified in appendTo or the application's root element if the application used append).\n\nWhile the parent view assigns its element directly, each child view looks up its element lazily. It does this by looking for an element whose id matches its elementId property. Unless explicitly provided, the rendering process generates an elementId property and assigns its value to the view's RenderBuffer, which allows the view to find its element as needed.\n4. Re-Rendering\nAfter the view inserts itself into the DOM, either Ember or the application may want to re-render the view. They can trigger a re-render by calling the rerender method on a view.\n\nRerendering will repeat steps 2 and 3 above, with two exceptions:\n\n\nInstead of inserting the element into an explicitly specified location, rerender replaces the existing element with the new element.\nIn addition to rendering a new element, it also removes the old element and destroys its children. This allows Ember to automatically handle unregistering appropriate bindings and observers when re-rendering a view. This makes observers on a path more viable, because the process of registering and unregistering all of the nested observers is automatic.\n\n\nThe most common cause of a view re-render is when the value bound to a Handlebars expression ({{foo}}) changes. Internally, Ember creates a simple view for each expression, and registers an observer on the path. When the path changes, Ember updates the area of the DOM with the new value.\n\nAnother common case is an {{#if}} or {{#with}} block. When rendering a template, Ember creates a virtual view for these block helpers. These virtual views do not appear in the publicly available view hierarchy (when getting parentView and childViews from a view), but they exist to enable consistent re-rendering.\n\nWhen the path passed to an {{#if}} or {{#with}} changes, Ember automatically re-renders the virtual view, which will replace its contents, and importantly, destroy all child views to free up their memory.\n\nIn addition to these cases, the application may sometimes want to explicitly re-render a view (usually a ContainerView, see below). In this case, the application can call rerender directly, and Ember will queue up a re-rendering job, with the same semantics.\n\nThe process looks something like:\n\n\n  \n\nThe View HierarchyParent and Child Views\nAs Ember renders a templated view, it will generate a view hierarchy. Let's assume we have a template form.\n\n  1\n2\n\n  {{view \"search\" placeholder=\"Search\"}}\n{{#view view.buttonView}}Go!{{/view}}\n\n\n\nAnd we insert it into the DOM like this:\n\n  1\n2\n3\n4\n\n  var view = Ember.View.create({\n  templateName: 'form',\n  buttonView: Ember.Button\n}).append();\n\n\n\nThis will create a small view hierarchy that looks like this:\n\n\n  \n\n\nYou can move around in the view hierarchy using the parentView and childViews properties.\n\n  1\n2\n\n  var children = view.get('childViews') // [ \u003cApp.Search\u003e, \u003cEmber.Button\u003e ]\nchildren.objectAt(0).get('parentView') // view\n\n\n\nOne common use of the parentView method is inside of an instance of a child view.\n\n  1\n2\n3\n4\n5\n\n  App.Search = Ember.View.extend({\n  didInsertElement: function() {\n    // this.get('parentView') in here references `view`\n  }\n})\n\n\nLifecycle Hooks\nIn order to make it easy to take action at different points during your view's lifecycle, there are several hooks you can implement.\n\n\nwillInsertElement: This hook is called after the view has been rendered, but before it has been inserted into the DOM. It does not provide access to the view's element.\ndidInsertElement: This hook is called immediately after the view has been inserted into the DOM. It provides access to the view's element and is most useful for integration with an external library. Any explicit DOM setup code should be limited to this hook.\nwillDestroyElement: This hook is called immediately before the element is removed from the DOM. This is your opportunity to tear down any external state associated with the DOM node. Like didInsertElement, it is most useful for integration with external libraries.\nwillClearRender: This hook is called immediately before a view is re-rendered. This is useful if you want to perform some teardown immediately before a view is re-rendered.\nbecameVisible: This hook is called after a view's isVisible property, or one of its ancestor's isVisible property, changes to true and the associated element becomes visible. Note that this hook is only reliable if all visibility is routed through the isVisible property.\nbecameHidden: This hook is called after a view's isVisible property, or one of its ancestor's isVisible property, changes to false and the associated element becomes hidden. Note that this hook is only reliable if all visibility is routed through the isVisible property.\n\n\nApps can implement these hooks by defining a method by the hook's name on the view. Alternatively, it is possible to register a listener for the hook on a view:\n\n  1\n2\n3\n\n  view.on('willClearRender', function() {\n  // do something with view\n});\n\n\nVirtual Views\nAs described above, Handlebars creates views in the view hierarchy to\nrepresent bound values. Every time you use a Handlebars expression,\nwhether it's a simple value or a block helper like {{#with}} or\n{{#if}}, Handlebars creates a new view.\n\nBecause Ember uses these views for internal bookkeeping only,\nthey are hidden from the view's public parentView and childViews\nAPI. The public view hierarchy reflects only views created using the\n{{view}} helper or through ContainerView (see below).\n\nFor example, consider the following Handlebars template:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  \u003ch1\u003eJoe's Lamprey Shack\u003c/h1\u003e\n{{restaurantHours}}\n\n{{#view \"fdaContactForm\"}}\n  If you are experiencing discomfort from eating at Joe's Lamprey Shack,\nplease use the form below to submit a complaint to the FDA.\n\n  {{#if allowComplaints}}\n    {{input value=\"complaint\"}}\n    \u003cbutton {{action \"submitComplaint\"}}\u003eSubmit\u003c/button\u003e\n  {{/if}}\n{{/view}}\n\n\n\nRendering this template would create a hierarchy like this:\n\n\n  \n\n\nBehind the scenes, Ember tracks additional virtual views for the\nHandlebars expressions:\n\n\n  \n\n\nFrom inside of the TextArea, the parentView would point to the\nFdaContactForm and the FdaContactForm's childViews would be an\narray of the single TextArea view.\n\nYou can see the internal view hierarchy by asking for the _parentView\nor _childViews, which will include virtual views:\n\n  1\n2\n3\n\n  var _childViews = view.get('_childViews');\nconsole.log(_childViews.objectAt(0).toString());\n//\u003e \u003cEmber._HandlebarsBoundView:ember1234\u003e\n\n\n\nWarning! You may not rely on these internal APIs in application code.\nThey may change at any time and have no public contract. The return\nvalue may not be observable or bindable. It may not be an Ember object.\nIf you feel the need to use them, please contact us so we can expose a better\npublic API for your use-case.\n\nBottom line: This API is like XML. If you think you have a use for it,\nyou may not yet understand the problem enough. Reconsider!\nEvent Bubbling\nOne responsibility of views is to respond to primitive user events\nand translate them into events that have semantic meaning for your\napplication.\n\nFor example, a delete button translates the primitive click event into\nthe application-specific \"remove this item from an array.\"\n\nIn order to respond to user events, create a new view subclass that\nimplements that event as a method:\n\n  1\n2\n3\n4\n5\n6\n\n  App.DeleteButton = Ember.View.create({\n  click: function(event) {\n    var item = this.get('model');\n    this.get('controller').send('deleteItem', item);\n  }\n});\n\n\n\nWhen you create a new Ember.Application instance, it registers an event\nhandler for each native browser event using jQuery's event delegation\nAPI. When the user triggers an event, the application's event dispatcher\nwill find the view nearest to the event target that implements the\nevent.\n\nA view implements an event by defining a method corresponding to the\nevent name. When the event name is made up of multiple words (like\nmouseup) the method name should be the camelized form of the event\nname (mouseUp).\n\nEvents will bubble up the view hierarchy until the event reaches the\nroot view. An event handler can stop propagation using the same\ntechniques as normal jQuery event handlers:\n\n\nreturn false from the method\nevent.stopPropagation\n\n\nFor example, imagine you defined the following view classes:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  App.GrandparentView = Ember.View.extend({\n  click: function() {\n    console.log('Grandparent!');\n  }\n});\n\nApp.ParentView = Ember.View.extend({\n  click: function() {\n    console.log('Parent!');\n    return false;\n  }\n});\n\nApp.ChildView = Ember.View.extend({\n  click: function() {\n    console.log('Child!');\n  }\n});\n\n\n\nAnd here's the Handlebars template that uses them:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  {{#view \"grandparent\"}}\n  {{#view \"parent\"}}\n    {{#view \"child\"}}\n      \u003ch1\u003eClick me!\u003c/h1\u003e\n    {{/view}}\n  {{/view}}\n{{/view}}\n\n\n\nIf you clicked on the \u003ch1\u003e, you'd see the following output in your\nbrowser's console:\n\n  1\n2\n\n  Child!\nParent!\n\n\n\nYou can see that Ember invokes the handler on the child-most view that\nreceived the event. The event continues to bubble to the ParentView,\nbut does not reach the GrandparentView because ParentView returns\nfalse from its event handler.\n\nYou can use normal event bubbling techniques to implement familiar\npatterns. For example, you could implement a FormView that defines a\nsubmit method. Because the browser triggers the submit event when\nthe user hits enter in a text field, defining a submit method on the\nform view will \"just work\".\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.FormView = Ember.View.extend({\n  tagName: \"form\",\n\n  submit: function(event) {\n    // will be invoked whenever the user triggers\n    // the browser's `submit` method\n  }\n});\n\n\n\n  1\n2\n3\n4\n5\n\n  {{#view \"form\"}}\n  {{input value=firstName}}\n  {{input value=lastName}}\n  \u003cbutton type=\"submit\"\u003eDone\u003c/button\u003e\n{{/view}}\n\n\nAdding New Events\nEmber comes with built-in support for the following native browser\nevents:\n\n\n  \n    Event NameMethod Name\n  \n  \n    touchstarttouchStart\n    touchmovetouchMove\n    touchendtouchEnd\n    touchcanceltouchCancel\n    keydownkeyDown\n    keyupkeyUp\n    keypresskeyPress\n    mousedownmouseDown\n    mouseupmouseUp\n    contextmenucontextMenu\n    clickclick\n    dblclickdoubleClick\n    mousemovemouseMove\n    focusinfocusIn\n    focusoutfocusOut\n    mouseentermouseEnter\n    mouseleavemouseLeave\n    submitsubmit\n    changechange\n    dragstartdragStart\n    dragdrag\n    dragenterdragEnter\n    dragleavedragLeave\n    dragoverdragOver\n    dropdrop\n    dragenddragEnd\n  \n\n\nYou can add additional events to the event dispatcher when you create a\nnew application:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App = Ember.Application.create({\n  customEvents: {\n    // add support for the loadedmetadata media\n    // player event\n    'loadedmetadata': \"loadedMetadata\"\n  }\n});\n\n\n\nIn order for this to work for a custom event, the HTML5 spec must define\nthe event as \"bubbling\", or jQuery must have provided an event\ndelegation shim for the event.\nTemplated Views\nAs you've seen so far in this guide, the majority of views that you will\nuse in your application are backed by a template. When using templates,\nyou do not need to programmatically create your view hierarchy because\nthe template creates it for you.\n\nWhile rendering, the view's template can append views to its child views\narray. Internally, the template's {{view}} helper calls the view's\nappendChild method.\n\nCalling appendChild does two things:\n\n\nAdds the child view to the childViews array.\nImmediately renders the child view and adds it to the parent's render\nbuffer.\n\n\n\n  \n\n\nYou may not call appendChild on a view after it has left the rendering\nstate. A template renders \"mixed content\" (both views and plain text) so\nthe parent view does not know exactly where to insert the new child view\nonce the rendering process has completed.\n\nIn the example above, imagine trying to insert a new view inside of\nthe parent view's childViews array. Should it go immediately\nafter the closing \u003c/div\u003e of App.MyView? Or should it go after the\nclosing \u003c/div\u003e of the entire view? There is no good answer that will\nalways be correct.\n\nBecause of this ambiguity, the only way to create a view hierarchy using\ntemplates is via the {{view}} helper, which always inserts views\nin the right place relative to any plain text.\n\nWhile this works for most situations, occasionally you may want to have\ndirect, programmatic control of a view's children. In that case, you can\nuse Ember.ContainerView, which explicitly exposes a public API for\ndoing so.\nContainer Views\nContainer views contain no plain text. They are composed entirely of\ntheir child views (which may themselves be template-backed).\n\nContainerView exposes two public APIs for changing its contents:\n\n\nA writable childViews array into which you can insert Ember.View\ninstances.\nA currentView property that, when set, inserts the new value into\nthe child views array. If there was a previous value of\ncurrentView, it is removed from the childViews array.\n\n\nHere is an example of using the childViews API to create a view that\nstarts with a hypothetical DescriptionView and can add a new button at\nany time by calling the addButton method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  App.ToolbarView = Ember.ContainerView.create({\n  init: function() {\n    var childViews = this.get('childViews');\n    var descriptionView = App.DescriptionView.create();\n\n    childViews.pushObject(descriptionView);\n    this.addButton();\n\n    return this._super();\n  },\n\n  addButton: function() {\n    var childViews = this.get('childViews');\n    var button = Ember.ButtonView.create();\n\n    childViews.pushObject(button);\n  }\n});\n\n\n\nAs you can see in the example above, we initialize the ContainerView\nwith two views, and can add additional views during runtime. There is a\nconvenient shorthand for doing this view setup without having to\noverride the init method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  App.ToolbarView = Ember.ContainerView.create({\n  childViews: ['descriptionView', 'buttonView'],\n\n  descriptionView: App.DescriptionView,\n  buttonView: Ember.ButtonView,\n\n  addButton: function() {\n    var childViews = this.get('childViews');\n    var button = Ember.ButtonView.create();\n\n    childViews.pushObject(button);\n  }\n});\n\n\n\nAs you can see above, when using this shorthand, you specify the\nchildViews as an array of strings. At initialization time, each of the\nstrings is used as a key to look up a view instance or class. That view\nis automatically instantiated, if necessary, and added to the\nchildViews array.\n\n\n  \n\nTemplate Scopes\nStandard Handlebars templates have the concept of a context--the\nobject from which expressions will be looked up.\n\nWhen a Handlebars template in an Ember app uses an expression\n({{#if foo.bar}}), Ember will automatically set up an\nobserver for that path on the current context.\n\nIf the object referenced by the path changes, Ember will automatically\nre-render the block with the appropriate context. In the case of a\ncontext-preserving helper, Ember will re-use the original context when\nre-rendering the block. Otherwise, Ember will use the new value of the\npath as the context.\n\n  1\n2\n3\n\n  {{#if controller.isAuthenticated}}\n  \u003ch1\u003eWelcome {{controller.name}}\u003c/h1\u003e\n{{/if}}\n\n\n\nIn the above template, when the isAuthenticated property changes from\nfalse to true, Ember will render the block, using the original outer\nscope as its context.\nView Scope\nIn addition to the Handlebars context, templates in Ember also have the\nnotion of the current view. No matter what the current context is, the\nview property always references the closest view.\n\nNote that the view property never references the internal views\ncreated for block expressions like {{#if}}. This allows you to\ndifferentiate between Handlebars contexts, which always work the way\nthey do in vanilla Handlebars, and the view hierarchy.\n\nBecause view points to an Ember.View instance, you can access any\nproperties on the view by using an expression like view.propertyName.\nYou can get access to a view's parent using view.parentView.\n\nFor example, imagine you had a view with the following properties:\n\n  1\n2\n3\n4\n\n  App.MenuItemView = Ember.View.create({\n  templateName: 'menu_item_view',\n  bulletText: '*'\n});\n\n\n\n…and the following template:\n\n  1\n\n  {{view.bulletText}} {{name}}\n\n\n\nYou can still access the view's bulletText by referencing view.bulletText.\nTemplate Variables\nSo far in this guide, we've been handwaving around the use of the\ncontroller property in our Handlebars templates. Where does it come\nfrom?\n\nHandlebars contexts in Ember can inherit variables from their parent\ncontexts. Before Ember looks up a variable in the current context, it\nfirst checks in its template variables. As a template creates new\nHandlebars scope, they automatically inherit the variables from their\nparent scope.\n\nEmber defines these view and controller variables, so they are\nalways found first when an expression uses the view or controller\nnames.\n\nAs described above, Ember sets the view variable on the Handlebars\ncontext whenever a template uses the {{#view}} helper. Initially,\nEmber sets the view variable to the view rendering the template.\n\nEmber sets the controller variable on the Handlebars context whenever\na rendered view has a controller property. If a view has no\ncontroller property, it inherits the controller variable from the\nmost recent view with one.\nOther Variables\nHandlebars helpers in Ember may also specify variables. For example, the\n{{#with controller.person as tom}} form specifies a tom variable\nthat descendent scopes can access. Even if a child context has a tom\nproperty, the tom variable will supersede it.\n\nThis form has one major benefit: it allows you to shorten long paths\nwithout losing access to the parent scope.\n\nIt is especially important in the {{#each}} helper, which provides\nthe {{#each person in people}} form.\nIn this form, descendent context have access to the person variable,\nbut remain in the same scope as where the template invoked the each.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003ch1\u003eTitle\u003c/h1\u003e\n\u003cul\u003e\n{{#each person in controller.people}}\n  {{! prefix here is controller.preferences.prefix }}\n  \u003cli\u003e{{prefix}}: {{person.fullName}}\u003c/li\u003e\n{{/each}}\n\u003cul\u003e\n\n\n\nNote that these variables inherit through ContainerViews, even though\nthey are not part of the Handlebars context hierarchy.\nAccessing Template Variables from Views\nIn most cases, you will need to access these template variables from\ninside your templates. In some unusual cases, you may want to access the\nvariables in-scope from your view's JavaScript code.\n\nYou can do this by accessing the view's templateVariables property,\nwhich will return a JavaScript object containing the variables that were\nin scope when the view was rendered. ContainerViews also have access\nto this property, which references the template variables in the most\nrecent template-backed view.\n\nAt present, you may not observe or bind a path containing\ntemplateVariables.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"70993087a6b865144ac896f587dc0f19","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/understanding-ember-data/record-lifecycle/","type":"enum"},{"name":"body","value":"Ember Data Record Lifecycle\nThe goal of this guide is to walk you through the lifecycle of an Ember\nData record.\n\nThroughout this guide, we will assume the existence of the following\nmodel:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  Person = DS.Model.extend({\n  firstName: DS.attr('string'),\n  lastName: DS.attr('string'),\n  father: DS.belongsTo('Person'),\n\n  name: function() {\n    return this.get('firstName') + ' ' +\n           this.get('lastName')\n  }.property('firstName', 'lastName')\n});\n\n\n\nThe guide will walk through the initial find on the model, how the\nadapter loads the data in from the server, and how the server data is\nmaterialized into an Ember Data record.\nStep 1: Finding a Record\nWhen you request a record using Person.find(1), Ember Data will ask\nthe store to find the record (store.find(Person, 1)).\n\n\n  \n\n\nIf the adapter has not already loaded the record into the store, the\nstore will ask the adapter to fetch it.\n\n\n  \n\n\nSince the adapter's request is asynchronous, the store will return a new\nPerson instance immediately. At this point, the record has no backing\ndata.\n\n\n  \n\nStep 2: Adapter Loads Data Into the Store\nAt some point later, the server will return some data to the adapter.\n\n\n  \n\n\nOnce the adapter receives the data hash, it loads it into the store.\nThe store saves off the data hash for use later. The store will also\nnotify the record that the data hash is available.\n\nThis will, in turn, notify all attributes (DS.attr) and relationships\n(DS.hasMany and DS.belongsTo).\n\n\n  \n\nStep 3: Getting an Attribute\nIn response to the notification, the app will typically request some\nattribute. In this case, imagine that the Person was represented by\nthe following template:\n\n  1\n\n  \u003cp\u003e{{name}}\u003c/p\u003e\n\n\n\nWhen the template renders, it will register an observer on the\nname property, which depends on firstName and lastName. Once the\ndata hash loads in from the server, the registered observer will call\nperson.get('name') to update the DOM. This will call\nperson.get('firstName').\n\n\n  \n\nStep 4: Materialization\nBecause this is the first time the record needs its backend-provided\ndata, it will ask the store to load it in using materializeData.\n\n\n  \n\n\nThe store will, in turn, ask the adapter to materialize the data. This\nallows the adapter to apply adapter-specific mappings to the\nbackend-provided data hash.\n\n\n  \n\n\nFinally, the adapter asks its serializer object to perform the\nmaterialization. In general, the adapter is responsible for working with\nthe backend, and the serializer is responsible for materializing\nbackend-provided data hashes into records, and serializing records into\nJSON hashes for the backend.\n\n\n  \n\n\nThe serializer is now responsible for extracting the information from\nthe backend-provided data hash and hydrating the record object. First,\nit populates the record's id.\n\n\n  \n\n\nNext, it populates the record's attributes.\n\n\n  \n\n\nFinally, it populates the belongsTo association.\n\n\n  \n\n\nOnce the adapter finishes materializing the record, it returns the\nrequested firstName.\n\nBecause the adapter has already populated the record, trying to get\nits lastName will not trigger additional materialization.\nIdentity Map\nAdditional requests for Person 1 will skip all of these steps, because\nstore.find(Person, 1) will see that it has already created an instance\nfor that record and return it.\n\nThis means that all requests for a record with the same model type and\nID will return the same object.\n\nThis feature is known as an \"identity map\", because it guarantees\nJavaScript identity for objects representing the same backend data.\nPractical Note\nIn the example above, we used a template that rendered the Person\nobject directly. As a result, we got partially loaded output that\nautomatically filled in as the data loaded.\n\nYou may want this behavior in some cases, but in most cases, your\ntemplate would look something like this:\n\n  1\n2\n3\n4\n5\n\n  {{#if isLoaded}}\n  \u003cp\u003e{{name}}\u003c/p\u003e\n{{else}}\n  \u003cimg src=\"/images/spinner.gif\"\u003e\n{{/if}}\n\n\n\nWhen the adapter loads the backend-provided hash into the store, the\nstore moves the record into the loaded state, which changes its\nisLoaded flag to true.\n\nThat will notify an observer set up by the template that isLoaded has\nchanged, which will cause the template to render the first branch\n(containing \u003cp\u003e{{name}}\u003c/p\u003e) instead of the spinner.\n\nWhen it renders that branch, the template will trigger the same\nget('name') that caused materialization in the above example.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9abe4a0a224c7b4dd7e1723da4745aa3","fields":[{"name":"title","value":"Adding Layouts to Views","type":"string"},{"name":"url","value":"/views/adding-layouts-to-views/","type":"enum"},{"name":"body","value":"Views can have a secondary template that wraps their main template. Like templates,\nlayouts are Handlebars templates that will be inserted inside the\nview's tag.\n\nTo tell a view which layout template to use, set its layoutName property.\n\nTo tell the layout template where to insert the main template, use the Handlebars {{yield}} helper.\nThe HTML contents of a view's rendered template will be inserted where the {{yield}} helper is.\n\nFirst, you define the following layout template:\n\n  1\n2\n3\n4\n5\n\n  \u003cscript type=\"text/x-handlebars\" data-template-name=\"my_layout\"\u003e\n  \u003cdiv class=\"content-wrapper\"\u003e\n    {{yield}}\n  \u003c/div\u003e\n\u003c/script\u003e\n\n\n\nAnd then the following main template:\n\n  1\n2\n3\n\n  \u003cscript type=\"text/x-handlebars\" data-template-name=\"my_content\"\u003e\n  Hello, \u003cb\u003e{{view.name}}\u003c/b\u003e!\n\u003c/script\u003e\n\n\n\nFinally, you define a view, and instruct it to wrap the template with the defined layout:\n\n  1\n2\n3\n4\n5\n\n  AViewWithLayout = Ember.View.extend({\n  name: 'Teddy',\n  layoutName: 'my_layout',\n  templateName: 'my_content'\n});\n\n\n\nThis will result in view instances containing the following HTML\n\n  1\n2\n3\n\n  \u003cdiv class=\"content-wrapper\"\u003e\n  Hello, \u003cb\u003eTeddy\u003c/b\u003e!\n\u003c/div\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e4dbe164d62822f5bf37e0b88bd19f96","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/views/building-reusable-views/","type":"enum"},{"name":"body","value":"ZOMGTREK","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3e49b1636055b7f6c48acfb964ac9f48","fields":[{"name":"title","value":"Built-in Views","type":"string"},{"name":"url","value":"/views/built-in-views/","type":"enum"},{"name":"body","value":"Ember comes pre-packaged with a set of views for building a basic controls like text inputs, check boxes, and select lists. Usually, these views will be used via the input helpers. However, the base views may be helpful in creating custom form behaviors.\n\n\nEmber.Checkbox\nEmber.TextField\nEmber.TextArea\n\n\nFor example, here we have created a custom text field that toggles a dirty property:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  // {{view \"my-text\" value=name inputDidChange=nameDidChange}}\nApp.MyTextView = Ember.TextField.extend({\n  inputDidChange: false,\n  change: function() {\n    this.set('inputDidChange', true);\n  }\n});\n\n\n\nEmber itself provides one additional view not covered by the input helpers, and this is the select box view.\n\n\nEmber.Select\n\n\nThis class can also be customized by extending it. To use the select view bundled with Ember, call it via the view helper:\n\n  1\n2\n3\n4\n5\n\n  {{view \"select\" content=people\n                optionLabelPath=\"content.fullName\"\n                optionValuePath=\"content.id\"\n                prompt=\"Pick a person:\"\n                selection=selectedPerson}}\n\n\n\nThe select view is extremely feature-rich, and may perform badly when rendering many items. Due to this, it has not yet been converted into an component or helper like other inputs.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"7b97e923f66a0d4d78a9e2a914b543da","fields":[{"name":"title","value":"Customizing a View's Element","type":"string"},{"name":"url","value":"/views/customizing-a-views-element/","type":"enum"},{"name":"body","value":"A view is represented by a single DOM element on the page. You can change what kind of element is created by\nchanging the tagName property.\n\n  1\n2\n3\n\n  App.MyView = Ember.View.extend({\n  tagName: 'span'\n});\n\n\n\nYou can also specify which class names are applied to the view by setting its classNames property to an array of strings:\n\n  1\n2\n3\n\n  App.MyView = Ember.View.extend({\n  classNames: ['my-view']\n});\n\n\n\nIf you want class names to be determined by the state of properties on the view, you can use class name bindings. If you bind to\na Boolean property, the class name will be added or removed depending on the value:\n\n  1\n2\n3\n4\n\n  App.MyView = Ember.View.extend({\n  classNameBindings: ['isUrgent'],\n  isUrgent: true\n});\n\n\n\nThis would render a view like this:\n\n  1\n\n  \u003cdiv class=\"ember-view is-urgent\"\u003e\n\n\n\nIf isUrgent is changed to false, then the is-urgent class name will be removed.\n\nBy default, the name of the Boolean property is dasherized. You can customize the class name\napplied by delimiting it with a colon:\n\n  1\n2\n3\n4\n\n  App.MyView = Ember.View.extend({\n  classNameBindings: ['isUrgent:urgent'],\n  isUrgent: true\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view urgent\"\u003e\n\n\n\nBesides the custom class name for the value being true, you can also specify a class name which is used when the value is false:\n\n  1\n2\n3\n4\n\n  App.MyView = Ember.View.extend({\n  classNameBindings: ['isEnabled:enabled:disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nYou can also specify to only add a class when the property is false by declaring classNameBindings like this:\n\n  1\n2\n3\n4\n\n  App.MyView = Ember.View.extend({\n  classNameBindings: ['isEnabled::disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nIf the isEnabled property is set to true, no class name is added:\n\n  1\n\n  \u003cdiv class=\"ember-view\"\u003e\n\n\n\nIf the bound value is a string, that value will be added as a class name without\nmodification:\n\n  1\n2\n3\n4\n\n  App.MyView = Ember.View.extend({\n  classNameBindings: ['priority'],\n  priority: 'highestPriority'\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view highestPriority\"\u003e\n\n\nAttribute Bindings on a View\nYou can bind attributes to the DOM element that represents a view by using attributeBindings:\n\n  1\n2\n3\n4\n5\n\n  App.MyView = Ember.View.extend({\n  tagName: 'a',\n  attributeBindings: ['href'],\n  href: \"http://emberjs.com\"\n});\n\n\n\nYou can also bind these attributes to differently named properties:\n\n  1\n2\n3\n4\n5\n\n  App.MyView = Ember.View.extend({\n  tagName: 'a',\n  attributeBindings: ['customHref:href'],\n  customHref: \"http://emberjs.com\"\n});\n\n\nCustomizing a View's Element from Handlebars\nWhen you append a view, it creates a new HTML element that holds its content.\nIf your view has any child views, they will also be displayed as child nodes\nof the parent's HTML element.\n\nBy default, new instances of Ember.View create a \u003cdiv\u003e element. You can\noverride this by passing a tagName parameter:\n\n  1\n\n  {{view \"info\" tagName=\"span\"}}\n\n\n\nYou can also assign an ID attribute to the view's HTML element by passing an id parameter:\n\n  1\n\n  {{view \"info\" id=\"info-view\"}}\n\n\n\nThis makes it easy to style using CSS ID selectors:\n\n  1\n2\n3\n4\n\n  /** Give the view a red background. **/\n#info-view {\n  background-color: red;\n}\n\n\n\nYou can assign class names similarly:\n\n  1\n\n  {{view \"info\" class=\"info urgent\"}}\n\n\n\nYou can bind class names to a property of the view by using classBinding instead of class. The same behavior as described in bind-attr applies:\n\n  1\n2\n3\n4\n\n  App.AlertView = Ember.View.extend({\n  priority: \"p4\",\n  isUrgent: true\n});\n\n\n\n  1\n\n  {{view \"alert\" classBinding=\"isUrgent priority\"}}\n\n\n\nThis yields a view wrapper that will look something like this:\n\n  1\n\n  \u003cdiv id=\"ember420\" class=\"ember-view is-urgent p4\"\u003e\u003c/div\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"99372a2930dba75d6ceeb1e3c4db65cd","fields":[{"name":"title","value":"Defining a View","type":"string"},{"name":"url","value":"/views/defining-a-view/","type":"enum"},{"name":"body","value":"You can use Ember.View to render a Handlebars template and insert it into the DOM.\n\nTo tell the view which template to use, set its templateName property. For example, if I had a \u003cscript\u003e tag like this:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003chtml\u003e\n  \u003chead\u003e\n    \u003cscript type=\"text/x-handlebars\" data-template-name=\"say-hello\"\u003e\n      Hello, \u003cb\u003e{{view.name}}\u003c/b\u003e\n    \u003c/script\u003e\n  \u003c/head\u003e\n\u003c/html\u003e\n\n\n\nI would set the templateName property to \"say-hello\".\n\n  1\n2\n3\n4\n\n  var view = Ember.View.create({\n  templateName: 'say-hello',\n  name: \"Bob\"\n});\n\n\n\nNote: For the remainder of the guide, the templateName property will be omitted from most examples. You can assume that if we show a code sample that includes an Ember.View and a Handlebars template, the view has been configured to display that template via the templateName property.\n\nYou can append views to the document by calling appendTo:\n\n  1\n\n  view.appendTo('#container');\n\n\n\nAs a shorthand, you can append a view to the document body by calling append:\n\n  1\n\n  view.append();\n\n\n\nTo remove a view from the document, call remove:\n\n  1\n\n  view.remove();\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"1ad48073ebb749972afb87f99875d99a","fields":[{"name":"title","value":"Handling Events","type":"string"},{"name":"url","value":"/views/handling-events/","type":"enum"},{"name":"body","value":"Instead of having to register event listeners on elements you'd like to\nrespond to, simply implement the name of the event you want to respond to\nas a method on your view.\n\nFor example, imagine we have a template like this:\n\n  1\n2\n3\n\n  {{#view \"clickable\"}}\nThis is a clickable area!\n{{/view}}\n\n\n\nLet's implement App.ClickableView such that when it is\nclicked, an alert is displayed:\n\n  1\n2\n3\n4\n5\n\n  App.ClickableView = Ember.View.extend({\n  click: function(evt) {\n    alert(\"ClickableView was clicked!\");\n  }\n});\n\n\n\nEvents bubble up from the target view to each parent view in succession,\nuntil the root view. These values are read-only. If you want to\nmanually manage views in JavaScript (instead of creating them using\nthe {{view}} helper in Handlebars), see the Ember.ContainerView\ndocumentation below.\nSending Events\nTo have the click event from App.ClickableView affect the state of your application, simply send an event to the view's controller:\n\n  1\n2\n3\n4\n5\n\n  App.ClickableView = Ember.View.extend({\n  click: function(evt) {\n    this.get('controller').send('turnItUp', 11);\n  }\n});\n\n\n\nIf the controller has an action handler called turnItUp, it will be called:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.PlaybackController = Ember.ObjectController.extend({\n  actions: {\n    turnItUp: function(level){\n      //Do your thing\n    }\n  }\n});\n\n\n\nIf it doesn't, the message will be passed to the current route:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App.PlaybackRoute = Ember.Route.extend({\n  actions: {\n    turnItUp: function(level){\n      //This won't be called if it's defined on App.PlaybackController\n    }\n  }\n});\n\n\n\nTo see a full listing of the Ember.View built-in events, see the\ndocumentation section on Event Names.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"62a94fb99b85945d4fc027b44f150a62","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/views/","type":"enum"},{"name":"body","value":"Because Handlebars templates in Ember.js are so powerful, the majority\nof your application's user interface will be described using them. If\nyou are coming from other JavaScript libraries, you may be surprised at\nhow few views you have to create.\n\nViews in Ember.js are typically only created for the following reasons:\n\n\nWhen you need sophisticated handling of user events\nWhen you want to create a re-usable component\n\n\nOften, both of these requirements will be present at the same time.\nEvent Handling\nThe role of the view in an Ember.js application is to translate\nprimitive browser events into events that have meaning to your\napplication.\n\nFor example, imagine you have a list of todo items. Next to each todo is\na button to delete that item:\n\n\n\nThe view is responsible for turning a primitive event (a click) into a\nsemantic event: delete this todo! These semantic events are first sent \nup to the controller, or if no method is defined there, your application's \nrouter, which is responsible for reacting to the event based on the \ncurrent state of the application.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b16f3beecbf81e69c258e6d7f209cb19","fields":[{"name":"title","value":"Inserting Views in Templates","type":"string"},{"name":"url","value":"/views/inserting-views-in-templates/","type":"enum"},{"name":"body","value":"So far, we've discussed writing templates for a single view. However, as your application grows, you will often want to create a hierarchy of views to encapsulate different areas on the page. Each view is responsible for handling events and maintaining the properties needed to display it.\n{{view}}\nTo add a child view to a parent, use the {{view}} helper. The {{view}} helper takes a string used to look up the view class.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  // Define parent view\nApp.UserView = Ember.View.extend({\n  templateName: 'user',\n\n  firstName: \"Albert\",\n  lastName: \"Hofmann\"\n});\n\n// Define child view\nApp.InfoView = Ember.View.extend({\n  templateName: 'info',\n\n  posts: 25,\n  hobbies: \"Riding bicycles\"\n});\n\n\n\n  1\n2\n3\n4\n\n  \u003cscript type=\"text/x-handlebars\" data-template-name=\"user\"\u003e\n  User: {{view.firstName}} {{view.lastName}}\n  {{view \"info\"}}\n\u003c/script\u003e\n\n\n\n  1\n2\n3\n4\n5\n\n  \u003cscript type=\"text/x-handlebars\" data-template-name=\"info\"\u003e\n  \u003cb\u003ePosts:\u003c/b\u003e {{view.posts}}\n  \u003cbr\u003e\n  \u003cb\u003eHobbies:\u003c/b\u003e {{view.hobbies}}\n\u003c/script\u003e\n\n\n\nIf we were to create an instance of App.UserView and render it, we would get\na DOM representation like this:\n\n  1\n2\n3\n4\n5\n6\n\n  User: Albert Hofmann\n\u003cdiv\u003e\n  \u003cb\u003ePosts:\u003c/b\u003e 25\n  \u003cbr\u003e\n  \u003cb\u003eHobbies:\u003c/b\u003e Riding bicycles\n\u003c/div\u003e\n\n\nRelative Paths\nInstead of specifying an absolute path, you can also specify which view class\nto use relative to the parent view. For example, we could nest the above view\nhierarchy like this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  App.UserView = Ember.View.extend({\n  templateName: 'user',\n\n  firstName: \"Albert\",\n  lastName: \"Hofmann\",\n\n  infoView: Ember.View.extend({\n    templateName: 'info',\n\n    posts: 25,\n    hobbies: \"Riding bicycles\"\n  })\n});\n\n\n\n  1\n2\n\n  User: {{view.firstName}} {{view.lastName}}\n{{view view.infoView}}\n\n\n\nWhen using the view helper with a property, prefer starting the property name with a lowercase letter. Using an uppercase letter, such as in {{view MyClass}} may trigger a deprecated use-case.\nSetting Child View Templates\nIf you'd like to specify the template your child views use inline in\nthe main template, you can use the block form of the {{view}} helper.\nWe might rewrite the above example like this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  App.UserView = Ember.View.extend({\n  templateName: 'user',\n\n  firstName: \"Albert\",\n  lastName: \"Hofmann\"\n});\n\nApp.InfoView = Ember.View.extend({\n  posts: 25,\n  hobbies: \"Riding bicycles\"\n});\n\n\n\n  1\n2\n3\n4\n5\n6\n\n  User: {{view.firstName}} {{view.lastName}}\n{{#view \"info\"}}\n  \u003cb\u003ePosts:\u003c/b\u003e {{view.posts}}\n  \u003cbr\u003e\n  \u003cb\u003eHobbies:\u003c/b\u003e {{view.hobbies}}\n{{/view}}\n\n\n\nWhen you do this, it may be helpful to think of it as assigning views to\nportions of the page. This allows you to encapsulate event handling for just\nthat part of the page.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"7bdc4108734011d72e1ca19d88932dbb","fields":[{"name":"title","value":"Manually Managing View Hierarchy","type":"string"},{"name":"url","value":"/views/manually-managing-view-hierarchy/","type":"enum"},{"name":"body","value":"Ember.ContainerView\nAs you probably know by now, views usually create their child views\nby using the {{view}} helper. However, it is sometimes useful to\nmanually manage a view's child views.\nEmber.ContainerView\nis the way to do just that.\n\nAs you programmatically add or remove views to a ContainerView,\nthose views' rendered HTML are added or removed from the DOM to\nmatch.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  var container = Ember.ContainerView.create();\ncontainer.append();\n\nvar firstView = App.FirstView.create(),\n    secondView = App.SecondView.create();\n\ncontainer.pushObject(firstView);\ncontainer.pushObject(secondView);\n\n// When the rendering completes, the DOM\n// will contain a `div` for the ContainerView\n// and nested inside of it, a `div` for each of\n// firstView and secondView.\n\n\nDefining the Initial Views of a Container View\nThere are a few ways to specify which initial child views a\nContainerView should render. The most straight-forward way is to add\nthem in init:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var container = Ember.ContainerView.create({\n  init: function() {\n    this._super();\n    this.pushObject(App.FirstView.create());\n    this.pushObject(App.SecondView.create());\n  }\n});\n\ncontainer.objectAt(0).toString(); //=\u003e '\u003cApp.FirstView:ember123\u003e'\ncontainer.objectAt(1).toString(); //=\u003e '\u003cApp.SecondView:ember124\u003e'\n\n\n\nAs a shorthand, you can specify a childViews property that will be\nconsulted on instantiation of the ContainerView also. This example is\nequivalent to the one above:\n\n  1\n2\n3\n4\n5\n6\n\n  var container = Ember.ContainerView.extend({\n  childViews: [App.FirstView, App.SecondView]\n});\n\ncontainer.objectAt(0).toString(); //=\u003e '\u003cApp.FirstView:ember123\u003e'\ncontainer.objectAt(1).toString(); //=\u003e '\u003cApp.SecondView:ember124\u003e'\n\n\n\nAnother bit of syntactic sugar is available as an option as well:\nspecifying string names in the childViews property that correspond\nto properties on the ContainerView. This style is less intuitive\nat first but has the added bonus that each named property will\nbe updated to reference its instantiated child view:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  var container = Ember.ContainerView.create({\n  childViews: ['firstView', 'secondView'],\n  firstView: App.FirstView,\n  secondView: App.SecondView\n});\n\ncontainer.objectAt(0).toString(); //=\u003e '\u003cApp.FirstView:ember123\u003e'\ncontainer.objectAt(1).toString(); //=\u003e '\u003cApp.SecondView:ember124\u003e'\n\ncontainer.get('firstView').toString(); //=\u003e '\u003cApp.FirstView:ember123\u003e'\ncontainer.get('secondView').toString(); //=\u003e '\u003cApp.SecondView:ember124\u003e'\n\n\nIt Feels Like an Array Because it is an Array\nYou may have noticed that some of these examples use pushObject to add\na child view, just like you would interact with an Ember array.\nEmber.ContainerView\ngains its collection-like behavior by mixing in\nEmber.MutableArray. That means\nthat you can manipulate the collection of views very expressively, using\nmethods like pushObject, popObject, shiftObject, unshiftObject, insertAt,\nremoveAt, or any other method you would use to interact with an Ember array.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"573ebd0a894568fd10e3a3598b0312d6","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/wip/basic-ajax/","type":"enum"},{"name":"body","value":"Loading and Saving Data With jQuery's Ajax\nThe easiest way to get started with data hosted on an external service\nis to fetch that data directly in the model hook of a route and to\nsave it in an action of your route.\nWhen to Use This Technique\nYou should use jQuery Ajax to communicate with your server if:\n\n\nYou are getting started with Ember, and already understand basic Ajax\nand want to get some data into your app quickly and easily.\nYou are working with simple models, with few relationships between\nthem (or relationships that you load and save all at once).\nYou don't have the same models represented in many places, or are\nwilling to roll your own identity map when the situation arises.\nYou are willing to make frequent Ajax requests as your user navigates\naround the page, or are willing to roll your own in-memory cache.\n\n\nSee the bottom of this guide for a brief description of other, more\nadvanced ways you can work with data, and links to guides about \nGetting Data Into Your App\nWhen your user enters a route, Ember will ask the associated\nEmber.Route object to convert the current URL into a model.\n\nFor example, if you have a posts resource:\n\n  1\n2\n3\n\n  App.Router.map(function() {\n  this.resource('posts');\n});\n\n\n\nWhen the user goes to /posts, Ember will ask App.PostsRoute which\nmodel to use. This method, called the \"model hook\", can return an Array,\nwhich will then become the model for the posts template. \n\n  1\n2\n3\n4\n5\n\n  App.PostsRoute = Ember.Route.extend({\n  model: function() {\n    return [...];\n  }\n});\n\n\n\nThat's all well and good, but it assumes that you have all of the data\nalready available. In practice, you will usually need to get it from the\nserver before proceeding.\n\nThe good news is that Ember allows you to return a Promise, a\nJavaScript object that represents a value that will eventually arrive\n(sometimes called an \"eventual value\").\n\nYou may be asking: that sounds cool, but how do I make an \"eventual\nvalue\"? jQuery's Ajax methods all return Promises by default!\n\nIf you want to tell Ember that the model for a route is the result of\nmaking an Ajax request instead of a value that you have locally, just\nreturn a jQuery Ajax request.\n\n  1\n2\n3\n4\n5\n\n  App.PostsRoute = Ember.Route.extend({\n  model: function() {\n    return $.getJSON(\"/posts\");\n  }\n});\n\n\nMunging Data\nIf you want to do some data munging before setting the model, just do it\nin the success handler of the Ajax request. Whatever value you return\nfrom the success handler will become the model.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  App.PostsRoute = Ember.Route.extend({\n  model: function() {\n    return $.getJSON(\"/posts\").then(function(json) {\n      return json.map(function(post) {\n        return { title: post.TTL, body: post.BDY };\n      });\n    });\n  }\n});\n\n\nParameter-Based Models\nAll of that works great for routes that only have a single model\nassociated with them. But what about routes that use :post_id to allow\na single route to represent many different models?\n\n  1\n2\n3\n4\n\n  App.Router.map(function() {\n  this.resource('posts');\n  this.resource('post', { path: '/posts/:post_id' });\n});\n\n\n\nIn this case, the model for URLs like /posts/1 will be different based\non the actual value of post_id.\n\nIn this situation, the model method will receive the parameters\nextracted from the URL, and should use it to return the specific model\nin question.\n\nFirst, if you already have the data locally:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n  var posts = [{\n  id: \"1\",\n  title: \"Rails is omakase\",\n  body: \"...\"\n}, {\n  id: \"2\",\n  title: \"The Parley Letter\",\n  body: \"...\"\n}];\n\nApp.PostsRoute = Ember.Route.extend({\n  // as before, just return the local list of posts\n  model: function() {\n    return posts;\n  }\n});\n\nApp.PostRoute = Ember.Route.extend({\n  // we'll need to use the :post_id param to figure out which model to\n  // use, and it's available in `params`\n  model: function(params) {\n    return posts.findBy('id', params.post_id);\n  }\n});\n\n\n\nAgain, this case isn't very interesting. You'll normally get your data\nfrom the server. As before, we can replace our code with an Ajax lookup.\nBecause jQuery provides promises by default, we can return the result of\na call to $.getJSON.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  App.PostsRoute = Ember.Route.extend({\n  model: function() {\n    return $.getJSON(\"/posts\");\n  }\n});\n\nApp.PostRoute = Ember.Route.extend({\n  model: function(params) {\n    return $.getJSON(\"/posts/\" + params.post_id);\n  }\n});\n\n\n\nEmber will automatically wait for these Ajax calls to complete before\nrendering your templates, so the Ajax-based routes behave exactly the\nsame as the synchronous versions.\n\nAs a result, you can often start by prototyping with synchronous model\nhooks, and upgrade to Ajax once your app is further along.\nDrilling in to Collections\nIn the Ajax examples below, drilling in to an individual post triggered\na second Ajax call. We will need to do that if the user enters the app\nfrom an individual post's page, but if she entered from the index, we'd\nprefer to use the post we already downloaded.\n\nIn order to achieve this, you can build a simple cache that will first\ntry to use loaded data before fetching.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n  // A simple cache class\nApp.Cache = Ember.Object.extend({\n  init: function() {\n    this._models = {};\n  },\n\n  /**\n    Fetch a model by ID and URL. If the model is already in the cache,\n    return it. Otherwise, return an Ajax request for the URL. When the\n    Ajax response comes back, put the model in the cache so we don't\n    make another Ajax request later.\n  */\n  fetch: function(id, url) {\n    var models = this._models;\n\n    if (id in models) {\n      return models[id];\n    }\n\n    return $.getJSON(url).then(function(json) {\n      models[id] = json;\n      return json;\n    });\n  },\n\n  /**\n    Fetch an Array of models by URL. Return an Ajax request for the URL.\n    When the Ajax response comes back, but the models in the cache by\n    their individual `id` property.\n  */\n  fetchAll: function(url) {\n    return $.getJSON(url).then(function(json) {\n      json.forEach(function(model) {\n        models[model.id] = model;\n      });\n      return json;\n    }\n  }\n});\n\n\n\nThen, we can use the cache in our model hooks:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  App.CacheController = Ember.Controller.extend({\n  init: function() {\n    this.posts = App.Cache.create();\n  }\n});\n\nApp.PostsRoute = Ember.Route.extend({\n  model: function() {\n    return this.controllerFor('cache')\n      .posts.fetchAll('/posts');\n  }\n});\n\nApp.PostRoute = Ember.Route.extend({\n  model: function(params) {\n    return this.controllerFor('cache')\n      .posts.fetch(params.post_id, '/posts/' + params.post_id);\n  }\n});\n\n\n\nBy putting the cache in a controller, we make sure that using\nApp.reset() to reset the application (in tests, or when the user logs\nout) will also clear the cache.\n\nThis is just a very simple caching implementation. If you have more\ncomplex caching needs, or if you need relationships between models, you\nprobably will want to use Ember Data, which handles much more\nsophisticated scenarios.\nPartial ModelsMore Advanced Techniques\nThere are several more advanced techniques, which provide more power,\nbut which require more up-front learning. You might want to consider\nusing one of these techniques if you have complex relationships or a\nneed for in-memory caching of models.\n\nYou can learn more about how to use Ember Data in these guides.\n\n\n[Using Ember Data as an in-memory cache][1]. You can still write all\nyour own Ajax code, and use Ember Data as an in-memory cache with\nrelationship support and a structured Adapter API for organizing your\nAjax code better.\n[Using the Ember Data REST Adapter][2]. If your server uses relatively\nconventional REST semantics, you can take advantage of the built-in\nREST Adapter, which will build your URLs, make Ajax requests with the\nappropriate headers and body, and deserialize the return value. It\nalso provides a pattern for receiving multiple records at once, known\nas \"sideloading\".\n[Using the Ember Data ActiveModel Adapter][3]. If your server uses\nRails-like semantics, such as underscored keys, you can take advantage\nof the ActiveModel Adapter, which will convert Rails conventions into\nEmber conventions.\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a7d5a821364ac4efc3cba2ff019b17e0","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/wip/data-introduction/","type":"enum"},{"name":"body","value":"Getting Data Into Your App\nEmber.js gives you the tools you need to keep your models synchronized\nwith your UI. That's great, but how do you get data into your models in\nthe first place?\n\nTo recap, Ember.js pages have a lifecycle that is designed to make it\neasy to keep your data and URL in sync.\n\n\nWhen the user loads the application, Ember looks at the URL and\ninvokes the model hooks in the Routes specified by your router\ndefinition.\nEmber then renders the templates for those routes, hooking up the\nmodel to the template.\nWhen a template uses {{link-to 'route'}}, Ember automatically\ngenerates a URL from the router definition.\nWhen the user clicks on the link, Ember renders the template for the\nroute specified in the link-to. If any models were specified\n({{link-to 'post' post}}), Ember will hook up the specified model to\nthe template it renders.\nAlso, when the user clicks on the link, Ember will update the URL.\n\n\n\nInsert Diagram Here\n\n\nAs far as Ember is concerned, you can return any JavaScript object from\nthe model hook, including a plain JavaScript object, so you can work\nwith raw JSON requests to your server if you want.\n\nIn practice, you will probably want more structure in your model layer,\nand Ember Data provides additional features that may help you:\n\n\nModel objects that can contain additional computed properties and\nmethods, rather than working directly with Plain Old JavaScript\nObjects.\nA built-in cache so that you can avoid making additional Ajax requests\nif the data you need is already available in memory.\nFlags on each model that you can use to determine whether a record is\nloading, saving, dirty, newly created, deleted, and more. You can use\nthese flags to control the UI. For example, you may want to show some UI\n(a spinner) when a record is saving, or disable editing when it's\nsaving.\nAutomatic, efficient filters on your models that you can use to build\nlive arrays that match conditions on each record. For example, you\ncould build a live array that contained only Person records whose\nlast name was \"Lannister\" or whose isSaving flag was true. The\narrays are updated incrementally only when the properties change.\nSupport for several different kinds of relationships. Relationships\ncan be populated with an Array of IDs, a URL, or determined lazily\nbased on information in the parent model.\nWhen relationships are specified by ID, avoiding additional fetches\nfrom the server for records that are already loaded.\nSupport for saving records, and tracking what exactly has changed on\nyour model object.\nSupport for rolling back changes that the user made since the last\nfetch or save. This makes it easy to implement cancel buttons, for\nexample.\nA well-defined separation between your model objects, how they are\nfetched from the server, how they are converted into the form\nexpected by your application, and how they are saved back to the\nserver.\n\n\nIn addition to these features, Ember Data comes with built-in support\nfor REST-like APIs. If your server's API is close to the API that the\nRESTAdapter expects, you can avoid having to write explicit Ajax code\nand serialization/deserialization logic.\n\nSome features of the RESTAdapter:\n\n\nAutomatically builds URLs for you based on the name of your model\nclass.\nAutomatically makes Ajax requests to the built URL, ensuring that the\nright headers are present and any data is serialized correctly.\nHandles payloads that contain multiple records at a time, so you can\nmake a single HTTP request and get back multiple records.\nHandles server responses that embed models inside of other models.\nHandles \"sideloading\"—returning a normalized payload with all\nrecords grouped by type instead of embedded. This allows you to avoid\nduplicating records that are referenced by multiple other records\n(such as the author of a blog post—sideloading allows you to\ninclude the author of multiple posts one time in the payload).\nAllows pushing data embedded in the HTML using the same structure as\nyour server's normal Ajax responses as an initial payload (to improve \nperformance).\n\n\nAdditionally, by using any Adapter (either by making your own Ajax\nrequests or using the built-in REST Adapter), you can prototype your\napplication using the Fixture Adapter and upgrade your models to use the\nserver when you're ready.\n\nYou can also make these decisions on a model-by-model basis. You might\nhave some models using raw Ajax in the model hook, some models using\nthe raw Adapter API, some models using the REST Adapter, and newer parts\nof your application on fixtures.\n\nThe rest of the guides in this section walk you through how to use each\nof these techniques, and go into more detail about when each one is\nappropriate.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f6c247b0d91025035e94c7c3aa7a6d3b","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/wip/outlets/","type":"enum"},{"name":"body","value":"Ember Application Structure\nOn a high-level, you structure an Ember application by designing a series of nested routes that correspond to nested application state. This guide will first cover the high-level concepts, and then walk you through an example.\nRouting\nA user navigates through your application by making choices about what\nto view. For example, if you had a blog, your user might first choose\nbetween your Posts and your About page. In general, you want to have a\ndefault for this first choice (in this case, probably Posts).\n\nOnce the user has made their first choice, they're usually not done. In\nthe context of Posts, the user will eventually view an individual post\nand its comments. Inside of an individual post, they can choose between\nviewing a list of comments and a list of trackbacks.\n\nImportantly, in all of these cases, the user is choosing what to display\non the page. As you descend deeper into your application state, those\nchoices affect smaller areas of the page.\n\nIn the next section, we'll cover how you control these areas of the\npage. For now, let's look at how to structure your templates.\n\nWhen the user first enters the application, the application is on the\nscreen, and it has an empty outlet that the router will control. In\nEmber, an outlet is an area of a template that has its child template\ndetermined at runtime based on user interaction.\n\n\n  \n\n\nThe template for the Application (application.handlebars) will look\nsomething like this:\n\n  1\n2\n3\n\n  \u003ch1\u003eMy Application\u003c/h1\u003e\n\n{{outlet}}\n\n\n\nBy default, the router will initially enter the list of posts state,\nand fill in the outlet with posts.handlebars. We will see later how\nthis works exactly.\n\n\n  \n\n\nAs expected, the list of posts template will render a list of posts.\nClicking on the link for an individual post will replace the contents of\nthe application's outlet with the template for an individual post.\n\nThe template will look like this:\n\n  1\n2\n3\n4\n\n  {{#each post in controller}}\n\u003ch1\u003e\u003ca {{action 'showPost' post href=true}}\u003e{{post.title}}\u003c/a\u003e\u003c/h1\u003e\n\u003cdiv\u003e{{post.intro}}\u003c/div\u003e\n{{/each}}\n\n\n\nWhen clicking on a link for an individual post, the application will\nmove into the individual post state, and replace posts.handlebars in\nthe application's outlet with post.handlebars.\n\n\n  \n\n\nIn this case, the individual post also has an outlet. In this case, the\noutlet will allow the user to choose between viewing comments or\ntrackbacks.\n\nThe template for an individual post looks like this:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\n\u003cdiv class=\"body\"\u003e\n  {{body}}\n\u003c/div\u003e\n\n{{outlet}}\n\n\n\nAgain, the {{outlet}} simply specifies that the router will make the\ndecision about what to put in that area of the template.\n\nBecause {{outlet}} is a feature of all templates, as you go deeper\ninto the route hierarchy, each route will naturally control a smaller\npart of the page.\nHow it Works\nNow that you understand the basic theory, let's take a look at how the\nrouter controls your outlets (for a more extensive treatment of the\nRouter, please consult the \"Router Primer\" guide).\nTemplates, Controllers, and Views\nFirst, for every high-level handlebars template, you will also have a\nview and a controller with the same name. For example:\n\n\napplication.handlebars: the template for the main application view\nApp.ApplicationController: the controller for the template. The\ninitial variable context of application.handlebars is an instance of\nthis controller.\nApp.ApplicationView: the view object for the template.\n\n\nIn general, you will use view objects to handle events and controller\nobjects to provide data to your templates.\n\nEmber provides two primary kinds of controllers, ObjectController and\nArrayController. These controllers serve as proxies for model objects\nand lists of model objects.\n\nWe start with controllers rather than exposing the model objects\ndirectly to your templates so that you have someplace to put\nview-related computed properties and don't end up polluting your models\nwith view concerns.\n\nYou also connect {{outlet}}s using the template's associated\ncontroller.\nThe Router\nYour application's router is responsible for moving your application\nthrough its states in response to user action.\n\nLet's start with a simple router:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  App.Router = Ember.Router.extend({\n  root: Ember.Route.extend({\n    index: Ember.Route.extend({\n      route: '/',\n      redirectsTo: 'posts'\n    }),\n\n    posts: Ember.Route.extend({\n      route: '/posts'\n    }),\n\n    post: Ember.Route.extend({\n      route: '/posts/:post_id'\n    })\n  })\n});\n\n\n\nThis router sets up three top-level states: an index state, a state that\nshows a list of posts, and a state that shows an individual post.\n\nIn our case, we'll simply redirect the index route to the posts state.\nIn other applications, you may want to have a dedicated home page.\n\nSo far, we have a list of states, and our app will dutifully enter the\nposts state, but it doesn't do anything. When the application enters\nthe posts state, we want it to connect the {{outlet}} in the\napplication template. We accomplish this using the connectOutlets\ncallback.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  App.Router = Ember.Router.extend({\n  root: Ember.Route.extend({\n    index: Ember.Route.extend({\n      route: '/',\n      redirectsTo: 'posts'\n    }),\n\n    posts: Ember.Route.extend({\n      route: '/posts',\n\n      connectOutlets: function(router) {\n        router.get('applicationController').connectOutlet('posts', App.Post.find());\n      }\n    }),\n\n    post: Ember.Route.extend({\n      route: '/posts/:post_id'\n    })\n  })\n});\n\n\n\nThis connectOutlet call does a few things for us:\n\n\nIt creates a new instance of App.PostsView, using the\nposts.handlebars template.\nIt sets the model property of postsController to a list of all\nof the available posts (App.Post.find()) and makes postsController\nthe controller for the new App.PostsView.\nIt connects the new view to the outlet in application.handlebars.\n\n\nIn general, you should just think of these objects as operating in\ntandem. You will always provide the model for a view's controller when\nyou create a view.\nTransitions and URLs\nNext, we will want to provide a way for an application in the posts\nstate to move into the post state. We accomplish this by specifying a\ntransition.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  posts: Ember.Route.extend({\n  route: '/posts',\n  showPost: Ember.Route.transitionTo('post'),\n\n  connectOutlets: function(router) {\n    router.get('applicationController').connectOutlet('posts', App.Post.find());\n  }\n})\n\n\n\nYou invoke this transition by using the {{action}} helper in the\ncurrent template.\n\n  1\n2\n3\n\n  {{#each post in controller}}\n  \u003ch1\u003e\u003ca {{action 'showPost' post href=true}}\u003e{{post.title}}\u003c/a\u003e\u003c/h1\u003e\n{{/each}}\n\n\n\nWhen a user clicks on a link with an {{action}} helper, Ember will\ndispatch an event to the current state with the specified name. In this\ncase, the event is a transition.\n\nBecause we used a transition, Ember was also able to generate a URL for\nthis link. Ember uses the id property of the context to fill in the\n:post_id dynamic segment of the post state.\n\nNext, we will need to implement connectOutlets on the post state.\nThis time, the connectOutlets method will receive the post object\nspecified as the context to the {{action}} helper.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  post: Ember.Route.extend({\n  route: '/posts/:post_id',\n\n  connectOutlets: function(router, post) {\n    router.get('applicationController').connectOutlet('post', post);\n  }\n})\n\n\n\nTo recap, the connectOutlet call performs a number of steps:\n\n\nIt creates a new instance of App.PostView, using the\npost.handlebars template.\nIt sets the model property of postController to the post that\nthe user clicked on.\nIt connects the new view to the outlet in application.handlebars.\n\n\nYou don't have to do anything else to get the link (/posts/1) to work\nif the user saves it as a bookmark and comes back to it later.\n\nIf the user enters the page for the first time with the URL /posts/1,\nthe router will perform a few steps:\n\n\nFigure out what state the URL corresponds with (in this case, post)\nExtract the dynamic segment (in this case :post_id) from the URL and\ncall App.Post.find(post_id). This works using a naming convention:\nthe :post_id dynamic segment corresponds to App.Post.\nCall connectOutlets with the return value of App.Post.find.\n\n\nThis means that regardless of whether the user enters the post state\nfrom another part of the page or through a URL, the router will invoke\nthe connectOutlets method with the same object.\nNesting\nFinally, let's implement the comments and trackbacks functionality.\n\nBecause the post state uses the same pattern as the root state, it\nwill look very similar.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n  post: Ember.Route.extend({\n  route: '/posts/:post_id',\n\n  connectOutlets: function(router, post) {\n    router.get('applicationController').connectOutlet('post', post);\n  },\n\n  index: Ember.Route.extend({\n    route: '/',\n    redirectsTo: 'comments'\n  }),\n\n  comments: Ember.Route.extend({\n    route: '/comments',\n    showTrackbacks: Ember.Route.transitionTo('trackbacks'),\n\n    connectOutlets: function(router) {\n      var postController = router.get('postController');\n      postController.connectOutlet('comments', postController.get('comments'));\n    }\n  }),\n\n  trackbacks: Ember.Route.extend({\n    route: '/trackbacks',\n    showComments: Ember.Route.transitionTo('comments'),\n\n    connectOutlets: function(router) {\n      var postController = router.get('postController');\n      postController.connectOutlet('trackbacks', postController.get('trackbacks'));\n    }\n  })\n})\n\n\n\nThere are only a few changes here:\n\n\nWe specify the showTrackbacks and showComments transitions only in\nthe states where transitioning makes sense.\nSince we are setting the view for the outlet in post.handlebars, we\ncall connectOutlet on postController\nIn this case, we get the content for the commentsController and\ntrackbacksController from the current post. The postController is\na proxy for the underlying Post, so we can retrieve the associations\ndirectly from the postController.\n\n\nHere's the template for an individual post.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\n\u003cdiv class=\"body\"\u003e\n  {{body}}\n\u003c/div\u003e\n\n\u003cp\u003e\n  \u003ca {{action 'showComments' href=true}}\u003eComments\u003c/a\u003e |\n  \u003ca {{action 'showTrackbacks' href=true}}\u003eTrackbacks\u003c/a\u003e\n\u003c/p\u003e\n\n{{outlet}}\n\n\n\nAnd finally, coming back from a bookmarked link will work fine with this\nnested setup. Let's take a look at what happens when the user enters the\nsite at /posts/1/trackbacks.\n\n\nThe router determines what state the URL corresponds with\n(post.trackbacks), and enters the state.\nFor each state along the way, the router extracts any dynamic segments\nand calls connectOutlets. This mirrors the path a user would take as\nthey move through the application. As before, the router will call the\nconnectOutlet method on the post with App.Post.find(1).\nWhen the router gets to the trackbacks state, it will invoke\nconnectOutlets. Because the connectOutlets method for post has\nset the model of the postController, the trackbacks state will\nretrieve the association.\n\n\nAgain, because of the way the connectOutlets callback works with\ndynamic URL segments, the URL generated by an {{action}} helper is\nguaranteed to work later.\nAsynchrony\nOne final point: you might be asking yourself how this system can work\nif the app has not yet loaded Post 1 by the time App.Post.find(1) is\ncalled.\n\nThe reason this works is that ember-data always returns an object\nimmediately, even if it needs to kick off a query. That object starts\noff with an empty data hash. When the server returns the data,\nember-data updates the object's data, which also triggers bindings on\nall defined attributes (properties defined using DS.attr).\n\nWhen you ask this object for its trackbacks, it will likewise return\nan empty ManyArray. When the server returns the associated content\nalong with the post, ember-data will also automatically update the\ntrackbacks array.\n\nIn your trackbacks.handlebars template, you will have done something\nlike:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n{{#each trackback in controller}}\n  \u003cli\u003e\u003ca {{bind-attr href=\"trackback.url\"}}\u003e{{trackback.title}}\u003c/a\u003e\u003c/li\u003e\n{{/each}}\n\u003c/ul\u003e\n\n\n\nWhen ember-data updates the trackbacks array, the change will\npropagate through the trackbacksController and into the DOM.\n\nYou may also want to avoid showing partial data that is not yet loaded.\nIn that case, you could do something like:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  \u003cul\u003e\n{{#if controller.isLoaded}}\n  {{#each trackback in controller}}\n    \u003cli\u003e\u003ca {{bind-attr href=\"trackback.url\"}}\u003e{{trackback.title}}\u003c/a\u003e\u003c/li\u003e\n  {{/each}}\n{{else}}\n  \u003cli\u003e\u003cimg src=\"/spinner.gif\"\u003e Loading trackbacks...\u003c/li\u003e\n{{/if}}\n\u003c/ul\u003e\n\n\n\nWhen ember-data populates the ManyArray for the trackbacks from the\nserver-provided data, it also sets the isLoaded property. Because all\ntemplate constructs, including #if automatically update the DOM if the\nunderlying property changes, this will \"just work\".\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e8575da25c245b0db47207c6725bc110","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/wip/rails/","type":"enum"},{"name":"body","value":"THIS GUIDE IS NOT YET FUNCTIONAL OR COMPLETEPLEASE DO NOT USEGetting Started with Ember.js and Ruby on Rails\nBefore getting started with this guide, you should have the latest version of Ruby on Rails installed (which is 3.2.3 at the time of writing). If you don't already have Ruby on Rails, you can follow the instructions available on the Rails website.\n\nIn this guide, we'll show you how to build a simple, personal photoblog application using Ember.js and Ruby on Rails.\nConcepts\nEmber.js is a front-end javascript model-view-controller framework. It is designed to help you create ambitious web applications which run inside the browser. These applications can use AJAX as their primary mechanism for communicating with an API, much like a desktop or mobile application.\n\nRuby on Rails is a Ruby-based full stack web framework. It also uses a model-view-controller paradigm to architect applications built on top of it, but in a much different way than Ember.js. The differences are beyond the scope of this guide, but you can read about them in our Ember MVC guide. What is critical to understand is that Ruby on Rails runs on the server, not the client. It is an excellent platform to build websites and APIs.\n\nIn the next few steps, we'll create a Ruby on Rails application which does two distinct but equally important things: It acts as a host for the Ember.js application we will write, and it acts as an API with which the application will communicate. \n\nIt's worth noting that it's not at all necessary to host an Ember.js application using Ruby on Rails. It can be served from any standard web server (or a local file.)\nCreating a New Project\nUse the rails command to generate a new project:\n\n  1\n\n  rails new photoblog -m http://emberjs.com/template.rb\n\n\n\nThe -m option specifies a template on which to base your new project. We have provided one for Ember.js apps which does the following:\n\n\nLoads the ember-rails and active_model_serializers gems\nRuns bundle install\nGenerates an appropriate directory structure inside app/assets/javascripts/\nGenerates an AssetsController and supplies an appropriate route in order to serve your application\nGenerates an appropirate ApplicationSerializer for Ember.js' RESTAdapter.\n\n\nWhen rails has finished creating your application it will reside in the photoblog directory. Switch to this newly created directory:\n\n  1\n\n  cd photoblog\n\n\nCreating the Server-side Models\nThis part will be familiar to anyone who has done Ruby on Rails development before. We'll create two new models, Photo and Comment. We start by asking Rails to generate the scaffolding for a Photo object.\n\n  1\n\n  rails generate scaffold Photo title:string url:string\n\n\n\nRails will generate a database migration, model, controller, resource routes, and other helpful files for us to start using. It will actually create more than we need: By default, rails scaffolding will generate standard CRUD (Create/Retrieve/Update/Destroy) views for our new model. Since our Ember.js application is going to be providing these views, we can safely remove them.\n\n  1\n\n  rm -rf app/views/photos\n\n\n\nWe should also ask Rails to generate our comment object and remove its views as well.\n\n  1\n2\n\n  rails generate scaffold Comment text:string\nrm -rf app/views/comments\n\n\n\nWe should now describe the accessible fields and the relationship of our models to Rails. In app/models/photo.rb, add the appropriate lines below:\n\n  1\n2\n3\n4\n\n  class Photo \u003c ActiveRecord::Base\n  attr_accessible :title, :url\n  has_many :comments\nend\n\n\n\nAnd in app/models/comment.rb:\n\n  1\n2\n3\n4\n\n  class Comment \u003c ActiveRecord::Base\n  attr_accessible :text, :photo_id\n  belongs_to :photo\nend\n\n\n\nIf we look inside db/migrate, you'll see the database migrations that have been generated for us. We'll need to modify the \u003cdatetime\u003e_create_comments.rb file to reference our photo model. \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  class CreateComments \u003c ActiveRecord::Migration\n  def change\n    create_table :comments do |t|\n      t.string :text\n      t.references :photo\n      t.timestamps\n    end\n  end\nend\n\n\n\nWe can now run rake db:migrate to run these migrations and set up our database.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  → rake db:migrate\n==  CreatePhotos: migrating ===================================================\n-- create_table(:photos)\n   -\u003e 0.0184s\n==  CreatePhotos: migrated (0.0185s) ==========================================\n\n==  CreateComments: migrating =================================================\n-- create_table(:comments)\n   -\u003e 0.0015s\n==  CreateComments: migrated (0.0016s) ========================================\n\n\n\nOur server-side models are now setup and ready for use! What we've done here is basically create a  API server that allows basic CRUD actions for our photo and comment models.\nCreating our Client-side Models\nNow that we have models set up to persist our data on the server, we need to describe them to Ember. ember-rails, included with our project template, provides generators to help us with this.\n\n  1\n\n  rails generate ember:model Photo title:string url:string\n\n\n\n  1\n\n  rails generate ember:model Comment text:string\n\n\n\nThis creates the appropriate Ember.js models in app/assets/javascripts/models. We'll need to describe the relationship between them by hand. To do this, we can use DS.hasMany and DS.belongsTo. We pass string which represent the path of the model class, in this case, Photoblog.Comment and Photoblog.Photo, respectively.\n\n  1\n2\n3\n4\n5\n\n  Photoblog.Photo = DS.Model.extend({\n  title: DS.attr('string'),\n  url: DS.attr('string'),\n  comments: DS.hasMany('Photoblog.Comment')\n});\n\n\n\n  1\n2\n3\n4\n\n  Photoblog.Comment = DS.Model.extend({\n  text: DS.attr('string'),\n  photo: DS.belongsTo('Photoblog.Photo')\n});\n\n\n\nThat's it! ember-data now knows about the structure of our data.\nSetting up the State Manager\nOur Ember.js application will be managed by a state manager. The state manger handles what view is currently being displayed, as well as some other application login. Our default template will have created one for us at app/assets/javascripts/states/app_states.js. We'll want to modify it to look like this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n  Photoblog.StateManager = Ember.StateManager.extend({\n  initialState: 'start',\n\n  states: {\n    start: Ember.State.extend({\n      ready: function(manager) {\n        var store = DS.Store.create({\n          adapter: DS.RESTAdapter.create(),\n          revision: 4\n        });\n\n        manager.set('store', store);\n\n        var photos = store.find(Photoblog.Photo);\n        manager.photosController.set('model', photos);\n\n        store.adapter.mappings = {\n          comments: Photoblog.Comment\n        };\n\n        manager.goToState('photos');\n      }\n    }),\n\n    photos: Ember.State.create({\n      initialState: 'index',\n\n      index: Ember.State.create({\n        view: function() {\n          return Photoblog.IndexView.create()\n        }.property()\n      })\n\n    }) // End Photos state\n\n  } // End States\n\n});\n\n\n\nHere, we're defining a state manager for our application. We set up our states object and include two states, start and photos. start is set as the initial state, and it handles only one event, called ready. In ready, it creates and configures our data store, and then it goes to the photos state. The photos state itself has a single substate, called index. This state is set as the initial substate for the photos parent state. The index substate has a single property, called 'view' which we are going to set to a new Photoblog.IndexView, which will show an index of all our photos. We haven't written that yet, so lets do that.\nCreating the Index View\nTo see all our photos, we need an write an index view which shows them.  We have a generator that will help us with this.\n\n  1\n\n  rails generate ember:view index photos\n\n\n\nNote that we pass two additional arguments after 'ember:view', index and photos. index specifies the name of the view, and photos specifies the name of the owning controller. We'll get to that in the next step. \n\nOur generator creates two new files, one at app/assets/javascripts/templates/photos/index.handlebars and one at app/assets/javascripts/views/photos/index_view.js. First, let's look at the the app/assets/javascripts/views/photos/index_view.js.\n\n  1\n2\n3\n4\n\n  Photoblog.IndexView = Ember.View.extend({\n  templateName: 'photos/index',\n  controller: Photoblog.photosController\n});\n\n\n\nThis is where we define the Ember.js object which manages the view. We simply provide it with a templateName property, which points to our handlebars template, and a controller property, which manages the view. Here's the template that defines what the index view looks like. Make yours look like the following:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  \u003ch1\u003eMy Photoblog\u003c/h1\u003e\n\n{{#each controller}}\n  {{#view}}\n    \u003cdiv class=\"photo\"\u003e\n      \u003ch2\u003e{{title}}\u003c/h2\u003e\n      \u003cimg {{bind-attr src=\"url\"}}\u003e\n      \u003cbr\u003e\n      {{#if comments.length}}\n        \u003ch3\u003eComments\u003c/h3\u003e\n        \u003cul\u003e\n          {{#each comments}}\n            \u003cli\u003e{{text}}\u003c/li\u003e\n          {{/each}}\n        \u003c/ul\u003e\n      {{/if}}\n    \u003c/div\u003e\n  {{/view}}\n{{/each}}\n\n\n\nLet's go break this down and explain what's gong on.\n\n  1\n2\n3\n\n  \u003ch1\u003eMy Photoblog\u003c/h1\u003e\n\n{{#each controller}}\n\n\n\nOur view has a controller, the Photoblog.photosController, which will create in the next step. This is an Ember.ArrayController, so it implements the Ember.Enumerable interface. This means that we can loop over its contents (each element of the array) using the #each Handlebars expression.\n\n  1\n\n  {{#view}}\n\n\n\nFor each photo managed by the photosController, we will create a subview with the following contents. The {{#view}} helper doesn't change context, so it's not necessary to set any bindings.\n\n  1\n2\n3\n4\n\n      \u003cdiv class=\"photo\"\u003e\n      \u003ch2\u003e{{title}}\u003c/h2\u003e\n      \u003cimg {{bind-attr src=\"url\"}}\u003e\n      \u003cbr\u003e\n\n\n\nHere, we reference our photo to get its title, and user bind-attr to set the \u003cimg\u003e tag's src attribute to the photo's url.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n        {{#if comments.length}}\n        \u003ch3\u003eComments\u003c/h3\u003e\n        \u003cul\u003e\n          {{#each comments}}\n            \u003cli\u003e{{text}}\u003c/li\u003e\n          {{/each}}\n        \u003c/ul\u003e\n      {{/if}}\n\n\n\nNext, we see if there are any comments on the photo. If there are, we create a section and list for comments, and iterate through them. Note that in this {{#each}} expression, we aren't binding the comment object to the model property, so the context is automatically set to it. We create a new \u003cli\u003e for each comment with the comments text, and close out our {{#each}} iteration, list, and {{#if}}.\n\n  1\n2\n\n    {{/view}}\n{{/each}}\n\n\n\nNow that we're done, we close out the subview and our iteration block. Our view is complete.\nCreating our Client-side Controller\nControllers serve as a mediator between your views and models. We've already discussed that we're going to need an Ember.ArrayController to manage our photo objects, so let's create it. You can create a new controller using the ember:controller generator. We can also create a new array controller by invoking the generator with the --array option:\n\n  1\n\n  rails generate ember:controller photos --array\n\n\n\nThis will generate a new array controller called Photoblog.photosController inside the app/assets/javascripts/controllers/photos_controller.js file. Note that this file also creates a class called Photoblog.PhotosController. This allows you to easily create new instances of the controller for unit testing without having to reset singletons to their original state.\n\nThe Ember.ArrayController provides us with all the functionality we need for now, so no extra code is needed.\nLoading the App\nWe've now gone through the process of describe out models, views, and controllers to Ember and Rails. Let's get things off the ground by viewing our application!\n\nThe Rails template that we based out application off of came with a Rails controller called AssetsController and an associated view and route. This is designed to simply serve our application content, which is basically an empty page with the javascript code which will launch and run our app.\n\nThe last thing for us to do is to add the bootstraping code for our app. In assets/javascripts/application.js, we should append the following:\n\n  1\n2\n3\n4\n\n    Photoblog.photosView = Ember.ContainerView.create({\n    currentViewBinding: 'Photoblog.stateManager.currentState.view'\n  });\n  Photoblog.photosView.append();\n\n\n\nWe're doing a few things here. First, we're getting all the photos in our data store, and setting the model of our photosController to the results array. Next, we set the data store's adapter mappings so that it knows comments are Photoblog.Comments. We then move to our initial state, and create an Ember.ContainerView with a currentView property that is bound to our current state's view property. Finally, add the photosView to the page.\n\nYou can now view the app in your browser by running rails server going to http://localhost:3000. You should see something like this:\n\n\n\nThere's our title, but there's no content! We need to add some photos first, of course.\nAdding a Test Photo\nWe need to add the ability to add photos to our application in order to see some on the index page. First, let's verify everything is working as expected by sending a POST request to our API with a new photo object. Ensure the server is running, and execute the following command:\n\n  1\n\n  curl -H \"Content-Type: application/json\" -X POST -d '{\"photo\":{\"url\":\"http://farm8.staticflickr.com/7101/7007178689_9cd571fa10.jpg\", \"title\":\"Books\"}}' http://localhost:3000/photos\n\n\n\nThis sends a json payload to our server with data for a new photo. Reload the page. You should see a new photo with its title listed on the index page. You'll also see the logs in the console where your server is running, showing the request being handled. If you don't see the photo, jump down to the troubleshooting section below.\n\nNow that we're sure everything is working, we want to be able to add photos through our Ember.js app. To do this, we'll write a new view.\nAdd the New Photo View\nWe want to add a button at the bottom of of our index view that lets us create a new photo. To do so, we'll write a new view, a template and controller for it, and add a new state to the state manager to represent the user being in the add photo state.\n\nFirst create the controller. A standard controller will work fine, we don't need an array controller in this case.\n\n  1\n\n  rails generate ember:controller photo\n\n\n\nNext, create the new view.\n\n  1\n\n  rails generate ember:view create photo\n\n\n\nModify the template for the create view at app/assets/javascripts/templates/photos/create.handlebars to look like this:\n\n  1\n2\n\n  \u003ch1\u003eAdd a New Photo\u003c/h1\u003e\n{{template \"photos/_form\"}}\n\n\n\nWe use the handlebars expression template to refer to another template we'd like to load, in this case, the _form template. This should be very familiar to rails users. You'll see why this is important later.\n\nLet's create the _form template in app/assets/javascripts/templates/photos/_form.handlebars. It will include only the form elements for our photo, like so:\n\n  1\n2\n3\n4\n5\n\n  \u003clabel for=\"title-field\"\u003eTitle:\u003c/label\u003e{{input id=\"title-field\" value=model.title}}\n\u003clabel for=\"url-field\"\u003eURL:\u003c/label\u003e{{input id=\"url-field\" value=model.url}}\n\n\u003cbutton {{action 'save' target=\"Photoblog.stateManager\"}}\u003eSave\u003c/button\u003e\n\u003cbutton {{action 'cancel' target=\"Photoblog.stateManager\"}}\u003eCancel\u003c/button\u003e\n\n\n\nWe create two Ember.TextField views, and we bind the value property (which will be the text in the text field) to that of our controllers' model's title and url objects, respectively. The controller is is the PhotoController, which we created above. Its model will be a photo object.\n\nWe then have a save button and cancel button, both of which target our state manager.\n\nNext, Take a look at the view in app/assets/javascripts/views/photos/create_view.js. It should reference both the template and the controller we just created.\n\n  1\n2\n3\n4\n\n  Photoblog.CreateView = Ember.View.extend({\n  templateName: 'photo/create',\n  controller: Photoblog.photoController\n});\n\n\n\nLet us now make the changes to our state manager to hook up all of these components together.\n\nInside our index state, we should add a new action, which tells our manager to go to the create state.\n\n  1\n2\n3\n\n  showCreate: function(manager) {\n  manager.goToState('create');\n}\n\n\n\nNote that you should always have actions within states that send the state manager to another state, as opposed to having other objects control the state manager. This allows for better encapsulation and more reusable code.\n\nNow, inside our photos parent state, we should add a new substate, called create.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n  create: Ember.State.create({\nview: Photoblog.CreateView.create(),\n\nenter: function(manager) {\n  var transaction = Photoblog.store.transaction();\n  var photo = transaction.createRecord(Photoblog.Photo);\n\n  manager.photoController.set('model', photo);\n  manager.set('transaction', transaction);\n},\n\nsave: function(manager) {\n  var transaction = manager.get('transaction');\n  transaction.commit();\n\n  manager.goToState('index');\n},\n\ncancel: function(manager) {\n  var transaction = manager.get('transaction');\n  transaction.rollback();\n\n  manager.goToState('index');\n}\n})\n\n\n\nLet's go through this and explain what's going on.\n\n  1\n2\n\n  create: Ember.State.create({\n    view: Photoblog.CreateView.create(),\n\n\n\nCreate a new state called create, which uses a new Photoblog. CreateView as its view.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  enter: function(manager) {\n  var store = manager.get('store');\n  var transaction = store.transaction();\n  var photo = transaction.createRecord(Photoblog.Photo);\n\n  manager.photoController.set('model', photo);\n  manager.set('transaction', transaction);\n},\n\n\n\nHere, we define the enter action of this state. enter and exit are special actions that are automatically called whenever the state manager enters or exits that particular state. Here, we set up a new transaction with our store, and create a new photo object from that transaction. We set it to be the model of our photoController, and save off the transaction for later use.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  save: function(manager) {\n  var transaction = manager.get('transaction');\n  transaction.commit();\n\n  manager.goToState('index');\n},\n\ncancel: function(manager) {\n  var transaction = manager.get('transaction');\n  transaction.rollback();\n\n  manager.goToState('index');\n}\n\n\n\nNow we define the save and cancel actions we referenced in our create view template earlier. Both of them get the current transaction, and the save action calls commit() where as the cancel action calls rollback(). commit() saves our photo object to the data store, which takes care of making the API request to save the data on our backend for us. rollback() undos any changes made in the transaction. Both actions then tell the manager to go back to the index state.\n\nFinally, we will add a button to the index template, at the very bottom, which tells our state manager to show the create view.\n\n  1\n\n  \u003cbutton {{action 'showCreate' target=\"Photoblog.stateManager\"}}\u003eAdd Photo\u003c/button\u003e\n\n\n\nWith all of this in place, ensure your server is running, and reload the index page. You should see a button at the bottom which takes you to our new create view and lets you add photos!\nAdd an Edit Photo View\nWe should have an edit view to let us modify photo titles at URLs. Creating this will be very similar to the previous step. We will add a view, a template, and modify the state manager. We can use the same photo controller we used in the previous step.\n\nFirst, lets add the new view at app/assets/javascripts/views/photos/edit_view.js\n\n  1\n2\n3\n4\n\n  Photoblog.EditView = Ember.View.extend({\n  templateName: 'templates/photos/edit',\n  controller: Photoblog.photoController\n});\n\n\n\nNow, we'll add the template for it at app/assets/javascripts/templates/photos/edit.handlebars.\n\n  1\n2\n\n  \u003ch1\u003eEdit a Photo\u003c/h1\u003e\n{{template \"templates/photos/_form\"}}\n\n\n\nNote that we can reuse our form elements from the previous step. The only thing that is different is the header text.\n\nNow, the bulk of our change is in the state manager. Below our create substate, lets add a new substate called edit:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n  edit: Ember.State.create({\n    view: Photoblog.EditView.create(),\n\n    enter: function(manager) {\n      var transaction = Photoblog.store.transaction();\n      var photo = Photoblog.photoController.get('model');\n      transaction.add(photo);\n\n      manager.set('transaction', transaction);\n    },\n\n    save: function(manager) {\n      var transaction = manager.get('transaction');\n      transaction.commit();\n\n      manager.goToState('index');\n    },\n\n    cancel: function(manager) {\n      var transaction = manager.get('transaction');\n      transaction.rollback();\n\n      manager.goToState('index');\n    }\n})\n\n\n\nMuch like in the previous step, we set a view property which is a new Photoblog.EditView.  The save and cancel actions are the same, but the enter action is a little bit different. Here, instead of creating a new record, we get the existing one from the photoController, and add it to our transaction.\n\nFurther up, in the state manager, we should add a function which lets us go from the index state to the edit state. In the index substate, add the following after showCreate:\n\n  1\n2\n3\n4\n5\n\n  showEdit: function(manager, evt) {\n  var photo = evt.context;\n  Photoblog.photoController.set('model', photo);\n  manager.goToState('edit');\n}\n\n\n\nEnsure that you add a comma to the previous showCreate. In this action, we're grabbing the photo from the event context and setting it to the model of our photoController.\n\nLastly, lets add an edit button to each photo on the page. Below the \u003cimg\u003e tag, add the following button, which targets our state manager's new showEdit action.\n\n  1\n\n  \u003ca href=\"#\" {{action 'showEdit' target=\"Photoblog.stateManager\"}}\u003eEdit Photo\u003c/a\u003e\n\n\n\nReload the page. There should now be an \"Edit Photo\" link below each photo that will take you to our new Edit Photo view.\nTroubleshooting\nWe'll update this page with common issues as they come up. In the mean time, see our Ember.js community page for more info on how to get help.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b5f51d33cd3395ca0535b566e778763a","fields":[{"name":"title","value":"","type":"string"},{"name":"url","value":"/guides/testing/unit/","type":"enum"},{"name":"body","value":"\n          \n            \n              \n              \n              \n            \n            \n              You are being redirected.\n            \n          \n        ","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]}]}